
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TagRule
 * 
 */
export type TagRule = $Result.DefaultSelection<Prisma.$TagRulePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model IncomeStream
 * 
 */
export type IncomeStream = $Result.DefaultSelection<Prisma.$IncomeStreamPayload>
/**
 * Model Debt
 * 
 */
export type Debt = $Result.DefaultSelection<Prisma.$DebtPayload>
/**
 * Model SavingsGoal
 * 
 */
export type SavingsGoal = $Result.DefaultSelection<Prisma.$SavingsGoalPayload>
/**
 * Model MandatorySavings
 * 
 */
export type MandatorySavings = $Result.DefaultSelection<Prisma.$MandatorySavingsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanItem
 * 
 */
export type PlanItem = $Result.DefaultSelection<Prisma.$PlanItemPayload>
/**
 * Model DebtPayment
 * 
 */
export type DebtPayment = $Result.DefaultSelection<Prisma.$DebtPaymentPayload>
/**
 * Model PlaidItem
 * 
 */
export type PlaidItem = $Result.DefaultSelection<Prisma.$PlaidItemPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagRuleTag
 * 
 */
export type TagRuleTag = $Result.DefaultSelection<Prisma.$TagRuleTagPayload>
/**
 * Model TransactionTag
 * 
 */
export type TransactionTag = $Result.DefaultSelection<Prisma.$TransactionTagPayload>
/**
 * Model IncomeStreamTag
 * 
 */
export type IncomeStreamTag = $Result.DefaultSelection<Prisma.$IncomeStreamTagPayload>
/**
 * Model DebtTag
 * 
 */
export type DebtTag = $Result.DefaultSelection<Prisma.$DebtTagPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountType: {
  CHECKING: 'CHECKING',
  SAVINGS: 'SAVINGS',
  CREDIT: 'CREDIT',
  CASH: 'CASH'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const CategoryKind: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  TRANSFER: 'TRANSFER'
};

export type CategoryKind = (typeof CategoryKind)[keyof typeof CategoryKind]


export const TagRuleMatchType: {
  CONTAINS: 'CONTAINS',
  REGEX: 'REGEX'
};

export type TagRuleMatchType = (typeof TagRuleMatchType)[keyof typeof TagRuleMatchType]


export const TagRuleSourceField: {
  MERCHANT: 'MERCHANT',
  NOTE: 'NOTE'
};

export type TagRuleSourceField = (typeof TagRuleSourceField)[keyof typeof TagRuleSourceField]


export const BudgetPeriod: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type BudgetPeriod = (typeof BudgetPeriod)[keyof typeof BudgetPeriod]


export const BillFrequency: {
  MONTHLY: 'MONTHLY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  YEARLY: 'YEARLY',
  ONE_OFF: 'ONE_OFF'
};

export type BillFrequency = (typeof BillFrequency)[keyof typeof BillFrequency]


export const SubscriptionFrequency: {
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type SubscriptionFrequency = (typeof SubscriptionFrequency)[keyof typeof SubscriptionFrequency]


export const IncomeCadence: {
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY'
};

export type IncomeCadence = (typeof IncomeCadence)[keyof typeof IncomeCadence]


export const SavingsRuleType: {
  FIXED_MONTHLY: 'FIXED_MONTHLY',
  FIXED_PER_PAYCHECK: 'FIXED_PER_PAYCHECK',
  PERCENT_OF_INCOME: 'PERCENT_OF_INCOME'
};

export type SavingsRuleType = (typeof SavingsRuleType)[keyof typeof SavingsRuleType]


export const PlanStrategy: {
  AVALANCHE: 'AVALANCHE',
  SNOWBALL: 'SNOWBALL',
  HYBRID: 'HYBRID',
  CUSTOM: 'CUSTOM'
};

export type PlanStrategy = (typeof PlanStrategy)[keyof typeof PlanStrategy]


export const PlanItemType: {
  INCOME: 'INCOME',
  BILL: 'BILL',
  SUBSCRIPTION: 'SUBSCRIPTION',
  DEBT_MIN: 'DEBT_MIN',
  DEBT_EXTRA: 'DEBT_EXTRA',
  SAVINGS: 'SAVINGS',
  NOTE: 'NOTE'
};

export type PlanItemType = (typeof PlanItemType)[keyof typeof PlanItemType]

}

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type CategoryKind = $Enums.CategoryKind

export const CategoryKind: typeof $Enums.CategoryKind

export type TagRuleMatchType = $Enums.TagRuleMatchType

export const TagRuleMatchType: typeof $Enums.TagRuleMatchType

export type TagRuleSourceField = $Enums.TagRuleSourceField

export const TagRuleSourceField: typeof $Enums.TagRuleSourceField

export type BudgetPeriod = $Enums.BudgetPeriod

export const BudgetPeriod: typeof $Enums.BudgetPeriod

export type BillFrequency = $Enums.BillFrequency

export const BillFrequency: typeof $Enums.BillFrequency

export type SubscriptionFrequency = $Enums.SubscriptionFrequency

export const SubscriptionFrequency: typeof $Enums.SubscriptionFrequency

export type IncomeCadence = $Enums.IncomeCadence

export const IncomeCadence: typeof $Enums.IncomeCadence

export type SavingsRuleType = $Enums.SavingsRuleType

export const SavingsRuleType: typeof $Enums.SavingsRuleType

export type PlanStrategy = $Enums.PlanStrategy

export const PlanStrategy: typeof $Enums.PlanStrategy

export type PlanItemType = $Enums.PlanItemType

export const PlanItemType: typeof $Enums.PlanItemType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.tagRule`: Exposes CRUD operations for the **TagRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagRules
    * const tagRules = await prisma.tagRule.findMany()
    * ```
    */
  get tagRule(): Prisma.TagRuleDelegate<ExtArgs>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.incomeStream`: Exposes CRUD operations for the **IncomeStream** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomeStreams
    * const incomeStreams = await prisma.incomeStream.findMany()
    * ```
    */
  get incomeStream(): Prisma.IncomeStreamDelegate<ExtArgs>;

  /**
   * `prisma.debt`: Exposes CRUD operations for the **Debt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debts
    * const debts = await prisma.debt.findMany()
    * ```
    */
  get debt(): Prisma.DebtDelegate<ExtArgs>;

  /**
   * `prisma.savingsGoal`: Exposes CRUD operations for the **SavingsGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavingsGoals
    * const savingsGoals = await prisma.savingsGoal.findMany()
    * ```
    */
  get savingsGoal(): Prisma.SavingsGoalDelegate<ExtArgs>;

  /**
   * `prisma.mandatorySavings`: Exposes CRUD operations for the **MandatorySavings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MandatorySavings
    * const mandatorySavings = await prisma.mandatorySavings.findMany()
    * ```
    */
  get mandatorySavings(): Prisma.MandatorySavingsDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.planItem`: Exposes CRUD operations for the **PlanItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanItems
    * const planItems = await prisma.planItem.findMany()
    * ```
    */
  get planItem(): Prisma.PlanItemDelegate<ExtArgs>;

  /**
   * `prisma.debtPayment`: Exposes CRUD operations for the **DebtPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtPayments
    * const debtPayments = await prisma.debtPayment.findMany()
    * ```
    */
  get debtPayment(): Prisma.DebtPaymentDelegate<ExtArgs>;

  /**
   * `prisma.plaidItem`: Exposes CRUD operations for the **PlaidItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaidItems
    * const plaidItems = await prisma.plaidItem.findMany()
    * ```
    */
  get plaidItem(): Prisma.PlaidItemDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.tagRuleTag`: Exposes CRUD operations for the **TagRuleTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagRuleTags
    * const tagRuleTags = await prisma.tagRuleTag.findMany()
    * ```
    */
  get tagRuleTag(): Prisma.TagRuleTagDelegate<ExtArgs>;

  /**
   * `prisma.transactionTag`: Exposes CRUD operations for the **TransactionTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionTags
    * const transactionTags = await prisma.transactionTag.findMany()
    * ```
    */
  get transactionTag(): Prisma.TransactionTagDelegate<ExtArgs>;

  /**
   * `prisma.incomeStreamTag`: Exposes CRUD operations for the **IncomeStreamTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomeStreamTags
    * const incomeStreamTags = await prisma.incomeStreamTag.findMany()
    * ```
    */
  get incomeStreamTag(): Prisma.IncomeStreamTagDelegate<ExtArgs>;

  /**
   * `prisma.debtTag`: Exposes CRUD operations for the **DebtTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtTags
    * const debtTags = await prisma.debtTag.findMany()
    * ```
    */
  get debtTag(): Prisma.DebtTagDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Category: 'Category',
    Transaction: 'Transaction',
    TagRule: 'TagRule',
    Budget: 'Budget',
    Bill: 'Bill',
    Subscription: 'Subscription',
    IncomeStream: 'IncomeStream',
    Debt: 'Debt',
    SavingsGoal: 'SavingsGoal',
    MandatorySavings: 'MandatorySavings',
    Notification: 'Notification',
    Plan: 'Plan',
    PlanItem: 'PlanItem',
    DebtPayment: 'DebtPayment',
    PlaidItem: 'PlaidItem',
    Tag: 'Tag',
    TagRuleTag: 'TagRuleTag',
    TransactionTag: 'TransactionTag',
    IncomeStreamTag: 'IncomeStreamTag',
    DebtTag: 'DebtTag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "category" | "transaction" | "tagRule" | "budget" | "bill" | "subscription" | "incomeStream" | "debt" | "savingsGoal" | "mandatorySavings" | "notification" | "plan" | "planItem" | "debtPayment" | "plaidItem" | "tag" | "tagRuleTag" | "transactionTag" | "incomeStreamTag" | "debtTag"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TransactionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TransactionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TagRule: {
        payload: Prisma.$TagRulePayload<ExtArgs>
        fields: Prisma.TagRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>
          }
          findFirst: {
            args: Prisma.TagRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>
          }
          findMany: {
            args: Prisma.TagRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>[]
          }
          create: {
            args: Prisma.TagRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>
          }
          createMany: {
            args: Prisma.TagRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>
          }
          update: {
            args: Prisma.TagRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>
          }
          deleteMany: {
            args: Prisma.TagRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRulePayload>
          }
          aggregate: {
            args: Prisma.TagRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagRule>
          }
          groupBy: {
            args: Prisma.TagRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagRuleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TagRuleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TagRuleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TagRuleCountArgs<ExtArgs>
            result: $Utils.Optional<TagRuleCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BudgetFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BudgetAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BillFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BillAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubscriptionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubscriptionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      IncomeStream: {
        payload: Prisma.$IncomeStreamPayload<ExtArgs>
        fields: Prisma.IncomeStreamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeStreamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeStreamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>
          }
          findFirst: {
            args: Prisma.IncomeStreamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeStreamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>
          }
          findMany: {
            args: Prisma.IncomeStreamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>[]
          }
          create: {
            args: Prisma.IncomeStreamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>
          }
          createMany: {
            args: Prisma.IncomeStreamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IncomeStreamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>
          }
          update: {
            args: Prisma.IncomeStreamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>
          }
          deleteMany: {
            args: Prisma.IncomeStreamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeStreamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncomeStreamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamPayload>
          }
          aggregate: {
            args: Prisma.IncomeStreamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncomeStream>
          }
          groupBy: {
            args: Prisma.IncomeStreamGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeStreamGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IncomeStreamFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IncomeStreamAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IncomeStreamCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeStreamCountAggregateOutputType> | number
          }
        }
      }
      Debt: {
        payload: Prisma.$DebtPayload<ExtArgs>
        fields: Prisma.DebtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          findFirst: {
            args: Prisma.DebtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          findMany: {
            args: Prisma.DebtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>[]
          }
          create: {
            args: Prisma.DebtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          createMany: {
            args: Prisma.DebtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DebtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          update: {
            args: Prisma.DebtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          deleteMany: {
            args: Prisma.DebtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DebtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          aggregate: {
            args: Prisma.DebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebt>
          }
          groupBy: {
            args: Prisma.DebtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DebtFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DebtAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DebtCountArgs<ExtArgs>
            result: $Utils.Optional<DebtCountAggregateOutputType> | number
          }
        }
      }
      SavingsGoal: {
        payload: Prisma.$SavingsGoalPayload<ExtArgs>
        fields: Prisma.SavingsGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavingsGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavingsGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>
          }
          findFirst: {
            args: Prisma.SavingsGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavingsGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>
          }
          findMany: {
            args: Prisma.SavingsGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>[]
          }
          create: {
            args: Prisma.SavingsGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>
          }
          createMany: {
            args: Prisma.SavingsGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SavingsGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>
          }
          update: {
            args: Prisma.SavingsGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>
          }
          deleteMany: {
            args: Prisma.SavingsGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavingsGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavingsGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavingsGoalPayload>
          }
          aggregate: {
            args: Prisma.SavingsGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavingsGoal>
          }
          groupBy: {
            args: Prisma.SavingsGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavingsGoalGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SavingsGoalFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SavingsGoalAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SavingsGoalCountArgs<ExtArgs>
            result: $Utils.Optional<SavingsGoalCountAggregateOutputType> | number
          }
        }
      }
      MandatorySavings: {
        payload: Prisma.$MandatorySavingsPayload<ExtArgs>
        fields: Prisma.MandatorySavingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MandatorySavingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MandatorySavingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>
          }
          findFirst: {
            args: Prisma.MandatorySavingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MandatorySavingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>
          }
          findMany: {
            args: Prisma.MandatorySavingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>[]
          }
          create: {
            args: Prisma.MandatorySavingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>
          }
          createMany: {
            args: Prisma.MandatorySavingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MandatorySavingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>
          }
          update: {
            args: Prisma.MandatorySavingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>
          }
          deleteMany: {
            args: Prisma.MandatorySavingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MandatorySavingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MandatorySavingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatorySavingsPayload>
          }
          aggregate: {
            args: Prisma.MandatorySavingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMandatorySavings>
          }
          groupBy: {
            args: Prisma.MandatorySavingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MandatorySavingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MandatorySavingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MandatorySavingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MandatorySavingsCountArgs<ExtArgs>
            result: $Utils.Optional<MandatorySavingsCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlanFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlanAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanItem: {
        payload: Prisma.$PlanItemPayload<ExtArgs>
        fields: Prisma.PlanItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>
          }
          findFirst: {
            args: Prisma.PlanItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>
          }
          findMany: {
            args: Prisma.PlanItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>[]
          }
          create: {
            args: Prisma.PlanItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>
          }
          createMany: {
            args: Prisma.PlanItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>
          }
          update: {
            args: Prisma.PlanItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>
          }
          deleteMany: {
            args: Prisma.PlanItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanItemPayload>
          }
          aggregate: {
            args: Prisma.PlanItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanItem>
          }
          groupBy: {
            args: Prisma.PlanItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlanItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlanItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlanItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlanItemCountAggregateOutputType> | number
          }
        }
      }
      DebtPayment: {
        payload: Prisma.$DebtPaymentPayload<ExtArgs>
        fields: Prisma.DebtPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          findFirst: {
            args: Prisma.DebtPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          findMany: {
            args: Prisma.DebtPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>[]
          }
          create: {
            args: Prisma.DebtPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          createMany: {
            args: Prisma.DebtPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DebtPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          update: {
            args: Prisma.DebtPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          deleteMany: {
            args: Prisma.DebtPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DebtPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          aggregate: {
            args: Prisma.DebtPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtPayment>
          }
          groupBy: {
            args: Prisma.DebtPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtPaymentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DebtPaymentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DebtPaymentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DebtPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<DebtPaymentCountAggregateOutputType> | number
          }
        }
      }
      PlaidItem: {
        payload: Prisma.$PlaidItemPayload<ExtArgs>
        fields: Prisma.PlaidItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaidItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaidItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>
          }
          findFirst: {
            args: Prisma.PlaidItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaidItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>
          }
          findMany: {
            args: Prisma.PlaidItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>[]
          }
          create: {
            args: Prisma.PlaidItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>
          }
          createMany: {
            args: Prisma.PlaidItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlaidItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>
          }
          update: {
            args: Prisma.PlaidItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>
          }
          deleteMany: {
            args: Prisma.PlaidItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaidItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaidItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaidItemPayload>
          }
          aggregate: {
            args: Prisma.PlaidItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaidItem>
          }
          groupBy: {
            args: Prisma.PlaidItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaidItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlaidItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlaidItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlaidItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlaidItemCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagRuleTag: {
        payload: Prisma.$TagRuleTagPayload<ExtArgs>
        fields: Prisma.TagRuleTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagRuleTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagRuleTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>
          }
          findFirst: {
            args: Prisma.TagRuleTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagRuleTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>
          }
          findMany: {
            args: Prisma.TagRuleTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>[]
          }
          create: {
            args: Prisma.TagRuleTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>
          }
          createMany: {
            args: Prisma.TagRuleTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagRuleTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>
          }
          update: {
            args: Prisma.TagRuleTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>
          }
          deleteMany: {
            args: Prisma.TagRuleTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagRuleTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagRuleTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagRuleTagPayload>
          }
          aggregate: {
            args: Prisma.TagRuleTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagRuleTag>
          }
          groupBy: {
            args: Prisma.TagRuleTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagRuleTagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TagRuleTagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TagRuleTagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TagRuleTagCountArgs<ExtArgs>
            result: $Utils.Optional<TagRuleTagCountAggregateOutputType> | number
          }
        }
      }
      TransactionTag: {
        payload: Prisma.$TransactionTagPayload<ExtArgs>
        fields: Prisma.TransactionTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          findFirst: {
            args: Prisma.TransactionTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          findMany: {
            args: Prisma.TransactionTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>[]
          }
          create: {
            args: Prisma.TransactionTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          createMany: {
            args: Prisma.TransactionTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          update: {
            args: Prisma.TransactionTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          deleteMany: {
            args: Prisma.TransactionTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          aggregate: {
            args: Prisma.TransactionTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionTag>
          }
          groupBy: {
            args: Prisma.TransactionTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionTagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TransactionTagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TransactionTagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TransactionTagCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionTagCountAggregateOutputType> | number
          }
        }
      }
      IncomeStreamTag: {
        payload: Prisma.$IncomeStreamTagPayload<ExtArgs>
        fields: Prisma.IncomeStreamTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeStreamTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeStreamTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>
          }
          findFirst: {
            args: Prisma.IncomeStreamTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeStreamTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>
          }
          findMany: {
            args: Prisma.IncomeStreamTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>[]
          }
          create: {
            args: Prisma.IncomeStreamTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>
          }
          createMany: {
            args: Prisma.IncomeStreamTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IncomeStreamTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>
          }
          update: {
            args: Prisma.IncomeStreamTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>
          }
          deleteMany: {
            args: Prisma.IncomeStreamTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeStreamTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncomeStreamTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeStreamTagPayload>
          }
          aggregate: {
            args: Prisma.IncomeStreamTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncomeStreamTag>
          }
          groupBy: {
            args: Prisma.IncomeStreamTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeStreamTagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IncomeStreamTagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IncomeStreamTagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IncomeStreamTagCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeStreamTagCountAggregateOutputType> | number
          }
        }
      }
      DebtTag: {
        payload: Prisma.$DebtTagPayload<ExtArgs>
        fields: Prisma.DebtTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>
          }
          findFirst: {
            args: Prisma.DebtTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>
          }
          findMany: {
            args: Prisma.DebtTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>[]
          }
          create: {
            args: Prisma.DebtTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>
          }
          createMany: {
            args: Prisma.DebtTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DebtTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>
          }
          update: {
            args: Prisma.DebtTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>
          }
          deleteMany: {
            args: Prisma.DebtTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DebtTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtTagPayload>
          }
          aggregate: {
            args: Prisma.DebtTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtTag>
          }
          groupBy: {
            args: Prisma.DebtTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtTagGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DebtTagFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DebtTagAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DebtTagCountArgs<ExtArgs>
            result: $Utils.Optional<DebtTagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    categories: number
    transactions: number
    tags: number
    bills: number
    subscriptions: number
    incomeStreams: number
    debts: number
    debtPayments: number
    savingsGoals: number
    plans: number
    plaidItems: number
    budgets: number
    tagRules: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    categories?: boolean | UserCountOutputTypeCountCategoriesArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    tags?: boolean | UserCountOutputTypeCountTagsArgs
    bills?: boolean | UserCountOutputTypeCountBillsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    incomeStreams?: boolean | UserCountOutputTypeCountIncomeStreamsArgs
    debts?: boolean | UserCountOutputTypeCountDebtsArgs
    debtPayments?: boolean | UserCountOutputTypeCountDebtPaymentsArgs
    savingsGoals?: boolean | UserCountOutputTypeCountSavingsGoalsArgs
    plans?: boolean | UserCountOutputTypeCountPlansArgs
    plaidItems?: boolean | UserCountOutputTypeCountPlaidItemsArgs
    budgets?: boolean | UserCountOutputTypeCountBudgetsArgs
    tagRules?: boolean | UserCountOutputTypeCountTagRulesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIncomeStreamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeStreamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtPaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavingsGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavingsGoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaidItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaidItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagRuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    transactions: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AccountCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    transactions: number
    budgets: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CategoryCountOutputTypeCountTransactionsArgs
    budgets?: boolean | CategoryCountOutputTypeCountBudgetsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    transactionTags: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionTags?: boolean | TransactionCountOutputTypeCountTransactionTagsArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountTransactionTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionTagWhereInput
  }


  /**
   * Count Type TagRuleCountOutputType
   */

  export type TagRuleCountOutputType = {
    tags: number
  }

  export type TagRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | TagRuleCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TagRuleCountOutputType without action
   */
  export type TagRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleCountOutputType
     */
    select?: TagRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagRuleCountOutputType without action
   */
  export type TagRuleCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagRuleTagWhereInput
  }


  /**
   * Count Type IncomeStreamCountOutputType
   */

  export type IncomeStreamCountOutputType = {
    incomeStreamTags: number
  }

  export type IncomeStreamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incomeStreamTags?: boolean | IncomeStreamCountOutputTypeCountIncomeStreamTagsArgs
  }

  // Custom InputTypes
  /**
   * IncomeStreamCountOutputType without action
   */
  export type IncomeStreamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamCountOutputType
     */
    select?: IncomeStreamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncomeStreamCountOutputType without action
   */
  export type IncomeStreamCountOutputTypeCountIncomeStreamTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeStreamTagWhereInput
  }


  /**
   * Count Type DebtCountOutputType
   */

  export type DebtCountOutputType = {
    payments: number
    debtTags: number
  }

  export type DebtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | DebtCountOutputTypeCountPaymentsArgs
    debtTags?: boolean | DebtCountOutputTypeCountDebtTagsArgs
  }

  // Custom InputTypes
  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtCountOutputType
     */
    select?: DebtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtPaymentWhereInput
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountDebtTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtTagWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    items: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PlanCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanItemWhereInput
  }


  /**
   * Count Type PlaidItemCountOutputType
   */

  export type PlaidItemCountOutputType = {
    accounts: number
  }

  export type PlaidItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | PlaidItemCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * PlaidItemCountOutputType without action
   */
  export type PlaidItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItemCountOutputType
     */
    select?: PlaidItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaidItemCountOutputType without action
   */
  export type PlaidItemCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    transactionTags: number
    incomeStreamTags: number
    debtTags: number
    budgets: number
    tagRuleTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionTags?: boolean | TagCountOutputTypeCountTransactionTagsArgs
    incomeStreamTags?: boolean | TagCountOutputTypeCountIncomeStreamTagsArgs
    debtTags?: boolean | TagCountOutputTypeCountDebtTagsArgs
    budgets?: boolean | TagCountOutputTypeCountBudgetsArgs
    tagRuleTags?: boolean | TagCountOutputTypeCountTagRuleTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTransactionTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountIncomeStreamTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeStreamTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountDebtTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTagRuleTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagRuleTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    bills?: boolean | User$billsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    incomeStreams?: boolean | User$incomeStreamsArgs<ExtArgs>
    debts?: boolean | User$debtsArgs<ExtArgs>
    debtPayments?: boolean | User$debtPaymentsArgs<ExtArgs>
    savingsGoals?: boolean | User$savingsGoalsArgs<ExtArgs>
    mandatorySavings?: boolean | User$mandatorySavingsArgs<ExtArgs>
    plans?: boolean | User$plansArgs<ExtArgs>
    plaidItems?: boolean | User$plaidItemsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    tagRules?: boolean | User$tagRulesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    bills?: boolean | User$billsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    incomeStreams?: boolean | User$incomeStreamsArgs<ExtArgs>
    debts?: boolean | User$debtsArgs<ExtArgs>
    debtPayments?: boolean | User$debtPaymentsArgs<ExtArgs>
    savingsGoals?: boolean | User$savingsGoalsArgs<ExtArgs>
    mandatorySavings?: boolean | User$mandatorySavingsArgs<ExtArgs>
    plans?: boolean | User$plansArgs<ExtArgs>
    plaidItems?: boolean | User$plaidItemsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    tagRules?: boolean | User$tagRulesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      bills: Prisma.$BillPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      incomeStreams: Prisma.$IncomeStreamPayload<ExtArgs>[]
      debts: Prisma.$DebtPayload<ExtArgs>[]
      debtPayments: Prisma.$DebtPaymentPayload<ExtArgs>[]
      savingsGoals: Prisma.$SavingsGoalPayload<ExtArgs>[]
      mandatorySavings: Prisma.$MandatorySavingsPayload<ExtArgs> | null
      plans: Prisma.$PlanPayload<ExtArgs>[]
      plaidItems: Prisma.$PlaidItemPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      tagRules: Prisma.$TagRulePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends User$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends User$tagsArgs<ExtArgs> = {}>(args?: Subset<T, User$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    bills<T extends User$billsArgs<ExtArgs> = {}>(args?: Subset<T, User$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    incomeStreams<T extends User$incomeStreamsArgs<ExtArgs> = {}>(args?: Subset<T, User$incomeStreamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findMany"> | Null>
    debts<T extends User$debtsArgs<ExtArgs> = {}>(args?: Subset<T, User$debtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany"> | Null>
    debtPayments<T extends User$debtPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$debtPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    savingsGoals<T extends User$savingsGoalsArgs<ExtArgs> = {}>(args?: Subset<T, User$savingsGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "findMany"> | Null>
    mandatorySavings<T extends User$mandatorySavingsArgs<ExtArgs> = {}>(args?: Subset<T, User$mandatorySavingsArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    plans<T extends User$plansArgs<ExtArgs> = {}>(args?: Subset<T, User$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany"> | Null>
    plaidItems<T extends User$plaidItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$plaidItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends User$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, User$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    tagRules<T extends User$tagRulesArgs<ExtArgs> = {}>(args?: Subset<T, User$tagRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.categories
   */
  export type User$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.tags
   */
  export type User$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * User.bills
   */
  export type User$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.incomeStreams
   */
  export type User$incomeStreamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    where?: IncomeStreamWhereInput
    orderBy?: IncomeStreamOrderByWithRelationInput | IncomeStreamOrderByWithRelationInput[]
    cursor?: IncomeStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncomeStreamScalarFieldEnum | IncomeStreamScalarFieldEnum[]
  }

  /**
   * User.debts
   */
  export type User$debtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    cursor?: DebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * User.debtPayments
   */
  export type User$debtPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    where?: DebtPaymentWhereInput
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    cursor?: DebtPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * User.savingsGoals
   */
  export type User$savingsGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    where?: SavingsGoalWhereInput
    orderBy?: SavingsGoalOrderByWithRelationInput | SavingsGoalOrderByWithRelationInput[]
    cursor?: SavingsGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavingsGoalScalarFieldEnum | SavingsGoalScalarFieldEnum[]
  }

  /**
   * User.mandatorySavings
   */
  export type User$mandatorySavingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    where?: MandatorySavingsWhereInput
  }

  /**
   * User.plans
   */
  export type User$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * User.plaidItems
   */
  export type User$plaidItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    where?: PlaidItemWhereInput
    orderBy?: PlaidItemOrderByWithRelationInput | PlaidItemOrderByWithRelationInput[]
    cursor?: PlaidItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaidItemScalarFieldEnum | PlaidItemScalarFieldEnum[]
  }

  /**
   * User.budgets
   */
  export type User$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * User.tagRules
   */
  export type User$tagRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    where?: TagRuleWhereInput
    orderBy?: TagRuleOrderByWithRelationInput | TagRuleOrderByWithRelationInput[]
    cursor?: TagRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagRuleScalarFieldEnum | TagRuleScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: $Enums.AccountType | null
    currency: string | null
    plaidItemId: string | null
    plaidAccountId: string | null
    plaidMask: string | null
    plaidType: string | null
    plaidSubtype: string | null
    createdAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: $Enums.AccountType | null
    currency: string | null
    plaidItemId: string | null
    plaidAccountId: string | null
    plaidMask: string | null
    plaidType: string | null
    plaidSubtype: string | null
    createdAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    type: number
    currency: number
    plaidItemId: number
    plaidAccountId: number
    plaidMask: number
    plaidType: number
    plaidSubtype: number
    createdAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    currency?: true
    plaidItemId?: true
    plaidAccountId?: true
    plaidMask?: true
    plaidType?: true
    plaidSubtype?: true
    createdAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    currency?: true
    plaidItemId?: true
    plaidAccountId?: true
    plaidMask?: true
    plaidType?: true
    plaidSubtype?: true
    createdAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    currency?: true
    plaidItemId?: true
    plaidAccountId?: true
    plaidMask?: true
    plaidType?: true
    plaidSubtype?: true
    createdAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidItemId: string | null
    plaidAccountId: string | null
    plaidMask: string | null
    plaidType: string | null
    plaidSubtype: string | null
    createdAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    currency?: boolean
    plaidItemId?: boolean
    plaidAccountId?: boolean
    plaidMask?: boolean
    plaidType?: boolean
    plaidSubtype?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plaidItem?: boolean | Account$plaidItemArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>


  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    currency?: boolean
    plaidItemId?: boolean
    plaidAccountId?: boolean
    plaidMask?: boolean
    plaidType?: boolean
    plaidSubtype?: boolean
    createdAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plaidItem?: boolean | Account$plaidItemArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plaidItem: Prisma.$PlaidItemPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      type: $Enums.AccountType
      currency: string
      plaidItemId: string | null
      plaidAccountId: string | null
      plaidMask: string | null
      plaidType: string | null
      plaidSubtype: string | null
      createdAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plaidItem<T extends Account$plaidItemArgs<ExtArgs> = {}>(args?: Subset<T, Account$plaidItemArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends Account$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly currency: FieldRef<"Account", 'String'>
    readonly plaidItemId: FieldRef<"Account", 'String'>
    readonly plaidAccountId: FieldRef<"Account", 'String'>
    readonly plaidMask: FieldRef<"Account", 'String'>
    readonly plaidType: FieldRef<"Account", 'String'>
    readonly plaidSubtype: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account.plaidItem
   */
  export type Account$plaidItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    where?: PlaidItemWhereInput
  }

  /**
   * Account.transactions
   */
  export type Account$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    kind: $Enums.CategoryKind | null
    createdAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    kind: $Enums.CategoryKind | null
    createdAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    kind: number
    createdAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    kind?: true
    createdAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    kind?: true
    createdAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    kind?: true
    createdAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    userId: string
    name: string
    kind: $Enums.CategoryKind
    createdAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    kind?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | Category$transactionsArgs<ExtArgs>
    budgets?: boolean | Category$budgetsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>


  export type CategorySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    kind?: boolean
    createdAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | Category$transactionsArgs<ExtArgs>
    budgets?: boolean | Category$budgetsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      kind: $Enums.CategoryKind
      createdAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Category$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends Category$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Category$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly userId: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly kind: FieldRef<"Category", 'CategoryKind'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category.transactions
   */
  export type Category$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Category.budgets
   */
  export type Category$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amountDollars: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amountDollars: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    date: Date | null
    amountDollars: number | null
    categoryId: string | null
    merchant: string | null
    note: string | null
    plaidTransactionId: string | null
    pending: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    date: Date | null
    amountDollars: number | null
    categoryId: string | null
    merchant: string | null
    note: string | null
    plaidTransactionId: string | null
    pending: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    date: number
    amountDollars: number
    categoryId: number
    merchant: number
    note: number
    plaidTransactionId: number
    pending: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amountDollars?: true
  }

  export type TransactionSumAggregateInputType = {
    amountDollars?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    date?: true
    amountDollars?: true
    categoryId?: true
    merchant?: true
    note?: true
    plaidTransactionId?: true
    pending?: true
    deletedAt?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    date?: true
    amountDollars?: true
    categoryId?: true
    merchant?: true
    note?: true
    plaidTransactionId?: true
    pending?: true
    deletedAt?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    date?: true
    amountDollars?: true
    categoryId?: true
    merchant?: true
    note?: true
    plaidTransactionId?: true
    pending?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    accountId: string | null
    date: Date
    amountDollars: number
    categoryId: string | null
    merchant: string | null
    note: string | null
    plaidTransactionId: string | null
    pending: boolean
    deletedAt: Date | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    date?: boolean
    amountDollars?: boolean
    categoryId?: boolean
    merchant?: boolean
    note?: boolean
    plaidTransactionId?: boolean
    pending?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    transactionTags?: boolean | Transaction$transactionTagsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>


  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    date?: boolean
    amountDollars?: boolean
    categoryId?: boolean
    merchant?: boolean
    note?: boolean
    plaidTransactionId?: boolean
    pending?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    transactionTags?: boolean | Transaction$transactionTagsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      transactionTags: Prisma.$TransactionTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string | null
      date: Date
      amountDollars: number
      categoryId: string | null
      merchant: string | null
      note: string | null
      plaidTransactionId: string | null
      pending: boolean
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * @param {TransactionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const transaction = await prisma.transaction.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TransactionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Transaction.
     * @param {TransactionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const transaction = await prisma.transaction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TransactionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends Transaction$accountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    category<T extends Transaction$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactionTags<T extends Transaction$transactionTagsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$transactionTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly accountId: FieldRef<"Transaction", 'String'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly amountDollars: FieldRef<"Transaction", 'Float'>
    readonly categoryId: FieldRef<"Transaction", 'String'>
    readonly merchant: FieldRef<"Transaction", 'String'>
    readonly note: FieldRef<"Transaction", 'String'>
    readonly plaidTransactionId: FieldRef<"Transaction", 'String'>
    readonly pending: FieldRef<"Transaction", 'Boolean'>
    readonly deletedAt: FieldRef<"Transaction", 'DateTime'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction findRaw
   */
  export type TransactionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Transaction aggregateRaw
   */
  export type TransactionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Transaction.account
   */
  export type Transaction$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction.category
   */
  export type Transaction$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Transaction.transactionTags
   */
  export type Transaction$transactionTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    where?: TransactionTagWhereInput
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    cursor?: TransactionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TagRule
   */

  export type AggregateTagRule = {
    _count: TagRuleCountAggregateOutputType | null
    _min: TagRuleMinAggregateOutputType | null
    _max: TagRuleMaxAggregateOutputType | null
  }

  export type TagRuleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    pattern: string | null
    matchType: $Enums.TagRuleMatchType | null
    sourceField: $Enums.TagRuleSourceField | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagRuleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    pattern: string | null
    matchType: $Enums.TagRuleMatchType | null
    sourceField: $Enums.TagRuleSourceField | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagRuleCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    pattern: number
    matchType: number
    sourceField: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagRuleMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    pattern?: true
    matchType?: true
    sourceField?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagRuleMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    pattern?: true
    matchType?: true
    sourceField?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagRuleCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    pattern?: true
    matchType?: true
    sourceField?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagRule to aggregate.
     */
    where?: TagRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRules to fetch.
     */
    orderBy?: TagRuleOrderByWithRelationInput | TagRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagRules
    **/
    _count?: true | TagRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagRuleMaxAggregateInputType
  }

  export type GetTagRuleAggregateType<T extends TagRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateTagRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagRule[P]>
      : GetScalarType<T[P], AggregateTagRule[P]>
  }




  export type TagRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagRuleWhereInput
    orderBy?: TagRuleOrderByWithAggregationInput | TagRuleOrderByWithAggregationInput[]
    by: TagRuleScalarFieldEnum[] | TagRuleScalarFieldEnum
    having?: TagRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagRuleCountAggregateInputType | true
    _min?: TagRuleMinAggregateInputType
    _max?: TagRuleMaxAggregateInputType
  }

  export type TagRuleGroupByOutputType = {
    id: string
    userId: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt: Date
    updatedAt: Date
    _count: TagRuleCountAggregateOutputType | null
    _min: TagRuleMinAggregateOutputType | null
    _max: TagRuleMaxAggregateOutputType | null
  }

  type GetTagRuleGroupByPayload<T extends TagRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagRuleGroupByOutputType[P]>
            : GetScalarType<T[P], TagRuleGroupByOutputType[P]>
        }
      >
    >


  export type TagRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    pattern?: boolean
    matchType?: boolean
    sourceField?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | TagRule$tagsArgs<ExtArgs>
    _count?: boolean | TagRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagRule"]>


  export type TagRuleSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    pattern?: boolean
    matchType?: boolean
    sourceField?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | TagRule$tagsArgs<ExtArgs>
    _count?: boolean | TagRuleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TagRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagRule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tags: Prisma.$TagRuleTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      pattern: string
      matchType: $Enums.TagRuleMatchType
      sourceField: $Enums.TagRuleSourceField
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tagRule"]>
    composites: {}
  }

  type TagRuleGetPayload<S extends boolean | null | undefined | TagRuleDefaultArgs> = $Result.GetResult<Prisma.$TagRulePayload, S>

  type TagRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagRuleCountAggregateInputType | true
    }

  export interface TagRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagRule'], meta: { name: 'TagRule' } }
    /**
     * Find zero or one TagRule that matches the filter.
     * @param {TagRuleFindUniqueArgs} args - Arguments to find a TagRule
     * @example
     * // Get one TagRule
     * const tagRule = await prisma.tagRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagRuleFindUniqueArgs>(args: SelectSubset<T, TagRuleFindUniqueArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TagRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagRuleFindUniqueOrThrowArgs} args - Arguments to find a TagRule
     * @example
     * // Get one TagRule
     * const tagRule = await prisma.tagRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, TagRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TagRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleFindFirstArgs} args - Arguments to find a TagRule
     * @example
     * // Get one TagRule
     * const tagRule = await prisma.tagRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagRuleFindFirstArgs>(args?: SelectSubset<T, TagRuleFindFirstArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TagRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleFindFirstOrThrowArgs} args - Arguments to find a TagRule
     * @example
     * // Get one TagRule
     * const tagRule = await prisma.tagRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, TagRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TagRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagRules
     * const tagRules = await prisma.tagRule.findMany()
     * 
     * // Get first 10 TagRules
     * const tagRules = await prisma.tagRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagRuleWithIdOnly = await prisma.tagRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagRuleFindManyArgs>(args?: SelectSubset<T, TagRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TagRule.
     * @param {TagRuleCreateArgs} args - Arguments to create a TagRule.
     * @example
     * // Create one TagRule
     * const TagRule = await prisma.tagRule.create({
     *   data: {
     *     // ... data to create a TagRule
     *   }
     * })
     * 
     */
    create<T extends TagRuleCreateArgs>(args: SelectSubset<T, TagRuleCreateArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TagRules.
     * @param {TagRuleCreateManyArgs} args - Arguments to create many TagRules.
     * @example
     * // Create many TagRules
     * const tagRule = await prisma.tagRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagRuleCreateManyArgs>(args?: SelectSubset<T, TagRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TagRule.
     * @param {TagRuleDeleteArgs} args - Arguments to delete one TagRule.
     * @example
     * // Delete one TagRule
     * const TagRule = await prisma.tagRule.delete({
     *   where: {
     *     // ... filter to delete one TagRule
     *   }
     * })
     * 
     */
    delete<T extends TagRuleDeleteArgs>(args: SelectSubset<T, TagRuleDeleteArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TagRule.
     * @param {TagRuleUpdateArgs} args - Arguments to update one TagRule.
     * @example
     * // Update one TagRule
     * const tagRule = await prisma.tagRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagRuleUpdateArgs>(args: SelectSubset<T, TagRuleUpdateArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TagRules.
     * @param {TagRuleDeleteManyArgs} args - Arguments to filter TagRules to delete.
     * @example
     * // Delete a few TagRules
     * const { count } = await prisma.tagRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagRuleDeleteManyArgs>(args?: SelectSubset<T, TagRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagRules
     * const tagRule = await prisma.tagRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagRuleUpdateManyArgs>(args: SelectSubset<T, TagRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TagRule.
     * @param {TagRuleUpsertArgs} args - Arguments to update or create a TagRule.
     * @example
     * // Update or create a TagRule
     * const tagRule = await prisma.tagRule.upsert({
     *   create: {
     *     // ... data to create a TagRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagRule we want to update
     *   }
     * })
     */
    upsert<T extends TagRuleUpsertArgs>(args: SelectSubset<T, TagRuleUpsertArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TagRules that matches the filter.
     * @param {TagRuleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tagRule = await prisma.tagRule.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TagRuleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TagRule.
     * @param {TagRuleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tagRule = await prisma.tagRule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TagRuleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TagRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleCountArgs} args - Arguments to filter TagRules to count.
     * @example
     * // Count the number of TagRules
     * const count = await prisma.tagRule.count({
     *   where: {
     *     // ... the filter for the TagRules we want to count
     *   }
     * })
    **/
    count<T extends TagRuleCountArgs>(
      args?: Subset<T, TagRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagRuleAggregateArgs>(args: Subset<T, TagRuleAggregateArgs>): Prisma.PrismaPromise<GetTagRuleAggregateType<T>>

    /**
     * Group by TagRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagRuleGroupByArgs['orderBy'] }
        : { orderBy?: TagRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagRule model
   */
  readonly fields: TagRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tags<T extends TagRule$tagsArgs<ExtArgs> = {}>(args?: Subset<T, TagRule$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagRule model
   */ 
  interface TagRuleFieldRefs {
    readonly id: FieldRef<"TagRule", 'String'>
    readonly userId: FieldRef<"TagRule", 'String'>
    readonly name: FieldRef<"TagRule", 'String'>
    readonly pattern: FieldRef<"TagRule", 'String'>
    readonly matchType: FieldRef<"TagRule", 'TagRuleMatchType'>
    readonly sourceField: FieldRef<"TagRule", 'TagRuleSourceField'>
    readonly createdAt: FieldRef<"TagRule", 'DateTime'>
    readonly updatedAt: FieldRef<"TagRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TagRule findUnique
   */
  export type TagRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * Filter, which TagRule to fetch.
     */
    where: TagRuleWhereUniqueInput
  }

  /**
   * TagRule findUniqueOrThrow
   */
  export type TagRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * Filter, which TagRule to fetch.
     */
    where: TagRuleWhereUniqueInput
  }

  /**
   * TagRule findFirst
   */
  export type TagRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * Filter, which TagRule to fetch.
     */
    where?: TagRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRules to fetch.
     */
    orderBy?: TagRuleOrderByWithRelationInput | TagRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagRules.
     */
    cursor?: TagRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagRules.
     */
    distinct?: TagRuleScalarFieldEnum | TagRuleScalarFieldEnum[]
  }

  /**
   * TagRule findFirstOrThrow
   */
  export type TagRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * Filter, which TagRule to fetch.
     */
    where?: TagRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRules to fetch.
     */
    orderBy?: TagRuleOrderByWithRelationInput | TagRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagRules.
     */
    cursor?: TagRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagRules.
     */
    distinct?: TagRuleScalarFieldEnum | TagRuleScalarFieldEnum[]
  }

  /**
   * TagRule findMany
   */
  export type TagRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * Filter, which TagRules to fetch.
     */
    where?: TagRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRules to fetch.
     */
    orderBy?: TagRuleOrderByWithRelationInput | TagRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagRules.
     */
    cursor?: TagRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRules.
     */
    skip?: number
    distinct?: TagRuleScalarFieldEnum | TagRuleScalarFieldEnum[]
  }

  /**
   * TagRule create
   */
  export type TagRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a TagRule.
     */
    data: XOR<TagRuleCreateInput, TagRuleUncheckedCreateInput>
  }

  /**
   * TagRule createMany
   */
  export type TagRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagRules.
     */
    data: TagRuleCreateManyInput | TagRuleCreateManyInput[]
  }

  /**
   * TagRule update
   */
  export type TagRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a TagRule.
     */
    data: XOR<TagRuleUpdateInput, TagRuleUncheckedUpdateInput>
    /**
     * Choose, which TagRule to update.
     */
    where: TagRuleWhereUniqueInput
  }

  /**
   * TagRule updateMany
   */
  export type TagRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagRules.
     */
    data: XOR<TagRuleUpdateManyMutationInput, TagRuleUncheckedUpdateManyInput>
    /**
     * Filter which TagRules to update
     */
    where?: TagRuleWhereInput
  }

  /**
   * TagRule upsert
   */
  export type TagRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the TagRule to update in case it exists.
     */
    where: TagRuleWhereUniqueInput
    /**
     * In case the TagRule found by the `where` argument doesn't exist, create a new TagRule with this data.
     */
    create: XOR<TagRuleCreateInput, TagRuleUncheckedCreateInput>
    /**
     * In case the TagRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagRuleUpdateInput, TagRuleUncheckedUpdateInput>
  }

  /**
   * TagRule delete
   */
  export type TagRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
    /**
     * Filter which TagRule to delete.
     */
    where: TagRuleWhereUniqueInput
  }

  /**
   * TagRule deleteMany
   */
  export type TagRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagRules to delete
     */
    where?: TagRuleWhereInput
  }

  /**
   * TagRule findRaw
   */
  export type TagRuleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TagRule aggregateRaw
   */
  export type TagRuleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TagRule.tags
   */
  export type TagRule$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    where?: TagRuleTagWhereInput
    orderBy?: TagRuleTagOrderByWithRelationInput | TagRuleTagOrderByWithRelationInput[]
    cursor?: TagRuleTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagRuleTagScalarFieldEnum | TagRuleTagScalarFieldEnum[]
  }

  /**
   * TagRule without action
   */
  export type TagRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRule
     */
    select?: TagRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    amountDollars: number | null
  }

  export type BudgetSumAggregateOutputType = {
    amountDollars: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    period: $Enums.BudgetPeriod | null
    categoryId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    period: $Enums.BudgetPeriod | null
    categoryId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    amountDollars: number
    period: number
    categoryId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    amountDollars?: true
  }

  export type BudgetSumAggregateInputType = {
    amountDollars?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    period?: true
    categoryId?: true
    tagId?: true
    createdAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    period?: true
    categoryId?: true
    tagId?: true
    createdAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    period?: true
    categoryId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId: string | null
    tagId: string | null
    createdAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    period?: boolean
    categoryId?: boolean
    tagId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Budget$categoryArgs<ExtArgs>
    tag?: boolean | Budget$tagArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>


  export type BudgetSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    period?: boolean
    categoryId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Budget$categoryArgs<ExtArgs>
    tag?: boolean | Budget$tagArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      tag: Prisma.$TagPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      amountDollars: number
      period: $Enums.BudgetPeriod
      categoryId: string | null
      tagId: string | null
      createdAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * @param {BudgetFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const budget = await prisma.budget.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BudgetFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Budget.
     * @param {BudgetAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const budget = await prisma.budget.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BudgetAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends Budget$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Budget$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tag<T extends Budget$tagArgs<ExtArgs> = {}>(args?: Subset<T, Budget$tagArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly userId: FieldRef<"Budget", 'String'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly amountDollars: FieldRef<"Budget", 'Float'>
    readonly period: FieldRef<"Budget", 'BudgetPeriod'>
    readonly categoryId: FieldRef<"Budget", 'String'>
    readonly tagId: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget findRaw
   */
  export type BudgetFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Budget aggregateRaw
   */
  export type BudgetAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Budget.category
   */
  export type Budget$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Budget.tag
   */
  export type Budget$tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    amountDollars: number | null
    dueDayOfMonth: number | null
  }

  export type BillSumAggregateOutputType = {
    amountDollars: number | null
    dueDayOfMonth: number | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    dueDayOfMonth: number | null
    dueDate: Date | null
    frequency: $Enums.BillFrequency | null
    isEssential: boolean | null
    autopay: boolean | null
    createdAt: Date | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    dueDayOfMonth: number | null
    dueDate: Date | null
    frequency: $Enums.BillFrequency | null
    isEssential: boolean | null
    autopay: boolean | null
    createdAt: Date | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    amountDollars: number
    dueDayOfMonth: number
    dueDate: number
    frequency: number
    isEssential: number
    autopay: number
    createdAt: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    amountDollars?: true
    dueDayOfMonth?: true
  }

  export type BillSumAggregateInputType = {
    amountDollars?: true
    dueDayOfMonth?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    dueDayOfMonth?: true
    dueDate?: true
    frequency?: true
    isEssential?: true
    autopay?: true
    createdAt?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    dueDayOfMonth?: true
    dueDate?: true
    frequency?: true
    isEssential?: true
    autopay?: true
    createdAt?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    dueDayOfMonth?: true
    dueDate?: true
    frequency?: true
    isEssential?: true
    autopay?: true
    createdAt?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: string
    userId: string
    name: string
    amountDollars: number
    dueDayOfMonth: number | null
    dueDate: Date | null
    frequency: $Enums.BillFrequency
    isEssential: boolean
    autopay: boolean
    createdAt: Date
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    dueDayOfMonth?: boolean
    dueDate?: boolean
    frequency?: boolean
    isEssential?: boolean
    autopay?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>


  export type BillSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    dueDayOfMonth?: boolean
    dueDate?: boolean
    frequency?: boolean
    isEssential?: boolean
    autopay?: boolean
    createdAt?: boolean
  }

  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      amountDollars: number
      dueDayOfMonth: number | null
      dueDate: Date | null
      frequency: $Enums.BillFrequency
      isEssential: boolean
      autopay: boolean
      createdAt: Date
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Bills that matches the filter.
     * @param {BillFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bill = await prisma.bill.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BillFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Bill.
     * @param {BillAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bill = await prisma.bill.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BillAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */ 
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'String'>
    readonly userId: FieldRef<"Bill", 'String'>
    readonly name: FieldRef<"Bill", 'String'>
    readonly amountDollars: FieldRef<"Bill", 'Float'>
    readonly dueDayOfMonth: FieldRef<"Bill", 'Int'>
    readonly dueDate: FieldRef<"Bill", 'DateTime'>
    readonly frequency: FieldRef<"Bill", 'BillFrequency'>
    readonly isEssential: FieldRef<"Bill", 'Boolean'>
    readonly autopay: FieldRef<"Bill", 'Boolean'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
  }

  /**
   * Bill findRaw
   */
  export type BillFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Bill aggregateRaw
   */
  export type BillAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    amountDollars: number | null
    billingDayOfMonth: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    amountDollars: number | null
    billingDayOfMonth: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    billingDayOfMonth: number | null
    frequency: $Enums.SubscriptionFrequency | null
    cancelable: boolean | null
    createdAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    billingDayOfMonth: number | null
    frequency: $Enums.SubscriptionFrequency | null
    cancelable: boolean | null
    createdAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    amountDollars: number
    billingDayOfMonth: number
    frequency: number
    cancelable: number
    createdAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    amountDollars?: true
    billingDayOfMonth?: true
  }

  export type SubscriptionSumAggregateInputType = {
    amountDollars?: true
    billingDayOfMonth?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    billingDayOfMonth?: true
    frequency?: true
    cancelable?: true
    createdAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    billingDayOfMonth?: true
    frequency?: true
    cancelable?: true
    createdAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    billingDayOfMonth?: true
    frequency?: true
    cancelable?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    billingDayOfMonth?: boolean
    frequency?: boolean
    cancelable?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>


  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    billingDayOfMonth?: boolean
    frequency?: boolean
    cancelable?: boolean
    createdAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      amountDollars: number
      billingDayOfMonth: number
      frequency: $Enums.SubscriptionFrequency
      cancelable: boolean
      createdAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * @param {SubscriptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subscription = await prisma.subscription.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SubscriptionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subscription.
     * @param {SubscriptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subscription = await prisma.subscription.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SubscriptionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly name: FieldRef<"Subscription", 'String'>
    readonly amountDollars: FieldRef<"Subscription", 'Float'>
    readonly billingDayOfMonth: FieldRef<"Subscription", 'Int'>
    readonly frequency: FieldRef<"Subscription", 'SubscriptionFrequency'>
    readonly cancelable: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription findRaw
   */
  export type SubscriptionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subscription aggregateRaw
   */
  export type SubscriptionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model IncomeStream
   */

  export type AggregateIncomeStream = {
    _count: IncomeStreamCountAggregateOutputType | null
    _avg: IncomeStreamAvgAggregateOutputType | null
    _sum: IncomeStreamSumAggregateOutputType | null
    _min: IncomeStreamMinAggregateOutputType | null
    _max: IncomeStreamMaxAggregateOutputType | null
  }

  export type IncomeStreamAvgAggregateOutputType = {
    amountDollars: number | null
    lastAmountDollars: number | null
  }

  export type IncomeStreamSumAggregateOutputType = {
    amountDollars: number | null
    lastAmountDollars: number | null
  }

  export type IncomeStreamMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    lastAmountDollars: number | null
    cadence: $Enums.IncomeCadence | null
    nextPayDate: Date | null
    createdAt: Date | null
  }

  export type IncomeStreamMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    amountDollars: number | null
    lastAmountDollars: number | null
    cadence: $Enums.IncomeCadence | null
    nextPayDate: Date | null
    createdAt: Date | null
  }

  export type IncomeStreamCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    amountDollars: number
    lastAmountDollars: number
    cadence: number
    nextPayDate: number
    createdAt: number
    _all: number
  }


  export type IncomeStreamAvgAggregateInputType = {
    amountDollars?: true
    lastAmountDollars?: true
  }

  export type IncomeStreamSumAggregateInputType = {
    amountDollars?: true
    lastAmountDollars?: true
  }

  export type IncomeStreamMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    lastAmountDollars?: true
    cadence?: true
    nextPayDate?: true
    createdAt?: true
  }

  export type IncomeStreamMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    lastAmountDollars?: true
    cadence?: true
    nextPayDate?: true
    createdAt?: true
  }

  export type IncomeStreamCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    amountDollars?: true
    lastAmountDollars?: true
    cadence?: true
    nextPayDate?: true
    createdAt?: true
    _all?: true
  }

  export type IncomeStreamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeStream to aggregate.
     */
    where?: IncomeStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreams to fetch.
     */
    orderBy?: IncomeStreamOrderByWithRelationInput | IncomeStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomeStreams
    **/
    _count?: true | IncomeStreamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomeStreamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomeStreamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeStreamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeStreamMaxAggregateInputType
  }

  export type GetIncomeStreamAggregateType<T extends IncomeStreamAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomeStream]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomeStream[P]>
      : GetScalarType<T[P], AggregateIncomeStream[P]>
  }




  export type IncomeStreamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeStreamWhereInput
    orderBy?: IncomeStreamOrderByWithAggregationInput | IncomeStreamOrderByWithAggregationInput[]
    by: IncomeStreamScalarFieldEnum[] | IncomeStreamScalarFieldEnum
    having?: IncomeStreamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeStreamCountAggregateInputType | true
    _avg?: IncomeStreamAvgAggregateInputType
    _sum?: IncomeStreamSumAggregateInputType
    _min?: IncomeStreamMinAggregateInputType
    _max?: IncomeStreamMaxAggregateInputType
  }

  export type IncomeStreamGroupByOutputType = {
    id: string
    userId: string
    name: string
    amountDollars: number
    lastAmountDollars: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date
    createdAt: Date
    _count: IncomeStreamCountAggregateOutputType | null
    _avg: IncomeStreamAvgAggregateOutputType | null
    _sum: IncomeStreamSumAggregateOutputType | null
    _min: IncomeStreamMinAggregateOutputType | null
    _max: IncomeStreamMaxAggregateOutputType | null
  }

  type GetIncomeStreamGroupByPayload<T extends IncomeStreamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeStreamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeStreamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeStreamGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeStreamGroupByOutputType[P]>
        }
      >
    >


  export type IncomeStreamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    lastAmountDollars?: boolean
    cadence?: boolean
    nextPayDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    incomeStreamTags?: boolean | IncomeStream$incomeStreamTagsArgs<ExtArgs>
    _count?: boolean | IncomeStreamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeStream"]>


  export type IncomeStreamSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    amountDollars?: boolean
    lastAmountDollars?: boolean
    cadence?: boolean
    nextPayDate?: boolean
    createdAt?: boolean
  }

  export type IncomeStreamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    incomeStreamTags?: boolean | IncomeStream$incomeStreamTagsArgs<ExtArgs>
    _count?: boolean | IncomeStreamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $IncomeStreamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncomeStream"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      incomeStreamTags: Prisma.$IncomeStreamTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      amountDollars: number
      lastAmountDollars: number | null
      cadence: $Enums.IncomeCadence
      nextPayDate: Date
      createdAt: Date
    }, ExtArgs["result"]["incomeStream"]>
    composites: {}
  }

  type IncomeStreamGetPayload<S extends boolean | null | undefined | IncomeStreamDefaultArgs> = $Result.GetResult<Prisma.$IncomeStreamPayload, S>

  type IncomeStreamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncomeStreamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncomeStreamCountAggregateInputType | true
    }

  export interface IncomeStreamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncomeStream'], meta: { name: 'IncomeStream' } }
    /**
     * Find zero or one IncomeStream that matches the filter.
     * @param {IncomeStreamFindUniqueArgs} args - Arguments to find a IncomeStream
     * @example
     * // Get one IncomeStream
     * const incomeStream = await prisma.incomeStream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeStreamFindUniqueArgs>(args: SelectSubset<T, IncomeStreamFindUniqueArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncomeStream that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncomeStreamFindUniqueOrThrowArgs} args - Arguments to find a IncomeStream
     * @example
     * // Get one IncomeStream
     * const incomeStream = await prisma.incomeStream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeStreamFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeStreamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncomeStream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamFindFirstArgs} args - Arguments to find a IncomeStream
     * @example
     * // Get one IncomeStream
     * const incomeStream = await prisma.incomeStream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeStreamFindFirstArgs>(args?: SelectSubset<T, IncomeStreamFindFirstArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncomeStream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamFindFirstOrThrowArgs} args - Arguments to find a IncomeStream
     * @example
     * // Get one IncomeStream
     * const incomeStream = await prisma.incomeStream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeStreamFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeStreamFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncomeStreams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomeStreams
     * const incomeStreams = await prisma.incomeStream.findMany()
     * 
     * // Get first 10 IncomeStreams
     * const incomeStreams = await prisma.incomeStream.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeStreamWithIdOnly = await prisma.incomeStream.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeStreamFindManyArgs>(args?: SelectSubset<T, IncomeStreamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncomeStream.
     * @param {IncomeStreamCreateArgs} args - Arguments to create a IncomeStream.
     * @example
     * // Create one IncomeStream
     * const IncomeStream = await prisma.incomeStream.create({
     *   data: {
     *     // ... data to create a IncomeStream
     *   }
     * })
     * 
     */
    create<T extends IncomeStreamCreateArgs>(args: SelectSubset<T, IncomeStreamCreateArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncomeStreams.
     * @param {IncomeStreamCreateManyArgs} args - Arguments to create many IncomeStreams.
     * @example
     * // Create many IncomeStreams
     * const incomeStream = await prisma.incomeStream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeStreamCreateManyArgs>(args?: SelectSubset<T, IncomeStreamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomeStream.
     * @param {IncomeStreamDeleteArgs} args - Arguments to delete one IncomeStream.
     * @example
     * // Delete one IncomeStream
     * const IncomeStream = await prisma.incomeStream.delete({
     *   where: {
     *     // ... filter to delete one IncomeStream
     *   }
     * })
     * 
     */
    delete<T extends IncomeStreamDeleteArgs>(args: SelectSubset<T, IncomeStreamDeleteArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncomeStream.
     * @param {IncomeStreamUpdateArgs} args - Arguments to update one IncomeStream.
     * @example
     * // Update one IncomeStream
     * const incomeStream = await prisma.incomeStream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeStreamUpdateArgs>(args: SelectSubset<T, IncomeStreamUpdateArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncomeStreams.
     * @param {IncomeStreamDeleteManyArgs} args - Arguments to filter IncomeStreams to delete.
     * @example
     * // Delete a few IncomeStreams
     * const { count } = await prisma.incomeStream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeStreamDeleteManyArgs>(args?: SelectSubset<T, IncomeStreamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomeStreams
     * const incomeStream = await prisma.incomeStream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeStreamUpdateManyArgs>(args: SelectSubset<T, IncomeStreamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomeStream.
     * @param {IncomeStreamUpsertArgs} args - Arguments to update or create a IncomeStream.
     * @example
     * // Update or create a IncomeStream
     * const incomeStream = await prisma.incomeStream.upsert({
     *   create: {
     *     // ... data to create a IncomeStream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomeStream we want to update
     *   }
     * })
     */
    upsert<T extends IncomeStreamUpsertArgs>(args: SelectSubset<T, IncomeStreamUpsertArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more IncomeStreams that matches the filter.
     * @param {IncomeStreamFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const incomeStream = await prisma.incomeStream.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: IncomeStreamFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IncomeStream.
     * @param {IncomeStreamAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const incomeStream = await prisma.incomeStream.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IncomeStreamAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IncomeStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamCountArgs} args - Arguments to filter IncomeStreams to count.
     * @example
     * // Count the number of IncomeStreams
     * const count = await prisma.incomeStream.count({
     *   where: {
     *     // ... the filter for the IncomeStreams we want to count
     *   }
     * })
    **/
    count<T extends IncomeStreamCountArgs>(
      args?: Subset<T, IncomeStreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeStreamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomeStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeStreamAggregateArgs>(args: Subset<T, IncomeStreamAggregateArgs>): Prisma.PrismaPromise<GetIncomeStreamAggregateType<T>>

    /**
     * Group by IncomeStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeStreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeStreamGroupByArgs['orderBy'] }
        : { orderBy?: IncomeStreamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeStreamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeStreamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncomeStream model
   */
  readonly fields: IncomeStreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomeStream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeStreamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    incomeStreamTags<T extends IncomeStream$incomeStreamTagsArgs<ExtArgs> = {}>(args?: Subset<T, IncomeStream$incomeStreamTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncomeStream model
   */ 
  interface IncomeStreamFieldRefs {
    readonly id: FieldRef<"IncomeStream", 'String'>
    readonly userId: FieldRef<"IncomeStream", 'String'>
    readonly name: FieldRef<"IncomeStream", 'String'>
    readonly amountDollars: FieldRef<"IncomeStream", 'Float'>
    readonly lastAmountDollars: FieldRef<"IncomeStream", 'Float'>
    readonly cadence: FieldRef<"IncomeStream", 'IncomeCadence'>
    readonly nextPayDate: FieldRef<"IncomeStream", 'DateTime'>
    readonly createdAt: FieldRef<"IncomeStream", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncomeStream findUnique
   */
  export type IncomeStreamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStream to fetch.
     */
    where: IncomeStreamWhereUniqueInput
  }

  /**
   * IncomeStream findUniqueOrThrow
   */
  export type IncomeStreamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStream to fetch.
     */
    where: IncomeStreamWhereUniqueInput
  }

  /**
   * IncomeStream findFirst
   */
  export type IncomeStreamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStream to fetch.
     */
    where?: IncomeStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreams to fetch.
     */
    orderBy?: IncomeStreamOrderByWithRelationInput | IncomeStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeStreams.
     */
    cursor?: IncomeStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeStreams.
     */
    distinct?: IncomeStreamScalarFieldEnum | IncomeStreamScalarFieldEnum[]
  }

  /**
   * IncomeStream findFirstOrThrow
   */
  export type IncomeStreamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStream to fetch.
     */
    where?: IncomeStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreams to fetch.
     */
    orderBy?: IncomeStreamOrderByWithRelationInput | IncomeStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeStreams.
     */
    cursor?: IncomeStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeStreams.
     */
    distinct?: IncomeStreamScalarFieldEnum | IncomeStreamScalarFieldEnum[]
  }

  /**
   * IncomeStream findMany
   */
  export type IncomeStreamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStreams to fetch.
     */
    where?: IncomeStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreams to fetch.
     */
    orderBy?: IncomeStreamOrderByWithRelationInput | IncomeStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomeStreams.
     */
    cursor?: IncomeStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreams.
     */
    skip?: number
    distinct?: IncomeStreamScalarFieldEnum | IncomeStreamScalarFieldEnum[]
  }

  /**
   * IncomeStream create
   */
  export type IncomeStreamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * The data needed to create a IncomeStream.
     */
    data: XOR<IncomeStreamCreateInput, IncomeStreamUncheckedCreateInput>
  }

  /**
   * IncomeStream createMany
   */
  export type IncomeStreamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncomeStreams.
     */
    data: IncomeStreamCreateManyInput | IncomeStreamCreateManyInput[]
  }

  /**
   * IncomeStream update
   */
  export type IncomeStreamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * The data needed to update a IncomeStream.
     */
    data: XOR<IncomeStreamUpdateInput, IncomeStreamUncheckedUpdateInput>
    /**
     * Choose, which IncomeStream to update.
     */
    where: IncomeStreamWhereUniqueInput
  }

  /**
   * IncomeStream updateMany
   */
  export type IncomeStreamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncomeStreams.
     */
    data: XOR<IncomeStreamUpdateManyMutationInput, IncomeStreamUncheckedUpdateManyInput>
    /**
     * Filter which IncomeStreams to update
     */
    where?: IncomeStreamWhereInput
  }

  /**
   * IncomeStream upsert
   */
  export type IncomeStreamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * The filter to search for the IncomeStream to update in case it exists.
     */
    where: IncomeStreamWhereUniqueInput
    /**
     * In case the IncomeStream found by the `where` argument doesn't exist, create a new IncomeStream with this data.
     */
    create: XOR<IncomeStreamCreateInput, IncomeStreamUncheckedCreateInput>
    /**
     * In case the IncomeStream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeStreamUpdateInput, IncomeStreamUncheckedUpdateInput>
  }

  /**
   * IncomeStream delete
   */
  export type IncomeStreamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
    /**
     * Filter which IncomeStream to delete.
     */
    where: IncomeStreamWhereUniqueInput
  }

  /**
   * IncomeStream deleteMany
   */
  export type IncomeStreamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeStreams to delete
     */
    where?: IncomeStreamWhereInput
  }

  /**
   * IncomeStream findRaw
   */
  export type IncomeStreamFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IncomeStream aggregateRaw
   */
  export type IncomeStreamAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IncomeStream.incomeStreamTags
   */
  export type IncomeStream$incomeStreamTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    where?: IncomeStreamTagWhereInput
    orderBy?: IncomeStreamTagOrderByWithRelationInput | IncomeStreamTagOrderByWithRelationInput[]
    cursor?: IncomeStreamTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncomeStreamTagScalarFieldEnum | IncomeStreamTagScalarFieldEnum[]
  }

  /**
   * IncomeStream without action
   */
  export type IncomeStreamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStream
     */
    select?: IncomeStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamInclude<ExtArgs> | null
  }


  /**
   * Model Debt
   */

  export type AggregateDebt = {
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  export type DebtAvgAggregateOutputType = {
    principalDollars: number | null
    aprBps: number | null
    minPaymentDollars: number | null
    estimatedMonthlyPaymentDollars: number | null
    dueDayOfMonth: number | null
  }

  export type DebtSumAggregateOutputType = {
    principalDollars: number | null
    aprBps: number | null
    minPaymentDollars: number | null
    estimatedMonthlyPaymentDollars: number | null
    dueDayOfMonth: number | null
  }

  export type DebtMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    principalDollars: number | null
    aprBps: number | null
    minPaymentDollars: number | null
    estimatedMonthlyPaymentDollars: number | null
    dueDayOfMonth: number | null
    estimatedPayoffDate: Date | null
    createdAt: Date | null
  }

  export type DebtMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    principalDollars: number | null
    aprBps: number | null
    minPaymentDollars: number | null
    estimatedMonthlyPaymentDollars: number | null
    dueDayOfMonth: number | null
    estimatedPayoffDate: Date | null
    createdAt: Date | null
  }

  export type DebtCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars: number
    dueDayOfMonth: number
    estimatedPayoffDate: number
    createdAt: number
    _all: number
  }


  export type DebtAvgAggregateInputType = {
    principalDollars?: true
    aprBps?: true
    minPaymentDollars?: true
    estimatedMonthlyPaymentDollars?: true
    dueDayOfMonth?: true
  }

  export type DebtSumAggregateInputType = {
    principalDollars?: true
    aprBps?: true
    minPaymentDollars?: true
    estimatedMonthlyPaymentDollars?: true
    dueDayOfMonth?: true
  }

  export type DebtMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    principalDollars?: true
    aprBps?: true
    minPaymentDollars?: true
    estimatedMonthlyPaymentDollars?: true
    dueDayOfMonth?: true
    estimatedPayoffDate?: true
    createdAt?: true
  }

  export type DebtMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    principalDollars?: true
    aprBps?: true
    minPaymentDollars?: true
    estimatedMonthlyPaymentDollars?: true
    dueDayOfMonth?: true
    estimatedPayoffDate?: true
    createdAt?: true
  }

  export type DebtCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    principalDollars?: true
    aprBps?: true
    minPaymentDollars?: true
    estimatedMonthlyPaymentDollars?: true
    dueDayOfMonth?: true
    estimatedPayoffDate?: true
    createdAt?: true
    _all?: true
  }

  export type DebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debt to aggregate.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Debts
    **/
    _count?: true | DebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtMaxAggregateInputType
  }

  export type GetDebtAggregateType<T extends DebtAggregateArgs> = {
        [P in keyof T & keyof AggregateDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebt[P]>
      : GetScalarType<T[P], AggregateDebt[P]>
  }




  export type DebtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithAggregationInput | DebtOrderByWithAggregationInput[]
    by: DebtScalarFieldEnum[] | DebtScalarFieldEnum
    having?: DebtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtCountAggregateInputType | true
    _avg?: DebtAvgAggregateInputType
    _sum?: DebtSumAggregateInputType
    _min?: DebtMinAggregateInputType
    _max?: DebtMaxAggregateInputType
  }

  export type DebtGroupByOutputType = {
    id: string
    userId: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars: number | null
    dueDayOfMonth: number
    estimatedPayoffDate: Date | null
    createdAt: Date
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  type GetDebtGroupByPayload<T extends DebtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtGroupByOutputType[P]>
            : GetScalarType<T[P], DebtGroupByOutputType[P]>
        }
      >
    >


  export type DebtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    principalDollars?: boolean
    aprBps?: boolean
    minPaymentDollars?: boolean
    estimatedMonthlyPaymentDollars?: boolean
    dueDayOfMonth?: boolean
    estimatedPayoffDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Debt$paymentsArgs<ExtArgs>
    debtTags?: boolean | Debt$debtTagsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt"]>


  export type DebtSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    principalDollars?: boolean
    aprBps?: boolean
    minPaymentDollars?: boolean
    estimatedMonthlyPaymentDollars?: boolean
    dueDayOfMonth?: boolean
    estimatedPayoffDate?: boolean
    createdAt?: boolean
  }

  export type DebtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Debt$paymentsArgs<ExtArgs>
    debtTags?: boolean | Debt$debtTagsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DebtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Debt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$DebtPaymentPayload<ExtArgs>[]
      debtTags: Prisma.$DebtTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      principalDollars: number
      aprBps: number
      minPaymentDollars: number
      estimatedMonthlyPaymentDollars: number | null
      dueDayOfMonth: number
      estimatedPayoffDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["debt"]>
    composites: {}
  }

  type DebtGetPayload<S extends boolean | null | undefined | DebtDefaultArgs> = $Result.GetResult<Prisma.$DebtPayload, S>

  type DebtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DebtFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DebtCountAggregateInputType | true
    }

  export interface DebtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Debt'], meta: { name: 'Debt' } }
    /**
     * Find zero or one Debt that matches the filter.
     * @param {DebtFindUniqueArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtFindUniqueArgs>(args: SelectSubset<T, DebtFindUniqueArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Debt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DebtFindUniqueOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Debt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindFirstArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtFindFirstArgs>(args?: SelectSubset<T, DebtFindFirstArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Debt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindFirstOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Debts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debts
     * const debts = await prisma.debt.findMany()
     * 
     * // Get first 10 Debts
     * const debts = await prisma.debt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtWithIdOnly = await prisma.debt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtFindManyArgs>(args?: SelectSubset<T, DebtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Debt.
     * @param {DebtCreateArgs} args - Arguments to create a Debt.
     * @example
     * // Create one Debt
     * const Debt = await prisma.debt.create({
     *   data: {
     *     // ... data to create a Debt
     *   }
     * })
     * 
     */
    create<T extends DebtCreateArgs>(args: SelectSubset<T, DebtCreateArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Debts.
     * @param {DebtCreateManyArgs} args - Arguments to create many Debts.
     * @example
     * // Create many Debts
     * const debt = await prisma.debt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtCreateManyArgs>(args?: SelectSubset<T, DebtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Debt.
     * @param {DebtDeleteArgs} args - Arguments to delete one Debt.
     * @example
     * // Delete one Debt
     * const Debt = await prisma.debt.delete({
     *   where: {
     *     // ... filter to delete one Debt
     *   }
     * })
     * 
     */
    delete<T extends DebtDeleteArgs>(args: SelectSubset<T, DebtDeleteArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Debt.
     * @param {DebtUpdateArgs} args - Arguments to update one Debt.
     * @example
     * // Update one Debt
     * const debt = await prisma.debt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtUpdateArgs>(args: SelectSubset<T, DebtUpdateArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Debts.
     * @param {DebtDeleteManyArgs} args - Arguments to filter Debts to delete.
     * @example
     * // Delete a few Debts
     * const { count } = await prisma.debt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtDeleteManyArgs>(args?: SelectSubset<T, DebtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debts
     * const debt = await prisma.debt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtUpdateManyArgs>(args: SelectSubset<T, DebtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Debt.
     * @param {DebtUpsertArgs} args - Arguments to update or create a Debt.
     * @example
     * // Update or create a Debt
     * const debt = await prisma.debt.upsert({
     *   create: {
     *     // ... data to create a Debt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debt we want to update
     *   }
     * })
     */
    upsert<T extends DebtUpsertArgs>(args: SelectSubset<T, DebtUpsertArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Debts that matches the filter.
     * @param {DebtFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const debt = await prisma.debt.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DebtFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Debt.
     * @param {DebtAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const debt = await prisma.debt.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DebtAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtCountArgs} args - Arguments to filter Debts to count.
     * @example
     * // Count the number of Debts
     * const count = await prisma.debt.count({
     *   where: {
     *     // ... the filter for the Debts we want to count
     *   }
     * })
    **/
    count<T extends DebtCountArgs>(
      args?: Subset<T, DebtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtAggregateArgs>(args: Subset<T, DebtAggregateArgs>): Prisma.PrismaPromise<GetDebtAggregateType<T>>

    /**
     * Group by Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtGroupByArgs['orderBy'] }
        : { orderBy?: DebtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Debt model
   */
  readonly fields: DebtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Debt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Debt$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Debt$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    debtTags<T extends Debt$debtTagsArgs<ExtArgs> = {}>(args?: Subset<T, Debt$debtTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Debt model
   */ 
  interface DebtFieldRefs {
    readonly id: FieldRef<"Debt", 'String'>
    readonly userId: FieldRef<"Debt", 'String'>
    readonly name: FieldRef<"Debt", 'String'>
    readonly principalDollars: FieldRef<"Debt", 'Float'>
    readonly aprBps: FieldRef<"Debt", 'Int'>
    readonly minPaymentDollars: FieldRef<"Debt", 'Float'>
    readonly estimatedMonthlyPaymentDollars: FieldRef<"Debt", 'Float'>
    readonly dueDayOfMonth: FieldRef<"Debt", 'Int'>
    readonly estimatedPayoffDate: FieldRef<"Debt", 'DateTime'>
    readonly createdAt: FieldRef<"Debt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Debt findUnique
   */
  export type DebtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt findUniqueOrThrow
   */
  export type DebtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt findFirst
   */
  export type DebtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt findFirstOrThrow
   */
  export type DebtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt findMany
   */
  export type DebtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debts to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt create
   */
  export type DebtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The data needed to create a Debt.
     */
    data: XOR<DebtCreateInput, DebtUncheckedCreateInput>
  }

  /**
   * Debt createMany
   */
  export type DebtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Debts.
     */
    data: DebtCreateManyInput | DebtCreateManyInput[]
  }

  /**
   * Debt update
   */
  export type DebtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The data needed to update a Debt.
     */
    data: XOR<DebtUpdateInput, DebtUncheckedUpdateInput>
    /**
     * Choose, which Debt to update.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt updateMany
   */
  export type DebtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Debts.
     */
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyInput>
    /**
     * Filter which Debts to update
     */
    where?: DebtWhereInput
  }

  /**
   * Debt upsert
   */
  export type DebtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The filter to search for the Debt to update in case it exists.
     */
    where: DebtWhereUniqueInput
    /**
     * In case the Debt found by the `where` argument doesn't exist, create a new Debt with this data.
     */
    create: XOR<DebtCreateInput, DebtUncheckedCreateInput>
    /**
     * In case the Debt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtUpdateInput, DebtUncheckedUpdateInput>
  }

  /**
   * Debt delete
   */
  export type DebtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter which Debt to delete.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt deleteMany
   */
  export type DebtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debts to delete
     */
    where?: DebtWhereInput
  }

  /**
   * Debt findRaw
   */
  export type DebtFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Debt aggregateRaw
   */
  export type DebtAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Debt.payments
   */
  export type Debt$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    where?: DebtPaymentWhereInput
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    cursor?: DebtPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * Debt.debtTags
   */
  export type Debt$debtTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    where?: DebtTagWhereInput
    orderBy?: DebtTagOrderByWithRelationInput | DebtTagOrderByWithRelationInput[]
    cursor?: DebtTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtTagScalarFieldEnum | DebtTagScalarFieldEnum[]
  }

  /**
   * Debt without action
   */
  export type DebtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
  }


  /**
   * Model SavingsGoal
   */

  export type AggregateSavingsGoal = {
    _count: SavingsGoalCountAggregateOutputType | null
    _avg: SavingsGoalAvgAggregateOutputType | null
    _sum: SavingsGoalSumAggregateOutputType | null
    _min: SavingsGoalMinAggregateOutputType | null
    _max: SavingsGoalMaxAggregateOutputType | null
  }

  export type SavingsGoalAvgAggregateOutputType = {
    targetDollars: number | null
    currentDollars: number | null
    ruleValueBpsOrDollars: number | null
    priority: number | null
  }

  export type SavingsGoalSumAggregateOutputType = {
    targetDollars: number | null
    currentDollars: number | null
    ruleValueBpsOrDollars: number | null
    priority: number | null
  }

  export type SavingsGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    targetDollars: number | null
    currentDollars: number | null
    ruleType: $Enums.SavingsRuleType | null
    ruleValueBpsOrDollars: number | null
    priority: number | null
    createdAt: Date | null
  }

  export type SavingsGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    targetDollars: number | null
    currentDollars: number | null
    ruleType: $Enums.SavingsRuleType | null
    ruleValueBpsOrDollars: number | null
    priority: number | null
    createdAt: Date | null
  }

  export type SavingsGoalCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    targetDollars: number
    currentDollars: number
    ruleType: number
    ruleValueBpsOrDollars: number
    priority: number
    createdAt: number
    _all: number
  }


  export type SavingsGoalAvgAggregateInputType = {
    targetDollars?: true
    currentDollars?: true
    ruleValueBpsOrDollars?: true
    priority?: true
  }

  export type SavingsGoalSumAggregateInputType = {
    targetDollars?: true
    currentDollars?: true
    ruleValueBpsOrDollars?: true
    priority?: true
  }

  export type SavingsGoalMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    targetDollars?: true
    currentDollars?: true
    ruleType?: true
    ruleValueBpsOrDollars?: true
    priority?: true
    createdAt?: true
  }

  export type SavingsGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    targetDollars?: true
    currentDollars?: true
    ruleType?: true
    ruleValueBpsOrDollars?: true
    priority?: true
    createdAt?: true
  }

  export type SavingsGoalCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    targetDollars?: true
    currentDollars?: true
    ruleType?: true
    ruleValueBpsOrDollars?: true
    priority?: true
    createdAt?: true
    _all?: true
  }

  export type SavingsGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavingsGoal to aggregate.
     */
    where?: SavingsGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavingsGoals to fetch.
     */
    orderBy?: SavingsGoalOrderByWithRelationInput | SavingsGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavingsGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavingsGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavingsGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavingsGoals
    **/
    _count?: true | SavingsGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavingsGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavingsGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavingsGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavingsGoalMaxAggregateInputType
  }

  export type GetSavingsGoalAggregateType<T extends SavingsGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateSavingsGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavingsGoal[P]>
      : GetScalarType<T[P], AggregateSavingsGoal[P]>
  }




  export type SavingsGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavingsGoalWhereInput
    orderBy?: SavingsGoalOrderByWithAggregationInput | SavingsGoalOrderByWithAggregationInput[]
    by: SavingsGoalScalarFieldEnum[] | SavingsGoalScalarFieldEnum
    having?: SavingsGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavingsGoalCountAggregateInputType | true
    _avg?: SavingsGoalAvgAggregateInputType
    _sum?: SavingsGoalSumAggregateInputType
    _min?: SavingsGoalMinAggregateInputType
    _max?: SavingsGoalMaxAggregateInputType
  }

  export type SavingsGoalGroupByOutputType = {
    id: string
    userId: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority: number
    createdAt: Date
    _count: SavingsGoalCountAggregateOutputType | null
    _avg: SavingsGoalAvgAggregateOutputType | null
    _sum: SavingsGoalSumAggregateOutputType | null
    _min: SavingsGoalMinAggregateOutputType | null
    _max: SavingsGoalMaxAggregateOutputType | null
  }

  type GetSavingsGoalGroupByPayload<T extends SavingsGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavingsGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavingsGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavingsGoalGroupByOutputType[P]>
            : GetScalarType<T[P], SavingsGoalGroupByOutputType[P]>
        }
      >
    >


  export type SavingsGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    targetDollars?: boolean
    currentDollars?: boolean
    ruleType?: boolean
    ruleValueBpsOrDollars?: boolean
    priority?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savingsGoal"]>


  export type SavingsGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    targetDollars?: boolean
    currentDollars?: boolean
    ruleType?: boolean
    ruleValueBpsOrDollars?: boolean
    priority?: boolean
    createdAt?: boolean
  }

  export type SavingsGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavingsGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavingsGoal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      targetDollars: number
      currentDollars: number
      ruleType: $Enums.SavingsRuleType
      ruleValueBpsOrDollars: number
      priority: number
      createdAt: Date
    }, ExtArgs["result"]["savingsGoal"]>
    composites: {}
  }

  type SavingsGoalGetPayload<S extends boolean | null | undefined | SavingsGoalDefaultArgs> = $Result.GetResult<Prisma.$SavingsGoalPayload, S>

  type SavingsGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavingsGoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavingsGoalCountAggregateInputType | true
    }

  export interface SavingsGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavingsGoal'], meta: { name: 'SavingsGoal' } }
    /**
     * Find zero or one SavingsGoal that matches the filter.
     * @param {SavingsGoalFindUniqueArgs} args - Arguments to find a SavingsGoal
     * @example
     * // Get one SavingsGoal
     * const savingsGoal = await prisma.savingsGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavingsGoalFindUniqueArgs>(args: SelectSubset<T, SavingsGoalFindUniqueArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavingsGoal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavingsGoalFindUniqueOrThrowArgs} args - Arguments to find a SavingsGoal
     * @example
     * // Get one SavingsGoal
     * const savingsGoal = await prisma.savingsGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavingsGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, SavingsGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavingsGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalFindFirstArgs} args - Arguments to find a SavingsGoal
     * @example
     * // Get one SavingsGoal
     * const savingsGoal = await prisma.savingsGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavingsGoalFindFirstArgs>(args?: SelectSubset<T, SavingsGoalFindFirstArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavingsGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalFindFirstOrThrowArgs} args - Arguments to find a SavingsGoal
     * @example
     * // Get one SavingsGoal
     * const savingsGoal = await prisma.savingsGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavingsGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, SavingsGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavingsGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavingsGoals
     * const savingsGoals = await prisma.savingsGoal.findMany()
     * 
     * // Get first 10 SavingsGoals
     * const savingsGoals = await prisma.savingsGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savingsGoalWithIdOnly = await prisma.savingsGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavingsGoalFindManyArgs>(args?: SelectSubset<T, SavingsGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavingsGoal.
     * @param {SavingsGoalCreateArgs} args - Arguments to create a SavingsGoal.
     * @example
     * // Create one SavingsGoal
     * const SavingsGoal = await prisma.savingsGoal.create({
     *   data: {
     *     // ... data to create a SavingsGoal
     *   }
     * })
     * 
     */
    create<T extends SavingsGoalCreateArgs>(args: SelectSubset<T, SavingsGoalCreateArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavingsGoals.
     * @param {SavingsGoalCreateManyArgs} args - Arguments to create many SavingsGoals.
     * @example
     * // Create many SavingsGoals
     * const savingsGoal = await prisma.savingsGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavingsGoalCreateManyArgs>(args?: SelectSubset<T, SavingsGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SavingsGoal.
     * @param {SavingsGoalDeleteArgs} args - Arguments to delete one SavingsGoal.
     * @example
     * // Delete one SavingsGoal
     * const SavingsGoal = await prisma.savingsGoal.delete({
     *   where: {
     *     // ... filter to delete one SavingsGoal
     *   }
     * })
     * 
     */
    delete<T extends SavingsGoalDeleteArgs>(args: SelectSubset<T, SavingsGoalDeleteArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavingsGoal.
     * @param {SavingsGoalUpdateArgs} args - Arguments to update one SavingsGoal.
     * @example
     * // Update one SavingsGoal
     * const savingsGoal = await prisma.savingsGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavingsGoalUpdateArgs>(args: SelectSubset<T, SavingsGoalUpdateArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavingsGoals.
     * @param {SavingsGoalDeleteManyArgs} args - Arguments to filter SavingsGoals to delete.
     * @example
     * // Delete a few SavingsGoals
     * const { count } = await prisma.savingsGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavingsGoalDeleteManyArgs>(args?: SelectSubset<T, SavingsGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavingsGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavingsGoals
     * const savingsGoal = await prisma.savingsGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavingsGoalUpdateManyArgs>(args: SelectSubset<T, SavingsGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavingsGoal.
     * @param {SavingsGoalUpsertArgs} args - Arguments to update or create a SavingsGoal.
     * @example
     * // Update or create a SavingsGoal
     * const savingsGoal = await prisma.savingsGoal.upsert({
     *   create: {
     *     // ... data to create a SavingsGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavingsGoal we want to update
     *   }
     * })
     */
    upsert<T extends SavingsGoalUpsertArgs>(args: SelectSubset<T, SavingsGoalUpsertArgs<ExtArgs>>): Prisma__SavingsGoalClient<$Result.GetResult<Prisma.$SavingsGoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more SavingsGoals that matches the filter.
     * @param {SavingsGoalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const savingsGoal = await prisma.savingsGoal.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SavingsGoalFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SavingsGoal.
     * @param {SavingsGoalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const savingsGoal = await prisma.savingsGoal.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SavingsGoalAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SavingsGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalCountArgs} args - Arguments to filter SavingsGoals to count.
     * @example
     * // Count the number of SavingsGoals
     * const count = await prisma.savingsGoal.count({
     *   where: {
     *     // ... the filter for the SavingsGoals we want to count
     *   }
     * })
    **/
    count<T extends SavingsGoalCountArgs>(
      args?: Subset<T, SavingsGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavingsGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavingsGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavingsGoalAggregateArgs>(args: Subset<T, SavingsGoalAggregateArgs>): Prisma.PrismaPromise<GetSavingsGoalAggregateType<T>>

    /**
     * Group by SavingsGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavingsGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavingsGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavingsGoalGroupByArgs['orderBy'] }
        : { orderBy?: SavingsGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavingsGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavingsGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavingsGoal model
   */
  readonly fields: SavingsGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavingsGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavingsGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavingsGoal model
   */ 
  interface SavingsGoalFieldRefs {
    readonly id: FieldRef<"SavingsGoal", 'String'>
    readonly userId: FieldRef<"SavingsGoal", 'String'>
    readonly name: FieldRef<"SavingsGoal", 'String'>
    readonly targetDollars: FieldRef<"SavingsGoal", 'Float'>
    readonly currentDollars: FieldRef<"SavingsGoal", 'Float'>
    readonly ruleType: FieldRef<"SavingsGoal", 'SavingsRuleType'>
    readonly ruleValueBpsOrDollars: FieldRef<"SavingsGoal", 'Float'>
    readonly priority: FieldRef<"SavingsGoal", 'Int'>
    readonly createdAt: FieldRef<"SavingsGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavingsGoal findUnique
   */
  export type SavingsGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * Filter, which SavingsGoal to fetch.
     */
    where: SavingsGoalWhereUniqueInput
  }

  /**
   * SavingsGoal findUniqueOrThrow
   */
  export type SavingsGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * Filter, which SavingsGoal to fetch.
     */
    where: SavingsGoalWhereUniqueInput
  }

  /**
   * SavingsGoal findFirst
   */
  export type SavingsGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * Filter, which SavingsGoal to fetch.
     */
    where?: SavingsGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavingsGoals to fetch.
     */
    orderBy?: SavingsGoalOrderByWithRelationInput | SavingsGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavingsGoals.
     */
    cursor?: SavingsGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavingsGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavingsGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavingsGoals.
     */
    distinct?: SavingsGoalScalarFieldEnum | SavingsGoalScalarFieldEnum[]
  }

  /**
   * SavingsGoal findFirstOrThrow
   */
  export type SavingsGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * Filter, which SavingsGoal to fetch.
     */
    where?: SavingsGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavingsGoals to fetch.
     */
    orderBy?: SavingsGoalOrderByWithRelationInput | SavingsGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavingsGoals.
     */
    cursor?: SavingsGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavingsGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavingsGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavingsGoals.
     */
    distinct?: SavingsGoalScalarFieldEnum | SavingsGoalScalarFieldEnum[]
  }

  /**
   * SavingsGoal findMany
   */
  export type SavingsGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * Filter, which SavingsGoals to fetch.
     */
    where?: SavingsGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavingsGoals to fetch.
     */
    orderBy?: SavingsGoalOrderByWithRelationInput | SavingsGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavingsGoals.
     */
    cursor?: SavingsGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavingsGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavingsGoals.
     */
    skip?: number
    distinct?: SavingsGoalScalarFieldEnum | SavingsGoalScalarFieldEnum[]
  }

  /**
   * SavingsGoal create
   */
  export type SavingsGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a SavingsGoal.
     */
    data: XOR<SavingsGoalCreateInput, SavingsGoalUncheckedCreateInput>
  }

  /**
   * SavingsGoal createMany
   */
  export type SavingsGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavingsGoals.
     */
    data: SavingsGoalCreateManyInput | SavingsGoalCreateManyInput[]
  }

  /**
   * SavingsGoal update
   */
  export type SavingsGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a SavingsGoal.
     */
    data: XOR<SavingsGoalUpdateInput, SavingsGoalUncheckedUpdateInput>
    /**
     * Choose, which SavingsGoal to update.
     */
    where: SavingsGoalWhereUniqueInput
  }

  /**
   * SavingsGoal updateMany
   */
  export type SavingsGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavingsGoals.
     */
    data: XOR<SavingsGoalUpdateManyMutationInput, SavingsGoalUncheckedUpdateManyInput>
    /**
     * Filter which SavingsGoals to update
     */
    where?: SavingsGoalWhereInput
  }

  /**
   * SavingsGoal upsert
   */
  export type SavingsGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the SavingsGoal to update in case it exists.
     */
    where: SavingsGoalWhereUniqueInput
    /**
     * In case the SavingsGoal found by the `where` argument doesn't exist, create a new SavingsGoal with this data.
     */
    create: XOR<SavingsGoalCreateInput, SavingsGoalUncheckedCreateInput>
    /**
     * In case the SavingsGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavingsGoalUpdateInput, SavingsGoalUncheckedUpdateInput>
  }

  /**
   * SavingsGoal delete
   */
  export type SavingsGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
    /**
     * Filter which SavingsGoal to delete.
     */
    where: SavingsGoalWhereUniqueInput
  }

  /**
   * SavingsGoal deleteMany
   */
  export type SavingsGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavingsGoals to delete
     */
    where?: SavingsGoalWhereInput
  }

  /**
   * SavingsGoal findRaw
   */
  export type SavingsGoalFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SavingsGoal aggregateRaw
   */
  export type SavingsGoalAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SavingsGoal without action
   */
  export type SavingsGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavingsGoal
     */
    select?: SavingsGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavingsGoalInclude<ExtArgs> | null
  }


  /**
   * Model MandatorySavings
   */

  export type AggregateMandatorySavings = {
    _count: MandatorySavingsCountAggregateOutputType | null
    _avg: MandatorySavingsAvgAggregateOutputType | null
    _sum: MandatorySavingsSumAggregateOutputType | null
    _min: MandatorySavingsMinAggregateOutputType | null
    _max: MandatorySavingsMaxAggregateOutputType | null
  }

  export type MandatorySavingsAvgAggregateOutputType = {
    monthsToSave: number | null
    targetDollars: number | null
    currentDollars: number | null
  }

  export type MandatorySavingsSumAggregateOutputType = {
    monthsToSave: number | null
    targetDollars: number | null
    currentDollars: number | null
  }

  export type MandatorySavingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    monthsToSave: number | null
    targetDollars: number | null
    currentDollars: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MandatorySavingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    monthsToSave: number | null
    targetDollars: number | null
    currentDollars: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MandatorySavingsCountAggregateOutputType = {
    id: number
    userId: number
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MandatorySavingsAvgAggregateInputType = {
    monthsToSave?: true
    targetDollars?: true
    currentDollars?: true
  }

  export type MandatorySavingsSumAggregateInputType = {
    monthsToSave?: true
    targetDollars?: true
    currentDollars?: true
  }

  export type MandatorySavingsMinAggregateInputType = {
    id?: true
    userId?: true
    monthsToSave?: true
    targetDollars?: true
    currentDollars?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MandatorySavingsMaxAggregateInputType = {
    id?: true
    userId?: true
    monthsToSave?: true
    targetDollars?: true
    currentDollars?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MandatorySavingsCountAggregateInputType = {
    id?: true
    userId?: true
    monthsToSave?: true
    targetDollars?: true
    currentDollars?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MandatorySavingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MandatorySavings to aggregate.
     */
    where?: MandatorySavingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandatorySavings to fetch.
     */
    orderBy?: MandatorySavingsOrderByWithRelationInput | MandatorySavingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MandatorySavingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandatorySavings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandatorySavings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MandatorySavings
    **/
    _count?: true | MandatorySavingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MandatorySavingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MandatorySavingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MandatorySavingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MandatorySavingsMaxAggregateInputType
  }

  export type GetMandatorySavingsAggregateType<T extends MandatorySavingsAggregateArgs> = {
        [P in keyof T & keyof AggregateMandatorySavings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMandatorySavings[P]>
      : GetScalarType<T[P], AggregateMandatorySavings[P]>
  }




  export type MandatorySavingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MandatorySavingsWhereInput
    orderBy?: MandatorySavingsOrderByWithAggregationInput | MandatorySavingsOrderByWithAggregationInput[]
    by: MandatorySavingsScalarFieldEnum[] | MandatorySavingsScalarFieldEnum
    having?: MandatorySavingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MandatorySavingsCountAggregateInputType | true
    _avg?: MandatorySavingsAvgAggregateInputType
    _sum?: MandatorySavingsSumAggregateInputType
    _min?: MandatorySavingsMinAggregateInputType
    _max?: MandatorySavingsMaxAggregateInputType
  }

  export type MandatorySavingsGroupByOutputType = {
    id: string
    userId: string
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt: Date
    updatedAt: Date
    _count: MandatorySavingsCountAggregateOutputType | null
    _avg: MandatorySavingsAvgAggregateOutputType | null
    _sum: MandatorySavingsSumAggregateOutputType | null
    _min: MandatorySavingsMinAggregateOutputType | null
    _max: MandatorySavingsMaxAggregateOutputType | null
  }

  type GetMandatorySavingsGroupByPayload<T extends MandatorySavingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MandatorySavingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MandatorySavingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MandatorySavingsGroupByOutputType[P]>
            : GetScalarType<T[P], MandatorySavingsGroupByOutputType[P]>
        }
      >
    >


  export type MandatorySavingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthsToSave?: boolean
    targetDollars?: boolean
    currentDollars?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mandatorySavings"]>


  export type MandatorySavingsSelectScalar = {
    id?: boolean
    userId?: boolean
    monthsToSave?: boolean
    targetDollars?: boolean
    currentDollars?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MandatorySavingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MandatorySavingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MandatorySavings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      monthsToSave: number
      targetDollars: number
      currentDollars: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mandatorySavings"]>
    composites: {}
  }

  type MandatorySavingsGetPayload<S extends boolean | null | undefined | MandatorySavingsDefaultArgs> = $Result.GetResult<Prisma.$MandatorySavingsPayload, S>

  type MandatorySavingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MandatorySavingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MandatorySavingsCountAggregateInputType | true
    }

  export interface MandatorySavingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MandatorySavings'], meta: { name: 'MandatorySavings' } }
    /**
     * Find zero or one MandatorySavings that matches the filter.
     * @param {MandatorySavingsFindUniqueArgs} args - Arguments to find a MandatorySavings
     * @example
     * // Get one MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MandatorySavingsFindUniqueArgs>(args: SelectSubset<T, MandatorySavingsFindUniqueArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MandatorySavings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MandatorySavingsFindUniqueOrThrowArgs} args - Arguments to find a MandatorySavings
     * @example
     * // Get one MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MandatorySavingsFindUniqueOrThrowArgs>(args: SelectSubset<T, MandatorySavingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MandatorySavings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsFindFirstArgs} args - Arguments to find a MandatorySavings
     * @example
     * // Get one MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MandatorySavingsFindFirstArgs>(args?: SelectSubset<T, MandatorySavingsFindFirstArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MandatorySavings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsFindFirstOrThrowArgs} args - Arguments to find a MandatorySavings
     * @example
     * // Get one MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MandatorySavingsFindFirstOrThrowArgs>(args?: SelectSubset<T, MandatorySavingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MandatorySavings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.findMany()
     * 
     * // Get first 10 MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mandatorySavingsWithIdOnly = await prisma.mandatorySavings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MandatorySavingsFindManyArgs>(args?: SelectSubset<T, MandatorySavingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MandatorySavings.
     * @param {MandatorySavingsCreateArgs} args - Arguments to create a MandatorySavings.
     * @example
     * // Create one MandatorySavings
     * const MandatorySavings = await prisma.mandatorySavings.create({
     *   data: {
     *     // ... data to create a MandatorySavings
     *   }
     * })
     * 
     */
    create<T extends MandatorySavingsCreateArgs>(args: SelectSubset<T, MandatorySavingsCreateArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MandatorySavings.
     * @param {MandatorySavingsCreateManyArgs} args - Arguments to create many MandatorySavings.
     * @example
     * // Create many MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MandatorySavingsCreateManyArgs>(args?: SelectSubset<T, MandatorySavingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MandatorySavings.
     * @param {MandatorySavingsDeleteArgs} args - Arguments to delete one MandatorySavings.
     * @example
     * // Delete one MandatorySavings
     * const MandatorySavings = await prisma.mandatorySavings.delete({
     *   where: {
     *     // ... filter to delete one MandatorySavings
     *   }
     * })
     * 
     */
    delete<T extends MandatorySavingsDeleteArgs>(args: SelectSubset<T, MandatorySavingsDeleteArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MandatorySavings.
     * @param {MandatorySavingsUpdateArgs} args - Arguments to update one MandatorySavings.
     * @example
     * // Update one MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MandatorySavingsUpdateArgs>(args: SelectSubset<T, MandatorySavingsUpdateArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MandatorySavings.
     * @param {MandatorySavingsDeleteManyArgs} args - Arguments to filter MandatorySavings to delete.
     * @example
     * // Delete a few MandatorySavings
     * const { count } = await prisma.mandatorySavings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MandatorySavingsDeleteManyArgs>(args?: SelectSubset<T, MandatorySavingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MandatorySavings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MandatorySavingsUpdateManyArgs>(args: SelectSubset<T, MandatorySavingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MandatorySavings.
     * @param {MandatorySavingsUpsertArgs} args - Arguments to update or create a MandatorySavings.
     * @example
     * // Update or create a MandatorySavings
     * const mandatorySavings = await prisma.mandatorySavings.upsert({
     *   create: {
     *     // ... data to create a MandatorySavings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MandatorySavings we want to update
     *   }
     * })
     */
    upsert<T extends MandatorySavingsUpsertArgs>(args: SelectSubset<T, MandatorySavingsUpsertArgs<ExtArgs>>): Prisma__MandatorySavingsClient<$Result.GetResult<Prisma.$MandatorySavingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more MandatorySavings that matches the filter.
     * @param {MandatorySavingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mandatorySavings = await prisma.mandatorySavings.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: MandatorySavingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MandatorySavings.
     * @param {MandatorySavingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mandatorySavings = await prisma.mandatorySavings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MandatorySavingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MandatorySavings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsCountArgs} args - Arguments to filter MandatorySavings to count.
     * @example
     * // Count the number of MandatorySavings
     * const count = await prisma.mandatorySavings.count({
     *   where: {
     *     // ... the filter for the MandatorySavings we want to count
     *   }
     * })
    **/
    count<T extends MandatorySavingsCountArgs>(
      args?: Subset<T, MandatorySavingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MandatorySavingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MandatorySavings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MandatorySavingsAggregateArgs>(args: Subset<T, MandatorySavingsAggregateArgs>): Prisma.PrismaPromise<GetMandatorySavingsAggregateType<T>>

    /**
     * Group by MandatorySavings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandatorySavingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MandatorySavingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MandatorySavingsGroupByArgs['orderBy'] }
        : { orderBy?: MandatorySavingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MandatorySavingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMandatorySavingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MandatorySavings model
   */
  readonly fields: MandatorySavingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MandatorySavings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MandatorySavingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MandatorySavings model
   */ 
  interface MandatorySavingsFieldRefs {
    readonly id: FieldRef<"MandatorySavings", 'String'>
    readonly userId: FieldRef<"MandatorySavings", 'String'>
    readonly monthsToSave: FieldRef<"MandatorySavings", 'Int'>
    readonly targetDollars: FieldRef<"MandatorySavings", 'Float'>
    readonly currentDollars: FieldRef<"MandatorySavings", 'Float'>
    readonly createdAt: FieldRef<"MandatorySavings", 'DateTime'>
    readonly updatedAt: FieldRef<"MandatorySavings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MandatorySavings findUnique
   */
  export type MandatorySavingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * Filter, which MandatorySavings to fetch.
     */
    where: MandatorySavingsWhereUniqueInput
  }

  /**
   * MandatorySavings findUniqueOrThrow
   */
  export type MandatorySavingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * Filter, which MandatorySavings to fetch.
     */
    where: MandatorySavingsWhereUniqueInput
  }

  /**
   * MandatorySavings findFirst
   */
  export type MandatorySavingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * Filter, which MandatorySavings to fetch.
     */
    where?: MandatorySavingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandatorySavings to fetch.
     */
    orderBy?: MandatorySavingsOrderByWithRelationInput | MandatorySavingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MandatorySavings.
     */
    cursor?: MandatorySavingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandatorySavings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandatorySavings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MandatorySavings.
     */
    distinct?: MandatorySavingsScalarFieldEnum | MandatorySavingsScalarFieldEnum[]
  }

  /**
   * MandatorySavings findFirstOrThrow
   */
  export type MandatorySavingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * Filter, which MandatorySavings to fetch.
     */
    where?: MandatorySavingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandatorySavings to fetch.
     */
    orderBy?: MandatorySavingsOrderByWithRelationInput | MandatorySavingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MandatorySavings.
     */
    cursor?: MandatorySavingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandatorySavings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandatorySavings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MandatorySavings.
     */
    distinct?: MandatorySavingsScalarFieldEnum | MandatorySavingsScalarFieldEnum[]
  }

  /**
   * MandatorySavings findMany
   */
  export type MandatorySavingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * Filter, which MandatorySavings to fetch.
     */
    where?: MandatorySavingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandatorySavings to fetch.
     */
    orderBy?: MandatorySavingsOrderByWithRelationInput | MandatorySavingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MandatorySavings.
     */
    cursor?: MandatorySavingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandatorySavings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandatorySavings.
     */
    skip?: number
    distinct?: MandatorySavingsScalarFieldEnum | MandatorySavingsScalarFieldEnum[]
  }

  /**
   * MandatorySavings create
   */
  export type MandatorySavingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * The data needed to create a MandatorySavings.
     */
    data: XOR<MandatorySavingsCreateInput, MandatorySavingsUncheckedCreateInput>
  }

  /**
   * MandatorySavings createMany
   */
  export type MandatorySavingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MandatorySavings.
     */
    data: MandatorySavingsCreateManyInput | MandatorySavingsCreateManyInput[]
  }

  /**
   * MandatorySavings update
   */
  export type MandatorySavingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * The data needed to update a MandatorySavings.
     */
    data: XOR<MandatorySavingsUpdateInput, MandatorySavingsUncheckedUpdateInput>
    /**
     * Choose, which MandatorySavings to update.
     */
    where: MandatorySavingsWhereUniqueInput
  }

  /**
   * MandatorySavings updateMany
   */
  export type MandatorySavingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MandatorySavings.
     */
    data: XOR<MandatorySavingsUpdateManyMutationInput, MandatorySavingsUncheckedUpdateManyInput>
    /**
     * Filter which MandatorySavings to update
     */
    where?: MandatorySavingsWhereInput
  }

  /**
   * MandatorySavings upsert
   */
  export type MandatorySavingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * The filter to search for the MandatorySavings to update in case it exists.
     */
    where: MandatorySavingsWhereUniqueInput
    /**
     * In case the MandatorySavings found by the `where` argument doesn't exist, create a new MandatorySavings with this data.
     */
    create: XOR<MandatorySavingsCreateInput, MandatorySavingsUncheckedCreateInput>
    /**
     * In case the MandatorySavings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MandatorySavingsUpdateInput, MandatorySavingsUncheckedUpdateInput>
  }

  /**
   * MandatorySavings delete
   */
  export type MandatorySavingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
    /**
     * Filter which MandatorySavings to delete.
     */
    where: MandatorySavingsWhereUniqueInput
  }

  /**
   * MandatorySavings deleteMany
   */
  export type MandatorySavingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MandatorySavings to delete
     */
    where?: MandatorySavingsWhereInput
  }

  /**
   * MandatorySavings findRaw
   */
  export type MandatorySavingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MandatorySavings aggregateRaw
   */
  export type MandatorySavingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MandatorySavings without action
   */
  export type MandatorySavingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandatorySavings
     */
    select?: MandatorySavingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandatorySavingsInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    milestonePct: number | null
  }

  export type NotificationSumAggregateOutputType = {
    milestonePct: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    entityType: string | null
    entityId: string | null
    milestonePct: number | null
    message: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    entityType: string | null
    entityId: string | null
    milestonePct: number | null
    message: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    entityType: number
    entityId: number
    milestonePct: number
    message: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    milestonePct?: true
  }

  export type NotificationSumAggregateInputType = {
    milestonePct?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityType?: true
    entityId?: true
    milestonePct?: true
    message?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityType?: true
    entityId?: true
    milestonePct?: true
    message?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityType?: true
    entityId?: true
    milestonePct?: true
    message?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    entityType: string | null
    entityId: string | null
    milestonePct: number | null
    message: string
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    entityType?: boolean
    entityId?: boolean
    milestonePct?: boolean
    message?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    entityType?: boolean
    entityId?: boolean
    milestonePct?: boolean
    message?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      entityType: string | null
      entityId: string | null
      milestonePct: number | null
      message: string
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly entityType: FieldRef<"Notification", 'String'>
    readonly entityId: FieldRef<"Notification", 'String'>
    readonly milestonePct: FieldRef<"Notification", 'Int'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    horizonMonths: number | null
  }

  export type PlanSumAggregateOutputType = {
    horizonMonths: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    strategy: $Enums.PlanStrategy | null
    horizonMonths: number | null
    startDate: Date | null
    createdAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    strategy: $Enums.PlanStrategy | null
    horizonMonths: number | null
    startDate: Date | null
    createdAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    strategy: number
    horizonMonths: number
    startDate: number
    rulesJson: number
    summaryJson: number
    warningsJson: number
    createdAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    horizonMonths?: true
  }

  export type PlanSumAggregateInputType = {
    horizonMonths?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    strategy?: true
    horizonMonths?: true
    startDate?: true
    createdAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    strategy?: true
    horizonMonths?: true
    startDate?: true
    createdAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    strategy?: true
    horizonMonths?: true
    startDate?: true
    rulesJson?: true
    summaryJson?: true
    warningsJson?: true
    createdAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    userId: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date
    rulesJson: JsonValue
    summaryJson: JsonValue
    warningsJson: JsonValue
    createdAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    strategy?: boolean
    horizonMonths?: boolean
    startDate?: boolean
    rulesJson?: boolean
    summaryJson?: boolean
    warningsJson?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Plan$itemsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>


  export type PlanSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    strategy?: boolean
    horizonMonths?: boolean
    startDate?: boolean
    rulesJson?: boolean
    summaryJson?: boolean
    warningsJson?: boolean
    createdAt?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Plan$itemsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$PlanItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      strategy: $Enums.PlanStrategy
      horizonMonths: number
      startDate: Date
      rulesJson: Prisma.JsonValue
      summaryJson: Prisma.JsonValue
      warningsJson: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * @param {PlanFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const plan = await prisma.plan.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PlanFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Plan.
     * @param {PlanAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const plan = await prisma.plan.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlanAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Plan$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly userId: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly strategy: FieldRef<"Plan", 'PlanStrategy'>
    readonly horizonMonths: FieldRef<"Plan", 'Int'>
    readonly startDate: FieldRef<"Plan", 'DateTime'>
    readonly rulesJson: FieldRef<"Plan", 'Json'>
    readonly summaryJson: FieldRef<"Plan", 'Json'>
    readonly warningsJson: FieldRef<"Plan", 'Json'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan findRaw
   */
  export type PlanFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Plan aggregateRaw
   */
  export type PlanAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Plan.items
   */
  export type Plan$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    where?: PlanItemWhereInput
    orderBy?: PlanItemOrderByWithRelationInput | PlanItemOrderByWithRelationInput[]
    cursor?: PlanItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanItemScalarFieldEnum | PlanItemScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanItem
   */

  export type AggregatePlanItem = {
    _count: PlanItemCountAggregateOutputType | null
    _avg: PlanItemAvgAggregateOutputType | null
    _sum: PlanItemSumAggregateOutputType | null
    _min: PlanItemMinAggregateOutputType | null
    _max: PlanItemMaxAggregateOutputType | null
  }

  export type PlanItemAvgAggregateOutputType = {
    amountDollars: number | null
  }

  export type PlanItemSumAggregateOutputType = {
    amountDollars: number | null
  }

  export type PlanItemMinAggregateOutputType = {
    id: string | null
    planId: string | null
    date: Date | null
    type: $Enums.PlanItemType | null
    entityId: string | null
    amountDollars: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type PlanItemMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    date: Date | null
    type: $Enums.PlanItemType | null
    entityId: string | null
    amountDollars: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type PlanItemCountAggregateOutputType = {
    id: number
    planId: number
    date: number
    type: number
    entityId: number
    amountDollars: number
    notes: number
    balanceSnapshotJson: number
    createdAt: number
    _all: number
  }


  export type PlanItemAvgAggregateInputType = {
    amountDollars?: true
  }

  export type PlanItemSumAggregateInputType = {
    amountDollars?: true
  }

  export type PlanItemMinAggregateInputType = {
    id?: true
    planId?: true
    date?: true
    type?: true
    entityId?: true
    amountDollars?: true
    notes?: true
    createdAt?: true
  }

  export type PlanItemMaxAggregateInputType = {
    id?: true
    planId?: true
    date?: true
    type?: true
    entityId?: true
    amountDollars?: true
    notes?: true
    createdAt?: true
  }

  export type PlanItemCountAggregateInputType = {
    id?: true
    planId?: true
    date?: true
    type?: true
    entityId?: true
    amountDollars?: true
    notes?: true
    balanceSnapshotJson?: true
    createdAt?: true
    _all?: true
  }

  export type PlanItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanItem to aggregate.
     */
    where?: PlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanItems to fetch.
     */
    orderBy?: PlanItemOrderByWithRelationInput | PlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanItems
    **/
    _count?: true | PlanItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanItemMaxAggregateInputType
  }

  export type GetPlanItemAggregateType<T extends PlanItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanItem[P]>
      : GetScalarType<T[P], AggregatePlanItem[P]>
  }




  export type PlanItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanItemWhereInput
    orderBy?: PlanItemOrderByWithAggregationInput | PlanItemOrderByWithAggregationInput[]
    by: PlanItemScalarFieldEnum[] | PlanItemScalarFieldEnum
    having?: PlanItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanItemCountAggregateInputType | true
    _avg?: PlanItemAvgAggregateInputType
    _sum?: PlanItemSumAggregateInputType
    _min?: PlanItemMinAggregateInputType
    _max?: PlanItemMaxAggregateInputType
  }

  export type PlanItemGroupByOutputType = {
    id: string
    planId: string
    date: Date
    type: $Enums.PlanItemType
    entityId: string | null
    amountDollars: number
    notes: string | null
    balanceSnapshotJson: JsonValue | null
    createdAt: Date
    _count: PlanItemCountAggregateOutputType | null
    _avg: PlanItemAvgAggregateOutputType | null
    _sum: PlanItemSumAggregateOutputType | null
    _min: PlanItemMinAggregateOutputType | null
    _max: PlanItemMaxAggregateOutputType | null
  }

  type GetPlanItemGroupByPayload<T extends PlanItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlanItemGroupByOutputType[P]>
        }
      >
    >


  export type PlanItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    date?: boolean
    type?: boolean
    entityId?: boolean
    amountDollars?: boolean
    notes?: boolean
    balanceSnapshotJson?: boolean
    createdAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planItem"]>


  export type PlanItemSelectScalar = {
    id?: boolean
    planId?: boolean
    date?: boolean
    type?: boolean
    entityId?: boolean
    amountDollars?: boolean
    notes?: boolean
    balanceSnapshotJson?: boolean
    createdAt?: boolean
  }

  export type PlanItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanItem"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      date: Date
      type: $Enums.PlanItemType
      entityId: string | null
      amountDollars: number
      notes: string | null
      balanceSnapshotJson: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["planItem"]>
    composites: {}
  }

  type PlanItemGetPayload<S extends boolean | null | undefined | PlanItemDefaultArgs> = $Result.GetResult<Prisma.$PlanItemPayload, S>

  type PlanItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanItemCountAggregateInputType | true
    }

  export interface PlanItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanItem'], meta: { name: 'PlanItem' } }
    /**
     * Find zero or one PlanItem that matches the filter.
     * @param {PlanItemFindUniqueArgs} args - Arguments to find a PlanItem
     * @example
     * // Get one PlanItem
     * const planItem = await prisma.planItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanItemFindUniqueArgs>(args: SelectSubset<T, PlanItemFindUniqueArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanItemFindUniqueOrThrowArgs} args - Arguments to find a PlanItem
     * @example
     * // Get one PlanItem
     * const planItem = await prisma.planItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemFindFirstArgs} args - Arguments to find a PlanItem
     * @example
     * // Get one PlanItem
     * const planItem = await prisma.planItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanItemFindFirstArgs>(args?: SelectSubset<T, PlanItemFindFirstArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemFindFirstOrThrowArgs} args - Arguments to find a PlanItem
     * @example
     * // Get one PlanItem
     * const planItem = await prisma.planItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanItems
     * const planItems = await prisma.planItem.findMany()
     * 
     * // Get first 10 PlanItems
     * const planItems = await prisma.planItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planItemWithIdOnly = await prisma.planItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanItemFindManyArgs>(args?: SelectSubset<T, PlanItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanItem.
     * @param {PlanItemCreateArgs} args - Arguments to create a PlanItem.
     * @example
     * // Create one PlanItem
     * const PlanItem = await prisma.planItem.create({
     *   data: {
     *     // ... data to create a PlanItem
     *   }
     * })
     * 
     */
    create<T extends PlanItemCreateArgs>(args: SelectSubset<T, PlanItemCreateArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanItems.
     * @param {PlanItemCreateManyArgs} args - Arguments to create many PlanItems.
     * @example
     * // Create many PlanItems
     * const planItem = await prisma.planItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanItemCreateManyArgs>(args?: SelectSubset<T, PlanItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanItem.
     * @param {PlanItemDeleteArgs} args - Arguments to delete one PlanItem.
     * @example
     * // Delete one PlanItem
     * const PlanItem = await prisma.planItem.delete({
     *   where: {
     *     // ... filter to delete one PlanItem
     *   }
     * })
     * 
     */
    delete<T extends PlanItemDeleteArgs>(args: SelectSubset<T, PlanItemDeleteArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanItem.
     * @param {PlanItemUpdateArgs} args - Arguments to update one PlanItem.
     * @example
     * // Update one PlanItem
     * const planItem = await prisma.planItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanItemUpdateArgs>(args: SelectSubset<T, PlanItemUpdateArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanItems.
     * @param {PlanItemDeleteManyArgs} args - Arguments to filter PlanItems to delete.
     * @example
     * // Delete a few PlanItems
     * const { count } = await prisma.planItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanItemDeleteManyArgs>(args?: SelectSubset<T, PlanItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanItems
     * const planItem = await prisma.planItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanItemUpdateManyArgs>(args: SelectSubset<T, PlanItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanItem.
     * @param {PlanItemUpsertArgs} args - Arguments to update or create a PlanItem.
     * @example
     * // Update or create a PlanItem
     * const planItem = await prisma.planItem.upsert({
     *   create: {
     *     // ... data to create a PlanItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanItem we want to update
     *   }
     * })
     */
    upsert<T extends PlanItemUpsertArgs>(args: SelectSubset<T, PlanItemUpsertArgs<ExtArgs>>): Prisma__PlanItemClient<$Result.GetResult<Prisma.$PlanItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more PlanItems that matches the filter.
     * @param {PlanItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const planItem = await prisma.planItem.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PlanItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PlanItem.
     * @param {PlanItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const planItem = await prisma.planItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlanItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PlanItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemCountArgs} args - Arguments to filter PlanItems to count.
     * @example
     * // Count the number of PlanItems
     * const count = await prisma.planItem.count({
     *   where: {
     *     // ... the filter for the PlanItems we want to count
     *   }
     * })
    **/
    count<T extends PlanItemCountArgs>(
      args?: Subset<T, PlanItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanItemAggregateArgs>(args: Subset<T, PlanItemAggregateArgs>): Prisma.PrismaPromise<GetPlanItemAggregateType<T>>

    /**
     * Group by PlanItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanItemGroupByArgs['orderBy'] }
        : { orderBy?: PlanItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanItem model
   */
  readonly fields: PlanItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanItem model
   */ 
  interface PlanItemFieldRefs {
    readonly id: FieldRef<"PlanItem", 'String'>
    readonly planId: FieldRef<"PlanItem", 'String'>
    readonly date: FieldRef<"PlanItem", 'DateTime'>
    readonly type: FieldRef<"PlanItem", 'PlanItemType'>
    readonly entityId: FieldRef<"PlanItem", 'String'>
    readonly amountDollars: FieldRef<"PlanItem", 'Float'>
    readonly notes: FieldRef<"PlanItem", 'String'>
    readonly balanceSnapshotJson: FieldRef<"PlanItem", 'Json'>
    readonly createdAt: FieldRef<"PlanItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanItem findUnique
   */
  export type PlanItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanItem to fetch.
     */
    where: PlanItemWhereUniqueInput
  }

  /**
   * PlanItem findUniqueOrThrow
   */
  export type PlanItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanItem to fetch.
     */
    where: PlanItemWhereUniqueInput
  }

  /**
   * PlanItem findFirst
   */
  export type PlanItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanItem to fetch.
     */
    where?: PlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanItems to fetch.
     */
    orderBy?: PlanItemOrderByWithRelationInput | PlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanItems.
     */
    cursor?: PlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanItems.
     */
    distinct?: PlanItemScalarFieldEnum | PlanItemScalarFieldEnum[]
  }

  /**
   * PlanItem findFirstOrThrow
   */
  export type PlanItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanItem to fetch.
     */
    where?: PlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanItems to fetch.
     */
    orderBy?: PlanItemOrderByWithRelationInput | PlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanItems.
     */
    cursor?: PlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanItems.
     */
    distinct?: PlanItemScalarFieldEnum | PlanItemScalarFieldEnum[]
  }

  /**
   * PlanItem findMany
   */
  export type PlanItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * Filter, which PlanItems to fetch.
     */
    where?: PlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanItems to fetch.
     */
    orderBy?: PlanItemOrderByWithRelationInput | PlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanItems.
     */
    cursor?: PlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanItems.
     */
    skip?: number
    distinct?: PlanItemScalarFieldEnum | PlanItemScalarFieldEnum[]
  }

  /**
   * PlanItem create
   */
  export type PlanItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanItem.
     */
    data: XOR<PlanItemCreateInput, PlanItemUncheckedCreateInput>
  }

  /**
   * PlanItem createMany
   */
  export type PlanItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanItems.
     */
    data: PlanItemCreateManyInput | PlanItemCreateManyInput[]
  }

  /**
   * PlanItem update
   */
  export type PlanItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanItem.
     */
    data: XOR<PlanItemUpdateInput, PlanItemUncheckedUpdateInput>
    /**
     * Choose, which PlanItem to update.
     */
    where: PlanItemWhereUniqueInput
  }

  /**
   * PlanItem updateMany
   */
  export type PlanItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanItems.
     */
    data: XOR<PlanItemUpdateManyMutationInput, PlanItemUncheckedUpdateManyInput>
    /**
     * Filter which PlanItems to update
     */
    where?: PlanItemWhereInput
  }

  /**
   * PlanItem upsert
   */
  export type PlanItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanItem to update in case it exists.
     */
    where: PlanItemWhereUniqueInput
    /**
     * In case the PlanItem found by the `where` argument doesn't exist, create a new PlanItem with this data.
     */
    create: XOR<PlanItemCreateInput, PlanItemUncheckedCreateInput>
    /**
     * In case the PlanItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanItemUpdateInput, PlanItemUncheckedUpdateInput>
  }

  /**
   * PlanItem delete
   */
  export type PlanItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
    /**
     * Filter which PlanItem to delete.
     */
    where: PlanItemWhereUniqueInput
  }

  /**
   * PlanItem deleteMany
   */
  export type PlanItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanItems to delete
     */
    where?: PlanItemWhereInput
  }

  /**
   * PlanItem findRaw
   */
  export type PlanItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlanItem aggregateRaw
   */
  export type PlanItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlanItem without action
   */
  export type PlanItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanItem
     */
    select?: PlanItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanItemInclude<ExtArgs> | null
  }


  /**
   * Model DebtPayment
   */

  export type AggregateDebtPayment = {
    _count: DebtPaymentCountAggregateOutputType | null
    _avg: DebtPaymentAvgAggregateOutputType | null
    _sum: DebtPaymentSumAggregateOutputType | null
    _min: DebtPaymentMinAggregateOutputType | null
    _max: DebtPaymentMaxAggregateOutputType | null
  }

  export type DebtPaymentAvgAggregateOutputType = {
    amountDollars: number | null
  }

  export type DebtPaymentSumAggregateOutputType = {
    amountDollars: number | null
  }

  export type DebtPaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    debtId: string | null
    amountDollars: number | null
    paymentDate: Date | null
    createdAt: Date | null
  }

  export type DebtPaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    debtId: string | null
    amountDollars: number | null
    paymentDate: Date | null
    createdAt: Date | null
  }

  export type DebtPaymentCountAggregateOutputType = {
    id: number
    userId: number
    debtId: number
    amountDollars: number
    paymentDate: number
    createdAt: number
    _all: number
  }


  export type DebtPaymentAvgAggregateInputType = {
    amountDollars?: true
  }

  export type DebtPaymentSumAggregateInputType = {
    amountDollars?: true
  }

  export type DebtPaymentMinAggregateInputType = {
    id?: true
    userId?: true
    debtId?: true
    amountDollars?: true
    paymentDate?: true
    createdAt?: true
  }

  export type DebtPaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    debtId?: true
    amountDollars?: true
    paymentDate?: true
    createdAt?: true
  }

  export type DebtPaymentCountAggregateInputType = {
    id?: true
    userId?: true
    debtId?: true
    amountDollars?: true
    paymentDate?: true
    createdAt?: true
    _all?: true
  }

  export type DebtPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtPayment to aggregate.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtPayments
    **/
    _count?: true | DebtPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtPaymentMaxAggregateInputType
  }

  export type GetDebtPaymentAggregateType<T extends DebtPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtPayment[P]>
      : GetScalarType<T[P], AggregateDebtPayment[P]>
  }




  export type DebtPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtPaymentWhereInput
    orderBy?: DebtPaymentOrderByWithAggregationInput | DebtPaymentOrderByWithAggregationInput[]
    by: DebtPaymentScalarFieldEnum[] | DebtPaymentScalarFieldEnum
    having?: DebtPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtPaymentCountAggregateInputType | true
    _avg?: DebtPaymentAvgAggregateInputType
    _sum?: DebtPaymentSumAggregateInputType
    _min?: DebtPaymentMinAggregateInputType
    _max?: DebtPaymentMaxAggregateInputType
  }

  export type DebtPaymentGroupByOutputType = {
    id: string
    userId: string
    debtId: string
    amountDollars: number
    paymentDate: Date
    createdAt: Date
    _count: DebtPaymentCountAggregateOutputType | null
    _avg: DebtPaymentAvgAggregateOutputType | null
    _sum: DebtPaymentSumAggregateOutputType | null
    _min: DebtPaymentMinAggregateOutputType | null
    _max: DebtPaymentMaxAggregateOutputType | null
  }

  type GetDebtPaymentGroupByPayload<T extends DebtPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], DebtPaymentGroupByOutputType[P]>
        }
      >
    >


  export type DebtPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    debtId?: boolean
    amountDollars?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtPayment"]>


  export type DebtPaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    debtId?: boolean
    amountDollars?: boolean
    paymentDate?: boolean
    createdAt?: boolean
  }

  export type DebtPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }

  export type $DebtPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtPayment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      debt: Prisma.$DebtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      debtId: string
      amountDollars: number
      paymentDate: Date
      createdAt: Date
    }, ExtArgs["result"]["debtPayment"]>
    composites: {}
  }

  type DebtPaymentGetPayload<S extends boolean | null | undefined | DebtPaymentDefaultArgs> = $Result.GetResult<Prisma.$DebtPaymentPayload, S>

  type DebtPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DebtPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DebtPaymentCountAggregateInputType | true
    }

  export interface DebtPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtPayment'], meta: { name: 'DebtPayment' } }
    /**
     * Find zero or one DebtPayment that matches the filter.
     * @param {DebtPaymentFindUniqueArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtPaymentFindUniqueArgs>(args: SelectSubset<T, DebtPaymentFindUniqueArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DebtPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DebtPaymentFindUniqueOrThrowArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DebtPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentFindFirstArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtPaymentFindFirstArgs>(args?: SelectSubset<T, DebtPaymentFindFirstArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DebtPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentFindFirstOrThrowArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DebtPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtPayments
     * const debtPayments = await prisma.debtPayment.findMany()
     * 
     * // Get first 10 DebtPayments
     * const debtPayments = await prisma.debtPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtPaymentWithIdOnly = await prisma.debtPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtPaymentFindManyArgs>(args?: SelectSubset<T, DebtPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DebtPayment.
     * @param {DebtPaymentCreateArgs} args - Arguments to create a DebtPayment.
     * @example
     * // Create one DebtPayment
     * const DebtPayment = await prisma.debtPayment.create({
     *   data: {
     *     // ... data to create a DebtPayment
     *   }
     * })
     * 
     */
    create<T extends DebtPaymentCreateArgs>(args: SelectSubset<T, DebtPaymentCreateArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DebtPayments.
     * @param {DebtPaymentCreateManyArgs} args - Arguments to create many DebtPayments.
     * @example
     * // Create many DebtPayments
     * const debtPayment = await prisma.debtPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtPaymentCreateManyArgs>(args?: SelectSubset<T, DebtPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DebtPayment.
     * @param {DebtPaymentDeleteArgs} args - Arguments to delete one DebtPayment.
     * @example
     * // Delete one DebtPayment
     * const DebtPayment = await prisma.debtPayment.delete({
     *   where: {
     *     // ... filter to delete one DebtPayment
     *   }
     * })
     * 
     */
    delete<T extends DebtPaymentDeleteArgs>(args: SelectSubset<T, DebtPaymentDeleteArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DebtPayment.
     * @param {DebtPaymentUpdateArgs} args - Arguments to update one DebtPayment.
     * @example
     * // Update one DebtPayment
     * const debtPayment = await prisma.debtPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtPaymentUpdateArgs>(args: SelectSubset<T, DebtPaymentUpdateArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DebtPayments.
     * @param {DebtPaymentDeleteManyArgs} args - Arguments to filter DebtPayments to delete.
     * @example
     * // Delete a few DebtPayments
     * const { count } = await prisma.debtPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtPaymentDeleteManyArgs>(args?: SelectSubset<T, DebtPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtPayments
     * const debtPayment = await prisma.debtPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtPaymentUpdateManyArgs>(args: SelectSubset<T, DebtPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DebtPayment.
     * @param {DebtPaymentUpsertArgs} args - Arguments to update or create a DebtPayment.
     * @example
     * // Update or create a DebtPayment
     * const debtPayment = await prisma.debtPayment.upsert({
     *   create: {
     *     // ... data to create a DebtPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtPayment we want to update
     *   }
     * })
     */
    upsert<T extends DebtPaymentUpsertArgs>(args: SelectSubset<T, DebtPaymentUpsertArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DebtPayments that matches the filter.
     * @param {DebtPaymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const debtPayment = await prisma.debtPayment.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DebtPaymentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DebtPayment.
     * @param {DebtPaymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const debtPayment = await prisma.debtPayment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DebtPaymentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DebtPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentCountArgs} args - Arguments to filter DebtPayments to count.
     * @example
     * // Count the number of DebtPayments
     * const count = await prisma.debtPayment.count({
     *   where: {
     *     // ... the filter for the DebtPayments we want to count
     *   }
     * })
    **/
    count<T extends DebtPaymentCountArgs>(
      args?: Subset<T, DebtPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtPaymentAggregateArgs>(args: Subset<T, DebtPaymentAggregateArgs>): Prisma.PrismaPromise<GetDebtPaymentAggregateType<T>>

    /**
     * Group by DebtPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtPaymentGroupByArgs['orderBy'] }
        : { orderBy?: DebtPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtPayment model
   */
  readonly fields: DebtPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    debt<T extends DebtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtDefaultArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtPayment model
   */ 
  interface DebtPaymentFieldRefs {
    readonly id: FieldRef<"DebtPayment", 'String'>
    readonly userId: FieldRef<"DebtPayment", 'String'>
    readonly debtId: FieldRef<"DebtPayment", 'String'>
    readonly amountDollars: FieldRef<"DebtPayment", 'Float'>
    readonly paymentDate: FieldRef<"DebtPayment", 'DateTime'>
    readonly createdAt: FieldRef<"DebtPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DebtPayment findUnique
   */
  export type DebtPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment findUniqueOrThrow
   */
  export type DebtPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment findFirst
   */
  export type DebtPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtPayments.
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtPayments.
     */
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * DebtPayment findFirstOrThrow
   */
  export type DebtPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtPayments.
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtPayments.
     */
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * DebtPayment findMany
   */
  export type DebtPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayments to fetch.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtPayments.
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * DebtPayment create
   */
  export type DebtPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtPayment.
     */
    data: XOR<DebtPaymentCreateInput, DebtPaymentUncheckedCreateInput>
  }

  /**
   * DebtPayment createMany
   */
  export type DebtPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtPayments.
     */
    data: DebtPaymentCreateManyInput | DebtPaymentCreateManyInput[]
  }

  /**
   * DebtPayment update
   */
  export type DebtPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtPayment.
     */
    data: XOR<DebtPaymentUpdateInput, DebtPaymentUncheckedUpdateInput>
    /**
     * Choose, which DebtPayment to update.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment updateMany
   */
  export type DebtPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtPayments.
     */
    data: XOR<DebtPaymentUpdateManyMutationInput, DebtPaymentUncheckedUpdateManyInput>
    /**
     * Filter which DebtPayments to update
     */
    where?: DebtPaymentWhereInput
  }

  /**
   * DebtPayment upsert
   */
  export type DebtPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtPayment to update in case it exists.
     */
    where: DebtPaymentWhereUniqueInput
    /**
     * In case the DebtPayment found by the `where` argument doesn't exist, create a new DebtPayment with this data.
     */
    create: XOR<DebtPaymentCreateInput, DebtPaymentUncheckedCreateInput>
    /**
     * In case the DebtPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtPaymentUpdateInput, DebtPaymentUncheckedUpdateInput>
  }

  /**
   * DebtPayment delete
   */
  export type DebtPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter which DebtPayment to delete.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment deleteMany
   */
  export type DebtPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtPayments to delete
     */
    where?: DebtPaymentWhereInput
  }

  /**
   * DebtPayment findRaw
   */
  export type DebtPaymentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DebtPayment aggregateRaw
   */
  export type DebtPaymentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DebtPayment without action
   */
  export type DebtPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PlaidItem
   */

  export type AggregatePlaidItem = {
    _count: PlaidItemCountAggregateOutputType | null
    _min: PlaidItemMinAggregateOutputType | null
    _max: PlaidItemMaxAggregateOutputType | null
  }

  export type PlaidItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    accessTokenEncrypted: string | null
    institutionId: string | null
    institutionName: string | null
    transactionsCursor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaidItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    accessTokenEncrypted: string | null
    institutionId: string | null
    institutionName: string | null
    transactionsCursor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaidItemCountAggregateOutputType = {
    id: number
    userId: number
    itemId: number
    accessTokenEncrypted: number
    institutionId: number
    institutionName: number
    transactionsCursor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaidItemMinAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    accessTokenEncrypted?: true
    institutionId?: true
    institutionName?: true
    transactionsCursor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaidItemMaxAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    accessTokenEncrypted?: true
    institutionId?: true
    institutionName?: true
    transactionsCursor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaidItemCountAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    accessTokenEncrypted?: true
    institutionId?: true
    institutionName?: true
    transactionsCursor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaidItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaidItem to aggregate.
     */
    where?: PlaidItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaidItems to fetch.
     */
    orderBy?: PlaidItemOrderByWithRelationInput | PlaidItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaidItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaidItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaidItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaidItems
    **/
    _count?: true | PlaidItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaidItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaidItemMaxAggregateInputType
  }

  export type GetPlaidItemAggregateType<T extends PlaidItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaidItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaidItem[P]>
      : GetScalarType<T[P], AggregatePlaidItem[P]>
  }




  export type PlaidItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaidItemWhereInput
    orderBy?: PlaidItemOrderByWithAggregationInput | PlaidItemOrderByWithAggregationInput[]
    by: PlaidItemScalarFieldEnum[] | PlaidItemScalarFieldEnum
    having?: PlaidItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaidItemCountAggregateInputType | true
    _min?: PlaidItemMinAggregateInputType
    _max?: PlaidItemMaxAggregateInputType
  }

  export type PlaidItemGroupByOutputType = {
    id: string
    userId: string
    itemId: string
    accessTokenEncrypted: string
    institutionId: string | null
    institutionName: string | null
    transactionsCursor: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlaidItemCountAggregateOutputType | null
    _min: PlaidItemMinAggregateOutputType | null
    _max: PlaidItemMaxAggregateOutputType | null
  }

  type GetPlaidItemGroupByPayload<T extends PlaidItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaidItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaidItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaidItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlaidItemGroupByOutputType[P]>
        }
      >
    >


  export type PlaidItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    accessTokenEncrypted?: boolean
    institutionId?: boolean
    institutionName?: boolean
    transactionsCursor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accounts?: boolean | PlaidItem$accountsArgs<ExtArgs>
    _count?: boolean | PlaidItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaidItem"]>


  export type PlaidItemSelectScalar = {
    id?: boolean
    userId?: boolean
    itemId?: boolean
    accessTokenEncrypted?: boolean
    institutionId?: boolean
    institutionName?: boolean
    transactionsCursor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlaidItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accounts?: boolean | PlaidItem$accountsArgs<ExtArgs>
    _count?: boolean | PlaidItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlaidItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaidItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemId: string
      accessTokenEncrypted: string
      institutionId: string | null
      institutionName: string | null
      transactionsCursor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plaidItem"]>
    composites: {}
  }

  type PlaidItemGetPayload<S extends boolean | null | undefined | PlaidItemDefaultArgs> = $Result.GetResult<Prisma.$PlaidItemPayload, S>

  type PlaidItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlaidItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlaidItemCountAggregateInputType | true
    }

  export interface PlaidItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaidItem'], meta: { name: 'PlaidItem' } }
    /**
     * Find zero or one PlaidItem that matches the filter.
     * @param {PlaidItemFindUniqueArgs} args - Arguments to find a PlaidItem
     * @example
     * // Get one PlaidItem
     * const plaidItem = await prisma.plaidItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaidItemFindUniqueArgs>(args: SelectSubset<T, PlaidItemFindUniqueArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlaidItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlaidItemFindUniqueOrThrowArgs} args - Arguments to find a PlaidItem
     * @example
     * // Get one PlaidItem
     * const plaidItem = await prisma.plaidItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaidItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaidItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlaidItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemFindFirstArgs} args - Arguments to find a PlaidItem
     * @example
     * // Get one PlaidItem
     * const plaidItem = await prisma.plaidItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaidItemFindFirstArgs>(args?: SelectSubset<T, PlaidItemFindFirstArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlaidItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemFindFirstOrThrowArgs} args - Arguments to find a PlaidItem
     * @example
     * // Get one PlaidItem
     * const plaidItem = await prisma.plaidItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaidItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaidItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlaidItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaidItems
     * const plaidItems = await prisma.plaidItem.findMany()
     * 
     * // Get first 10 PlaidItems
     * const plaidItems = await prisma.plaidItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plaidItemWithIdOnly = await prisma.plaidItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaidItemFindManyArgs>(args?: SelectSubset<T, PlaidItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlaidItem.
     * @param {PlaidItemCreateArgs} args - Arguments to create a PlaidItem.
     * @example
     * // Create one PlaidItem
     * const PlaidItem = await prisma.plaidItem.create({
     *   data: {
     *     // ... data to create a PlaidItem
     *   }
     * })
     * 
     */
    create<T extends PlaidItemCreateArgs>(args: SelectSubset<T, PlaidItemCreateArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlaidItems.
     * @param {PlaidItemCreateManyArgs} args - Arguments to create many PlaidItems.
     * @example
     * // Create many PlaidItems
     * const plaidItem = await prisma.plaidItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaidItemCreateManyArgs>(args?: SelectSubset<T, PlaidItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlaidItem.
     * @param {PlaidItemDeleteArgs} args - Arguments to delete one PlaidItem.
     * @example
     * // Delete one PlaidItem
     * const PlaidItem = await prisma.plaidItem.delete({
     *   where: {
     *     // ... filter to delete one PlaidItem
     *   }
     * })
     * 
     */
    delete<T extends PlaidItemDeleteArgs>(args: SelectSubset<T, PlaidItemDeleteArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlaidItem.
     * @param {PlaidItemUpdateArgs} args - Arguments to update one PlaidItem.
     * @example
     * // Update one PlaidItem
     * const plaidItem = await prisma.plaidItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaidItemUpdateArgs>(args: SelectSubset<T, PlaidItemUpdateArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlaidItems.
     * @param {PlaidItemDeleteManyArgs} args - Arguments to filter PlaidItems to delete.
     * @example
     * // Delete a few PlaidItems
     * const { count } = await prisma.plaidItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaidItemDeleteManyArgs>(args?: SelectSubset<T, PlaidItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaidItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaidItems
     * const plaidItem = await prisma.plaidItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaidItemUpdateManyArgs>(args: SelectSubset<T, PlaidItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlaidItem.
     * @param {PlaidItemUpsertArgs} args - Arguments to update or create a PlaidItem.
     * @example
     * // Update or create a PlaidItem
     * const plaidItem = await prisma.plaidItem.upsert({
     *   create: {
     *     // ... data to create a PlaidItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaidItem we want to update
     *   }
     * })
     */
    upsert<T extends PlaidItemUpsertArgs>(args: SelectSubset<T, PlaidItemUpsertArgs<ExtArgs>>): Prisma__PlaidItemClient<$Result.GetResult<Prisma.$PlaidItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more PlaidItems that matches the filter.
     * @param {PlaidItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const plaidItem = await prisma.plaidItem.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PlaidItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PlaidItem.
     * @param {PlaidItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const plaidItem = await prisma.plaidItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlaidItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PlaidItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemCountArgs} args - Arguments to filter PlaidItems to count.
     * @example
     * // Count the number of PlaidItems
     * const count = await prisma.plaidItem.count({
     *   where: {
     *     // ... the filter for the PlaidItems we want to count
     *   }
     * })
    **/
    count<T extends PlaidItemCountArgs>(
      args?: Subset<T, PlaidItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaidItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaidItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaidItemAggregateArgs>(args: Subset<T, PlaidItemAggregateArgs>): Prisma.PrismaPromise<GetPlaidItemAggregateType<T>>

    /**
     * Group by PlaidItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaidItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaidItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaidItemGroupByArgs['orderBy'] }
        : { orderBy?: PlaidItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaidItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaidItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaidItem model
   */
  readonly fields: PlaidItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaidItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaidItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    accounts<T extends PlaidItem$accountsArgs<ExtArgs> = {}>(args?: Subset<T, PlaidItem$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaidItem model
   */ 
  interface PlaidItemFieldRefs {
    readonly id: FieldRef<"PlaidItem", 'String'>
    readonly userId: FieldRef<"PlaidItem", 'String'>
    readonly itemId: FieldRef<"PlaidItem", 'String'>
    readonly accessTokenEncrypted: FieldRef<"PlaidItem", 'String'>
    readonly institutionId: FieldRef<"PlaidItem", 'String'>
    readonly institutionName: FieldRef<"PlaidItem", 'String'>
    readonly transactionsCursor: FieldRef<"PlaidItem", 'String'>
    readonly createdAt: FieldRef<"PlaidItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PlaidItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaidItem findUnique
   */
  export type PlaidItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaidItem to fetch.
     */
    where: PlaidItemWhereUniqueInput
  }

  /**
   * PlaidItem findUniqueOrThrow
   */
  export type PlaidItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaidItem to fetch.
     */
    where: PlaidItemWhereUniqueInput
  }

  /**
   * PlaidItem findFirst
   */
  export type PlaidItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaidItem to fetch.
     */
    where?: PlaidItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaidItems to fetch.
     */
    orderBy?: PlaidItemOrderByWithRelationInput | PlaidItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaidItems.
     */
    cursor?: PlaidItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaidItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaidItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaidItems.
     */
    distinct?: PlaidItemScalarFieldEnum | PlaidItemScalarFieldEnum[]
  }

  /**
   * PlaidItem findFirstOrThrow
   */
  export type PlaidItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaidItem to fetch.
     */
    where?: PlaidItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaidItems to fetch.
     */
    orderBy?: PlaidItemOrderByWithRelationInput | PlaidItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaidItems.
     */
    cursor?: PlaidItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaidItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaidItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaidItems.
     */
    distinct?: PlaidItemScalarFieldEnum | PlaidItemScalarFieldEnum[]
  }

  /**
   * PlaidItem findMany
   */
  export type PlaidItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaidItems to fetch.
     */
    where?: PlaidItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaidItems to fetch.
     */
    orderBy?: PlaidItemOrderByWithRelationInput | PlaidItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaidItems.
     */
    cursor?: PlaidItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaidItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaidItems.
     */
    skip?: number
    distinct?: PlaidItemScalarFieldEnum | PlaidItemScalarFieldEnum[]
  }

  /**
   * PlaidItem create
   */
  export type PlaidItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaidItem.
     */
    data: XOR<PlaidItemCreateInput, PlaidItemUncheckedCreateInput>
  }

  /**
   * PlaidItem createMany
   */
  export type PlaidItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaidItems.
     */
    data: PlaidItemCreateManyInput | PlaidItemCreateManyInput[]
  }

  /**
   * PlaidItem update
   */
  export type PlaidItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaidItem.
     */
    data: XOR<PlaidItemUpdateInput, PlaidItemUncheckedUpdateInput>
    /**
     * Choose, which PlaidItem to update.
     */
    where: PlaidItemWhereUniqueInput
  }

  /**
   * PlaidItem updateMany
   */
  export type PlaidItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaidItems.
     */
    data: XOR<PlaidItemUpdateManyMutationInput, PlaidItemUncheckedUpdateManyInput>
    /**
     * Filter which PlaidItems to update
     */
    where?: PlaidItemWhereInput
  }

  /**
   * PlaidItem upsert
   */
  export type PlaidItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaidItem to update in case it exists.
     */
    where: PlaidItemWhereUniqueInput
    /**
     * In case the PlaidItem found by the `where` argument doesn't exist, create a new PlaidItem with this data.
     */
    create: XOR<PlaidItemCreateInput, PlaidItemUncheckedCreateInput>
    /**
     * In case the PlaidItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaidItemUpdateInput, PlaidItemUncheckedUpdateInput>
  }

  /**
   * PlaidItem delete
   */
  export type PlaidItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
    /**
     * Filter which PlaidItem to delete.
     */
    where: PlaidItemWhereUniqueInput
  }

  /**
   * PlaidItem deleteMany
   */
  export type PlaidItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaidItems to delete
     */
    where?: PlaidItemWhereInput
  }

  /**
   * PlaidItem findRaw
   */
  export type PlaidItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlaidItem aggregateRaw
   */
  export type PlaidItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlaidItem.accounts
   */
  export type PlaidItem$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * PlaidItem without action
   */
  export type PlaidItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaidItem
     */
    select?: PlaidItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaidItemInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    userId: string
    name: string
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactionTags?: boolean | Tag$transactionTagsArgs<ExtArgs>
    incomeStreamTags?: boolean | Tag$incomeStreamTagsArgs<ExtArgs>
    debtTags?: boolean | Tag$debtTagsArgs<ExtArgs>
    budgets?: boolean | Tag$budgetsArgs<ExtArgs>
    tagRuleTags?: boolean | Tag$tagRuleTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>


  export type TagSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactionTags?: boolean | Tag$transactionTagsArgs<ExtArgs>
    incomeStreamTags?: boolean | Tag$incomeStreamTagsArgs<ExtArgs>
    debtTags?: boolean | Tag$debtTagsArgs<ExtArgs>
    budgets?: boolean | Tag$budgetsArgs<ExtArgs>
    tagRuleTags?: boolean | Tag$tagRuleTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactionTags: Prisma.$TransactionTagPayload<ExtArgs>[]
      incomeStreamTags: Prisma.$IncomeStreamTagPayload<ExtArgs>[]
      debtTags: Prisma.$DebtTagPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      tagRuleTags: Prisma.$TagRuleTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * @param {TagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tag = await prisma.tag.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tag.
     * @param {TagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tag = await prisma.tag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactionTags<T extends Tag$transactionTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$transactionTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findMany"> | Null>
    incomeStreamTags<T extends Tag$incomeStreamTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$incomeStreamTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findMany"> | Null>
    debtTags<T extends Tag$debtTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$debtTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends Tag$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    tagRuleTags<T extends Tag$tagRuleTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$tagRuleTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly userId: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag findRaw
   */
  export type TagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tag aggregateRaw
   */
  export type TagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tag.transactionTags
   */
  export type Tag$transactionTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    where?: TransactionTagWhereInput
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    cursor?: TransactionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * Tag.incomeStreamTags
   */
  export type Tag$incomeStreamTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    where?: IncomeStreamTagWhereInput
    orderBy?: IncomeStreamTagOrderByWithRelationInput | IncomeStreamTagOrderByWithRelationInput[]
    cursor?: IncomeStreamTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncomeStreamTagScalarFieldEnum | IncomeStreamTagScalarFieldEnum[]
  }

  /**
   * Tag.debtTags
   */
  export type Tag$debtTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    where?: DebtTagWhereInput
    orderBy?: DebtTagOrderByWithRelationInput | DebtTagOrderByWithRelationInput[]
    cursor?: DebtTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtTagScalarFieldEnum | DebtTagScalarFieldEnum[]
  }

  /**
   * Tag.budgets
   */
  export type Tag$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Tag.tagRuleTags
   */
  export type Tag$tagRuleTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    where?: TagRuleTagWhereInput
    orderBy?: TagRuleTagOrderByWithRelationInput | TagRuleTagOrderByWithRelationInput[]
    cursor?: TagRuleTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagRuleTagScalarFieldEnum | TagRuleTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagRuleTag
   */

  export type AggregateTagRuleTag = {
    _count: TagRuleTagCountAggregateOutputType | null
    _min: TagRuleTagMinAggregateOutputType | null
    _max: TagRuleTagMaxAggregateOutputType | null
  }

  export type TagRuleTagMinAggregateOutputType = {
    id: string | null
    tagRuleId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type TagRuleTagMaxAggregateOutputType = {
    id: string | null
    tagRuleId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type TagRuleTagCountAggregateOutputType = {
    id: number
    tagRuleId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type TagRuleTagMinAggregateInputType = {
    id?: true
    tagRuleId?: true
    tagId?: true
    createdAt?: true
  }

  export type TagRuleTagMaxAggregateInputType = {
    id?: true
    tagRuleId?: true
    tagId?: true
    createdAt?: true
  }

  export type TagRuleTagCountAggregateInputType = {
    id?: true
    tagRuleId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type TagRuleTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagRuleTag to aggregate.
     */
    where?: TagRuleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRuleTags to fetch.
     */
    orderBy?: TagRuleTagOrderByWithRelationInput | TagRuleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagRuleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRuleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRuleTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagRuleTags
    **/
    _count?: true | TagRuleTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagRuleTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagRuleTagMaxAggregateInputType
  }

  export type GetTagRuleTagAggregateType<T extends TagRuleTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTagRuleTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagRuleTag[P]>
      : GetScalarType<T[P], AggregateTagRuleTag[P]>
  }




  export type TagRuleTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagRuleTagWhereInput
    orderBy?: TagRuleTagOrderByWithAggregationInput | TagRuleTagOrderByWithAggregationInput[]
    by: TagRuleTagScalarFieldEnum[] | TagRuleTagScalarFieldEnum
    having?: TagRuleTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagRuleTagCountAggregateInputType | true
    _min?: TagRuleTagMinAggregateInputType
    _max?: TagRuleTagMaxAggregateInputType
  }

  export type TagRuleTagGroupByOutputType = {
    id: string
    tagRuleId: string
    tagId: string
    createdAt: Date
    _count: TagRuleTagCountAggregateOutputType | null
    _min: TagRuleTagMinAggregateOutputType | null
    _max: TagRuleTagMaxAggregateOutputType | null
  }

  type GetTagRuleTagGroupByPayload<T extends TagRuleTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagRuleTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagRuleTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagRuleTagGroupByOutputType[P]>
            : GetScalarType<T[P], TagRuleTagGroupByOutputType[P]>
        }
      >
    >


  export type TagRuleTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagRuleId?: boolean
    tagId?: boolean
    createdAt?: boolean
    tagRule?: boolean | TagRuleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagRuleTag"]>


  export type TagRuleTagSelectScalar = {
    id?: boolean
    tagRuleId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type TagRuleTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagRule?: boolean | TagRuleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TagRuleTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagRuleTag"
    objects: {
      tagRule: Prisma.$TagRulePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagRuleId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["tagRuleTag"]>
    composites: {}
  }

  type TagRuleTagGetPayload<S extends boolean | null | undefined | TagRuleTagDefaultArgs> = $Result.GetResult<Prisma.$TagRuleTagPayload, S>

  type TagRuleTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagRuleTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagRuleTagCountAggregateInputType | true
    }

  export interface TagRuleTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagRuleTag'], meta: { name: 'TagRuleTag' } }
    /**
     * Find zero or one TagRuleTag that matches the filter.
     * @param {TagRuleTagFindUniqueArgs} args - Arguments to find a TagRuleTag
     * @example
     * // Get one TagRuleTag
     * const tagRuleTag = await prisma.tagRuleTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagRuleTagFindUniqueArgs>(args: SelectSubset<T, TagRuleTagFindUniqueArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TagRuleTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagRuleTagFindUniqueOrThrowArgs} args - Arguments to find a TagRuleTag
     * @example
     * // Get one TagRuleTag
     * const tagRuleTag = await prisma.tagRuleTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagRuleTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagRuleTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TagRuleTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagFindFirstArgs} args - Arguments to find a TagRuleTag
     * @example
     * // Get one TagRuleTag
     * const tagRuleTag = await prisma.tagRuleTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagRuleTagFindFirstArgs>(args?: SelectSubset<T, TagRuleTagFindFirstArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TagRuleTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagFindFirstOrThrowArgs} args - Arguments to find a TagRuleTag
     * @example
     * // Get one TagRuleTag
     * const tagRuleTag = await prisma.tagRuleTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagRuleTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagRuleTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TagRuleTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagRuleTags
     * const tagRuleTags = await prisma.tagRuleTag.findMany()
     * 
     * // Get first 10 TagRuleTags
     * const tagRuleTags = await prisma.tagRuleTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagRuleTagWithIdOnly = await prisma.tagRuleTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagRuleTagFindManyArgs>(args?: SelectSubset<T, TagRuleTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TagRuleTag.
     * @param {TagRuleTagCreateArgs} args - Arguments to create a TagRuleTag.
     * @example
     * // Create one TagRuleTag
     * const TagRuleTag = await prisma.tagRuleTag.create({
     *   data: {
     *     // ... data to create a TagRuleTag
     *   }
     * })
     * 
     */
    create<T extends TagRuleTagCreateArgs>(args: SelectSubset<T, TagRuleTagCreateArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TagRuleTags.
     * @param {TagRuleTagCreateManyArgs} args - Arguments to create many TagRuleTags.
     * @example
     * // Create many TagRuleTags
     * const tagRuleTag = await prisma.tagRuleTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagRuleTagCreateManyArgs>(args?: SelectSubset<T, TagRuleTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TagRuleTag.
     * @param {TagRuleTagDeleteArgs} args - Arguments to delete one TagRuleTag.
     * @example
     * // Delete one TagRuleTag
     * const TagRuleTag = await prisma.tagRuleTag.delete({
     *   where: {
     *     // ... filter to delete one TagRuleTag
     *   }
     * })
     * 
     */
    delete<T extends TagRuleTagDeleteArgs>(args: SelectSubset<T, TagRuleTagDeleteArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TagRuleTag.
     * @param {TagRuleTagUpdateArgs} args - Arguments to update one TagRuleTag.
     * @example
     * // Update one TagRuleTag
     * const tagRuleTag = await prisma.tagRuleTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagRuleTagUpdateArgs>(args: SelectSubset<T, TagRuleTagUpdateArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TagRuleTags.
     * @param {TagRuleTagDeleteManyArgs} args - Arguments to filter TagRuleTags to delete.
     * @example
     * // Delete a few TagRuleTags
     * const { count } = await prisma.tagRuleTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagRuleTagDeleteManyArgs>(args?: SelectSubset<T, TagRuleTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagRuleTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagRuleTags
     * const tagRuleTag = await prisma.tagRuleTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagRuleTagUpdateManyArgs>(args: SelectSubset<T, TagRuleTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TagRuleTag.
     * @param {TagRuleTagUpsertArgs} args - Arguments to update or create a TagRuleTag.
     * @example
     * // Update or create a TagRuleTag
     * const tagRuleTag = await prisma.tagRuleTag.upsert({
     *   create: {
     *     // ... data to create a TagRuleTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagRuleTag we want to update
     *   }
     * })
     */
    upsert<T extends TagRuleTagUpsertArgs>(args: SelectSubset<T, TagRuleTagUpsertArgs<ExtArgs>>): Prisma__TagRuleTagClient<$Result.GetResult<Prisma.$TagRuleTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TagRuleTags that matches the filter.
     * @param {TagRuleTagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tagRuleTag = await prisma.tagRuleTag.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TagRuleTagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TagRuleTag.
     * @param {TagRuleTagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tagRuleTag = await prisma.tagRuleTag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TagRuleTagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TagRuleTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagCountArgs} args - Arguments to filter TagRuleTags to count.
     * @example
     * // Count the number of TagRuleTags
     * const count = await prisma.tagRuleTag.count({
     *   where: {
     *     // ... the filter for the TagRuleTags we want to count
     *   }
     * })
    **/
    count<T extends TagRuleTagCountArgs>(
      args?: Subset<T, TagRuleTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagRuleTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagRuleTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagRuleTagAggregateArgs>(args: Subset<T, TagRuleTagAggregateArgs>): Prisma.PrismaPromise<GetTagRuleTagAggregateType<T>>

    /**
     * Group by TagRuleTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagRuleTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagRuleTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagRuleTagGroupByArgs['orderBy'] }
        : { orderBy?: TagRuleTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagRuleTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagRuleTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagRuleTag model
   */
  readonly fields: TagRuleTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagRuleTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagRuleTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tagRule<T extends TagRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagRuleDefaultArgs<ExtArgs>>): Prisma__TagRuleClient<$Result.GetResult<Prisma.$TagRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagRuleTag model
   */ 
  interface TagRuleTagFieldRefs {
    readonly id: FieldRef<"TagRuleTag", 'String'>
    readonly tagRuleId: FieldRef<"TagRuleTag", 'String'>
    readonly tagId: FieldRef<"TagRuleTag", 'String'>
    readonly createdAt: FieldRef<"TagRuleTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TagRuleTag findUnique
   */
  export type TagRuleTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * Filter, which TagRuleTag to fetch.
     */
    where: TagRuleTagWhereUniqueInput
  }

  /**
   * TagRuleTag findUniqueOrThrow
   */
  export type TagRuleTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * Filter, which TagRuleTag to fetch.
     */
    where: TagRuleTagWhereUniqueInput
  }

  /**
   * TagRuleTag findFirst
   */
  export type TagRuleTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * Filter, which TagRuleTag to fetch.
     */
    where?: TagRuleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRuleTags to fetch.
     */
    orderBy?: TagRuleTagOrderByWithRelationInput | TagRuleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagRuleTags.
     */
    cursor?: TagRuleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRuleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRuleTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagRuleTags.
     */
    distinct?: TagRuleTagScalarFieldEnum | TagRuleTagScalarFieldEnum[]
  }

  /**
   * TagRuleTag findFirstOrThrow
   */
  export type TagRuleTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * Filter, which TagRuleTag to fetch.
     */
    where?: TagRuleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRuleTags to fetch.
     */
    orderBy?: TagRuleTagOrderByWithRelationInput | TagRuleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagRuleTags.
     */
    cursor?: TagRuleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRuleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRuleTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagRuleTags.
     */
    distinct?: TagRuleTagScalarFieldEnum | TagRuleTagScalarFieldEnum[]
  }

  /**
   * TagRuleTag findMany
   */
  export type TagRuleTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * Filter, which TagRuleTags to fetch.
     */
    where?: TagRuleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagRuleTags to fetch.
     */
    orderBy?: TagRuleTagOrderByWithRelationInput | TagRuleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagRuleTags.
     */
    cursor?: TagRuleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagRuleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagRuleTags.
     */
    skip?: number
    distinct?: TagRuleTagScalarFieldEnum | TagRuleTagScalarFieldEnum[]
  }

  /**
   * TagRuleTag create
   */
  export type TagRuleTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TagRuleTag.
     */
    data: XOR<TagRuleTagCreateInput, TagRuleTagUncheckedCreateInput>
  }

  /**
   * TagRuleTag createMany
   */
  export type TagRuleTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagRuleTags.
     */
    data: TagRuleTagCreateManyInput | TagRuleTagCreateManyInput[]
  }

  /**
   * TagRuleTag update
   */
  export type TagRuleTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TagRuleTag.
     */
    data: XOR<TagRuleTagUpdateInput, TagRuleTagUncheckedUpdateInput>
    /**
     * Choose, which TagRuleTag to update.
     */
    where: TagRuleTagWhereUniqueInput
  }

  /**
   * TagRuleTag updateMany
   */
  export type TagRuleTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagRuleTags.
     */
    data: XOR<TagRuleTagUpdateManyMutationInput, TagRuleTagUncheckedUpdateManyInput>
    /**
     * Filter which TagRuleTags to update
     */
    where?: TagRuleTagWhereInput
  }

  /**
   * TagRuleTag upsert
   */
  export type TagRuleTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TagRuleTag to update in case it exists.
     */
    where: TagRuleTagWhereUniqueInput
    /**
     * In case the TagRuleTag found by the `where` argument doesn't exist, create a new TagRuleTag with this data.
     */
    create: XOR<TagRuleTagCreateInput, TagRuleTagUncheckedCreateInput>
    /**
     * In case the TagRuleTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagRuleTagUpdateInput, TagRuleTagUncheckedUpdateInput>
  }

  /**
   * TagRuleTag delete
   */
  export type TagRuleTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
    /**
     * Filter which TagRuleTag to delete.
     */
    where: TagRuleTagWhereUniqueInput
  }

  /**
   * TagRuleTag deleteMany
   */
  export type TagRuleTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagRuleTags to delete
     */
    where?: TagRuleTagWhereInput
  }

  /**
   * TagRuleTag findRaw
   */
  export type TagRuleTagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TagRuleTag aggregateRaw
   */
  export type TagRuleTagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TagRuleTag without action
   */
  export type TagRuleTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagRuleTag
     */
    select?: TagRuleTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagRuleTagInclude<ExtArgs> | null
  }


  /**
   * Model TransactionTag
   */

  export type AggregateTransactionTag = {
    _count: TransactionTagCountAggregateOutputType | null
    _min: TransactionTagMinAggregateOutputType | null
    _max: TransactionTagMaxAggregateOutputType | null
  }

  export type TransactionTagMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type TransactionTagMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type TransactionTagCountAggregateOutputType = {
    id: number
    transactionId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type TransactionTagMinAggregateInputType = {
    id?: true
    transactionId?: true
    tagId?: true
    createdAt?: true
  }

  export type TransactionTagMaxAggregateInputType = {
    id?: true
    transactionId?: true
    tagId?: true
    createdAt?: true
  }

  export type TransactionTagCountAggregateInputType = {
    id?: true
    transactionId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionTag to aggregate.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionTags
    **/
    _count?: true | TransactionTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionTagMaxAggregateInputType
  }

  export type GetTransactionTagAggregateType<T extends TransactionTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionTag[P]>
      : GetScalarType<T[P], AggregateTransactionTag[P]>
  }




  export type TransactionTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionTagWhereInput
    orderBy?: TransactionTagOrderByWithAggregationInput | TransactionTagOrderByWithAggregationInput[]
    by: TransactionTagScalarFieldEnum[] | TransactionTagScalarFieldEnum
    having?: TransactionTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionTagCountAggregateInputType | true
    _min?: TransactionTagMinAggregateInputType
    _max?: TransactionTagMaxAggregateInputType
  }

  export type TransactionTagGroupByOutputType = {
    id: string
    transactionId: string
    tagId: string
    createdAt: Date
    _count: TransactionTagCountAggregateOutputType | null
    _min: TransactionTagMinAggregateOutputType | null
    _max: TransactionTagMaxAggregateOutputType | null
  }

  type GetTransactionTagGroupByPayload<T extends TransactionTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionTagGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionTagGroupByOutputType[P]>
        }
      >
    >


  export type TransactionTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tagId?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionTag"]>


  export type TransactionTagSelectScalar = {
    id?: boolean
    transactionId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type TransactionTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TransactionTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionTag"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["transactionTag"]>
    composites: {}
  }

  type TransactionTagGetPayload<S extends boolean | null | undefined | TransactionTagDefaultArgs> = $Result.GetResult<Prisma.$TransactionTagPayload, S>

  type TransactionTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionTagCountAggregateInputType | true
    }

  export interface TransactionTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionTag'], meta: { name: 'TransactionTag' } }
    /**
     * Find zero or one TransactionTag that matches the filter.
     * @param {TransactionTagFindUniqueArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionTagFindUniqueArgs>(args: SelectSubset<T, TransactionTagFindUniqueArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransactionTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionTagFindUniqueOrThrowArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransactionTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagFindFirstArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionTagFindFirstArgs>(args?: SelectSubset<T, TransactionTagFindFirstArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransactionTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagFindFirstOrThrowArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransactionTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionTags
     * const transactionTags = await prisma.transactionTag.findMany()
     * 
     * // Get first 10 TransactionTags
     * const transactionTags = await prisma.transactionTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionTagWithIdOnly = await prisma.transactionTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionTagFindManyArgs>(args?: SelectSubset<T, TransactionTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransactionTag.
     * @param {TransactionTagCreateArgs} args - Arguments to create a TransactionTag.
     * @example
     * // Create one TransactionTag
     * const TransactionTag = await prisma.transactionTag.create({
     *   data: {
     *     // ... data to create a TransactionTag
     *   }
     * })
     * 
     */
    create<T extends TransactionTagCreateArgs>(args: SelectSubset<T, TransactionTagCreateArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransactionTags.
     * @param {TransactionTagCreateManyArgs} args - Arguments to create many TransactionTags.
     * @example
     * // Create many TransactionTags
     * const transactionTag = await prisma.transactionTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionTagCreateManyArgs>(args?: SelectSubset<T, TransactionTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionTag.
     * @param {TransactionTagDeleteArgs} args - Arguments to delete one TransactionTag.
     * @example
     * // Delete one TransactionTag
     * const TransactionTag = await prisma.transactionTag.delete({
     *   where: {
     *     // ... filter to delete one TransactionTag
     *   }
     * })
     * 
     */
    delete<T extends TransactionTagDeleteArgs>(args: SelectSubset<T, TransactionTagDeleteArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransactionTag.
     * @param {TransactionTagUpdateArgs} args - Arguments to update one TransactionTag.
     * @example
     * // Update one TransactionTag
     * const transactionTag = await prisma.transactionTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionTagUpdateArgs>(args: SelectSubset<T, TransactionTagUpdateArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransactionTags.
     * @param {TransactionTagDeleteManyArgs} args - Arguments to filter TransactionTags to delete.
     * @example
     * // Delete a few TransactionTags
     * const { count } = await prisma.transactionTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionTagDeleteManyArgs>(args?: SelectSubset<T, TransactionTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionTags
     * const transactionTag = await prisma.transactionTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionTagUpdateManyArgs>(args: SelectSubset<T, TransactionTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionTag.
     * @param {TransactionTagUpsertArgs} args - Arguments to update or create a TransactionTag.
     * @example
     * // Update or create a TransactionTag
     * const transactionTag = await prisma.transactionTag.upsert({
     *   create: {
     *     // ... data to create a TransactionTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionTag we want to update
     *   }
     * })
     */
    upsert<T extends TransactionTagUpsertArgs>(args: SelectSubset<T, TransactionTagUpsertArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TransactionTags that matches the filter.
     * @param {TransactionTagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const transactionTag = await prisma.transactionTag.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TransactionTagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TransactionTag.
     * @param {TransactionTagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const transactionTag = await prisma.transactionTag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TransactionTagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TransactionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagCountArgs} args - Arguments to filter TransactionTags to count.
     * @example
     * // Count the number of TransactionTags
     * const count = await prisma.transactionTag.count({
     *   where: {
     *     // ... the filter for the TransactionTags we want to count
     *   }
     * })
    **/
    count<T extends TransactionTagCountArgs>(
      args?: Subset<T, TransactionTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionTagAggregateArgs>(args: Subset<T, TransactionTagAggregateArgs>): Prisma.PrismaPromise<GetTransactionTagAggregateType<T>>

    /**
     * Group by TransactionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionTagGroupByArgs['orderBy'] }
        : { orderBy?: TransactionTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionTag model
   */
  readonly fields: TransactionTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionTag model
   */ 
  interface TransactionTagFieldRefs {
    readonly id: FieldRef<"TransactionTag", 'String'>
    readonly transactionId: FieldRef<"TransactionTag", 'String'>
    readonly tagId: FieldRef<"TransactionTag", 'String'>
    readonly createdAt: FieldRef<"TransactionTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionTag findUnique
   */
  export type TransactionTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag findUniqueOrThrow
   */
  export type TransactionTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag findFirst
   */
  export type TransactionTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionTags.
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionTags.
     */
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * TransactionTag findFirstOrThrow
   */
  export type TransactionTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionTags.
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionTags.
     */
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * TransactionTag findMany
   */
  export type TransactionTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTags to fetch.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionTags.
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * TransactionTag create
   */
  export type TransactionTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionTag.
     */
    data: XOR<TransactionTagCreateInput, TransactionTagUncheckedCreateInput>
  }

  /**
   * TransactionTag createMany
   */
  export type TransactionTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionTags.
     */
    data: TransactionTagCreateManyInput | TransactionTagCreateManyInput[]
  }

  /**
   * TransactionTag update
   */
  export type TransactionTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionTag.
     */
    data: XOR<TransactionTagUpdateInput, TransactionTagUncheckedUpdateInput>
    /**
     * Choose, which TransactionTag to update.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag updateMany
   */
  export type TransactionTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionTags.
     */
    data: XOR<TransactionTagUpdateManyMutationInput, TransactionTagUncheckedUpdateManyInput>
    /**
     * Filter which TransactionTags to update
     */
    where?: TransactionTagWhereInput
  }

  /**
   * TransactionTag upsert
   */
  export type TransactionTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionTag to update in case it exists.
     */
    where: TransactionTagWhereUniqueInput
    /**
     * In case the TransactionTag found by the `where` argument doesn't exist, create a new TransactionTag with this data.
     */
    create: XOR<TransactionTagCreateInput, TransactionTagUncheckedCreateInput>
    /**
     * In case the TransactionTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionTagUpdateInput, TransactionTagUncheckedUpdateInput>
  }

  /**
   * TransactionTag delete
   */
  export type TransactionTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter which TransactionTag to delete.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag deleteMany
   */
  export type TransactionTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionTags to delete
     */
    where?: TransactionTagWhereInput
  }

  /**
   * TransactionTag findRaw
   */
  export type TransactionTagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TransactionTag aggregateRaw
   */
  export type TransactionTagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TransactionTag without action
   */
  export type TransactionTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
  }


  /**
   * Model IncomeStreamTag
   */

  export type AggregateIncomeStreamTag = {
    _count: IncomeStreamTagCountAggregateOutputType | null
    _min: IncomeStreamTagMinAggregateOutputType | null
    _max: IncomeStreamTagMaxAggregateOutputType | null
  }

  export type IncomeStreamTagMinAggregateOutputType = {
    id: string | null
    incomeStreamId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type IncomeStreamTagMaxAggregateOutputType = {
    id: string | null
    incomeStreamId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type IncomeStreamTagCountAggregateOutputType = {
    id: number
    incomeStreamId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type IncomeStreamTagMinAggregateInputType = {
    id?: true
    incomeStreamId?: true
    tagId?: true
    createdAt?: true
  }

  export type IncomeStreamTagMaxAggregateInputType = {
    id?: true
    incomeStreamId?: true
    tagId?: true
    createdAt?: true
  }

  export type IncomeStreamTagCountAggregateInputType = {
    id?: true
    incomeStreamId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type IncomeStreamTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeStreamTag to aggregate.
     */
    where?: IncomeStreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreamTags to fetch.
     */
    orderBy?: IncomeStreamTagOrderByWithRelationInput | IncomeStreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeStreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreamTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomeStreamTags
    **/
    _count?: true | IncomeStreamTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeStreamTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeStreamTagMaxAggregateInputType
  }

  export type GetIncomeStreamTagAggregateType<T extends IncomeStreamTagAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomeStreamTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomeStreamTag[P]>
      : GetScalarType<T[P], AggregateIncomeStreamTag[P]>
  }




  export type IncomeStreamTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeStreamTagWhereInput
    orderBy?: IncomeStreamTagOrderByWithAggregationInput | IncomeStreamTagOrderByWithAggregationInput[]
    by: IncomeStreamTagScalarFieldEnum[] | IncomeStreamTagScalarFieldEnum
    having?: IncomeStreamTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeStreamTagCountAggregateInputType | true
    _min?: IncomeStreamTagMinAggregateInputType
    _max?: IncomeStreamTagMaxAggregateInputType
  }

  export type IncomeStreamTagGroupByOutputType = {
    id: string
    incomeStreamId: string
    tagId: string
    createdAt: Date
    _count: IncomeStreamTagCountAggregateOutputType | null
    _min: IncomeStreamTagMinAggregateOutputType | null
    _max: IncomeStreamTagMaxAggregateOutputType | null
  }

  type GetIncomeStreamTagGroupByPayload<T extends IncomeStreamTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeStreamTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeStreamTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeStreamTagGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeStreamTagGroupByOutputType[P]>
        }
      >
    >


  export type IncomeStreamTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incomeStreamId?: boolean
    tagId?: boolean
    createdAt?: boolean
    incomeStream?: boolean | IncomeStreamDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeStreamTag"]>


  export type IncomeStreamTagSelectScalar = {
    id?: boolean
    incomeStreamId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type IncomeStreamTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incomeStream?: boolean | IncomeStreamDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $IncomeStreamTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncomeStreamTag"
    objects: {
      incomeStream: Prisma.$IncomeStreamPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incomeStreamId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["incomeStreamTag"]>
    composites: {}
  }

  type IncomeStreamTagGetPayload<S extends boolean | null | undefined | IncomeStreamTagDefaultArgs> = $Result.GetResult<Prisma.$IncomeStreamTagPayload, S>

  type IncomeStreamTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncomeStreamTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncomeStreamTagCountAggregateInputType | true
    }

  export interface IncomeStreamTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncomeStreamTag'], meta: { name: 'IncomeStreamTag' } }
    /**
     * Find zero or one IncomeStreamTag that matches the filter.
     * @param {IncomeStreamTagFindUniqueArgs} args - Arguments to find a IncomeStreamTag
     * @example
     * // Get one IncomeStreamTag
     * const incomeStreamTag = await prisma.incomeStreamTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeStreamTagFindUniqueArgs>(args: SelectSubset<T, IncomeStreamTagFindUniqueArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncomeStreamTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncomeStreamTagFindUniqueOrThrowArgs} args - Arguments to find a IncomeStreamTag
     * @example
     * // Get one IncomeStreamTag
     * const incomeStreamTag = await prisma.incomeStreamTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeStreamTagFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeStreamTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncomeStreamTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagFindFirstArgs} args - Arguments to find a IncomeStreamTag
     * @example
     * // Get one IncomeStreamTag
     * const incomeStreamTag = await prisma.incomeStreamTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeStreamTagFindFirstArgs>(args?: SelectSubset<T, IncomeStreamTagFindFirstArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncomeStreamTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagFindFirstOrThrowArgs} args - Arguments to find a IncomeStreamTag
     * @example
     * // Get one IncomeStreamTag
     * const incomeStreamTag = await prisma.incomeStreamTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeStreamTagFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeStreamTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncomeStreamTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomeStreamTags
     * const incomeStreamTags = await prisma.incomeStreamTag.findMany()
     * 
     * // Get first 10 IncomeStreamTags
     * const incomeStreamTags = await prisma.incomeStreamTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeStreamTagWithIdOnly = await prisma.incomeStreamTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeStreamTagFindManyArgs>(args?: SelectSubset<T, IncomeStreamTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncomeStreamTag.
     * @param {IncomeStreamTagCreateArgs} args - Arguments to create a IncomeStreamTag.
     * @example
     * // Create one IncomeStreamTag
     * const IncomeStreamTag = await prisma.incomeStreamTag.create({
     *   data: {
     *     // ... data to create a IncomeStreamTag
     *   }
     * })
     * 
     */
    create<T extends IncomeStreamTagCreateArgs>(args: SelectSubset<T, IncomeStreamTagCreateArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncomeStreamTags.
     * @param {IncomeStreamTagCreateManyArgs} args - Arguments to create many IncomeStreamTags.
     * @example
     * // Create many IncomeStreamTags
     * const incomeStreamTag = await prisma.incomeStreamTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeStreamTagCreateManyArgs>(args?: SelectSubset<T, IncomeStreamTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomeStreamTag.
     * @param {IncomeStreamTagDeleteArgs} args - Arguments to delete one IncomeStreamTag.
     * @example
     * // Delete one IncomeStreamTag
     * const IncomeStreamTag = await prisma.incomeStreamTag.delete({
     *   where: {
     *     // ... filter to delete one IncomeStreamTag
     *   }
     * })
     * 
     */
    delete<T extends IncomeStreamTagDeleteArgs>(args: SelectSubset<T, IncomeStreamTagDeleteArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncomeStreamTag.
     * @param {IncomeStreamTagUpdateArgs} args - Arguments to update one IncomeStreamTag.
     * @example
     * // Update one IncomeStreamTag
     * const incomeStreamTag = await prisma.incomeStreamTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeStreamTagUpdateArgs>(args: SelectSubset<T, IncomeStreamTagUpdateArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncomeStreamTags.
     * @param {IncomeStreamTagDeleteManyArgs} args - Arguments to filter IncomeStreamTags to delete.
     * @example
     * // Delete a few IncomeStreamTags
     * const { count } = await prisma.incomeStreamTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeStreamTagDeleteManyArgs>(args?: SelectSubset<T, IncomeStreamTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeStreamTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomeStreamTags
     * const incomeStreamTag = await prisma.incomeStreamTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeStreamTagUpdateManyArgs>(args: SelectSubset<T, IncomeStreamTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomeStreamTag.
     * @param {IncomeStreamTagUpsertArgs} args - Arguments to update or create a IncomeStreamTag.
     * @example
     * // Update or create a IncomeStreamTag
     * const incomeStreamTag = await prisma.incomeStreamTag.upsert({
     *   create: {
     *     // ... data to create a IncomeStreamTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomeStreamTag we want to update
     *   }
     * })
     */
    upsert<T extends IncomeStreamTagUpsertArgs>(args: SelectSubset<T, IncomeStreamTagUpsertArgs<ExtArgs>>): Prisma__IncomeStreamTagClient<$Result.GetResult<Prisma.$IncomeStreamTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more IncomeStreamTags that matches the filter.
     * @param {IncomeStreamTagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const incomeStreamTag = await prisma.incomeStreamTag.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: IncomeStreamTagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IncomeStreamTag.
     * @param {IncomeStreamTagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const incomeStreamTag = await prisma.incomeStreamTag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IncomeStreamTagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IncomeStreamTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagCountArgs} args - Arguments to filter IncomeStreamTags to count.
     * @example
     * // Count the number of IncomeStreamTags
     * const count = await prisma.incomeStreamTag.count({
     *   where: {
     *     // ... the filter for the IncomeStreamTags we want to count
     *   }
     * })
    **/
    count<T extends IncomeStreamTagCountArgs>(
      args?: Subset<T, IncomeStreamTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeStreamTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomeStreamTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeStreamTagAggregateArgs>(args: Subset<T, IncomeStreamTagAggregateArgs>): Prisma.PrismaPromise<GetIncomeStreamTagAggregateType<T>>

    /**
     * Group by IncomeStreamTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeStreamTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeStreamTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeStreamTagGroupByArgs['orderBy'] }
        : { orderBy?: IncomeStreamTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeStreamTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeStreamTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncomeStreamTag model
   */
  readonly fields: IncomeStreamTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomeStreamTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeStreamTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incomeStream<T extends IncomeStreamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncomeStreamDefaultArgs<ExtArgs>>): Prisma__IncomeStreamClient<$Result.GetResult<Prisma.$IncomeStreamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncomeStreamTag model
   */ 
  interface IncomeStreamTagFieldRefs {
    readonly id: FieldRef<"IncomeStreamTag", 'String'>
    readonly incomeStreamId: FieldRef<"IncomeStreamTag", 'String'>
    readonly tagId: FieldRef<"IncomeStreamTag", 'String'>
    readonly createdAt: FieldRef<"IncomeStreamTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncomeStreamTag findUnique
   */
  export type IncomeStreamTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStreamTag to fetch.
     */
    where: IncomeStreamTagWhereUniqueInput
  }

  /**
   * IncomeStreamTag findUniqueOrThrow
   */
  export type IncomeStreamTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStreamTag to fetch.
     */
    where: IncomeStreamTagWhereUniqueInput
  }

  /**
   * IncomeStreamTag findFirst
   */
  export type IncomeStreamTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStreamTag to fetch.
     */
    where?: IncomeStreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreamTags to fetch.
     */
    orderBy?: IncomeStreamTagOrderByWithRelationInput | IncomeStreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeStreamTags.
     */
    cursor?: IncomeStreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreamTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeStreamTags.
     */
    distinct?: IncomeStreamTagScalarFieldEnum | IncomeStreamTagScalarFieldEnum[]
  }

  /**
   * IncomeStreamTag findFirstOrThrow
   */
  export type IncomeStreamTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStreamTag to fetch.
     */
    where?: IncomeStreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreamTags to fetch.
     */
    orderBy?: IncomeStreamTagOrderByWithRelationInput | IncomeStreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeStreamTags.
     */
    cursor?: IncomeStreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreamTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeStreamTags.
     */
    distinct?: IncomeStreamTagScalarFieldEnum | IncomeStreamTagScalarFieldEnum[]
  }

  /**
   * IncomeStreamTag findMany
   */
  export type IncomeStreamTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * Filter, which IncomeStreamTags to fetch.
     */
    where?: IncomeStreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeStreamTags to fetch.
     */
    orderBy?: IncomeStreamTagOrderByWithRelationInput | IncomeStreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomeStreamTags.
     */
    cursor?: IncomeStreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeStreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeStreamTags.
     */
    skip?: number
    distinct?: IncomeStreamTagScalarFieldEnum | IncomeStreamTagScalarFieldEnum[]
  }

  /**
   * IncomeStreamTag create
   */
  export type IncomeStreamTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * The data needed to create a IncomeStreamTag.
     */
    data: XOR<IncomeStreamTagCreateInput, IncomeStreamTagUncheckedCreateInput>
  }

  /**
   * IncomeStreamTag createMany
   */
  export type IncomeStreamTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncomeStreamTags.
     */
    data: IncomeStreamTagCreateManyInput | IncomeStreamTagCreateManyInput[]
  }

  /**
   * IncomeStreamTag update
   */
  export type IncomeStreamTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * The data needed to update a IncomeStreamTag.
     */
    data: XOR<IncomeStreamTagUpdateInput, IncomeStreamTagUncheckedUpdateInput>
    /**
     * Choose, which IncomeStreamTag to update.
     */
    where: IncomeStreamTagWhereUniqueInput
  }

  /**
   * IncomeStreamTag updateMany
   */
  export type IncomeStreamTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncomeStreamTags.
     */
    data: XOR<IncomeStreamTagUpdateManyMutationInput, IncomeStreamTagUncheckedUpdateManyInput>
    /**
     * Filter which IncomeStreamTags to update
     */
    where?: IncomeStreamTagWhereInput
  }

  /**
   * IncomeStreamTag upsert
   */
  export type IncomeStreamTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * The filter to search for the IncomeStreamTag to update in case it exists.
     */
    where: IncomeStreamTagWhereUniqueInput
    /**
     * In case the IncomeStreamTag found by the `where` argument doesn't exist, create a new IncomeStreamTag with this data.
     */
    create: XOR<IncomeStreamTagCreateInput, IncomeStreamTagUncheckedCreateInput>
    /**
     * In case the IncomeStreamTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeStreamTagUpdateInput, IncomeStreamTagUncheckedUpdateInput>
  }

  /**
   * IncomeStreamTag delete
   */
  export type IncomeStreamTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
    /**
     * Filter which IncomeStreamTag to delete.
     */
    where: IncomeStreamTagWhereUniqueInput
  }

  /**
   * IncomeStreamTag deleteMany
   */
  export type IncomeStreamTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeStreamTags to delete
     */
    where?: IncomeStreamTagWhereInput
  }

  /**
   * IncomeStreamTag findRaw
   */
  export type IncomeStreamTagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IncomeStreamTag aggregateRaw
   */
  export type IncomeStreamTagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IncomeStreamTag without action
   */
  export type IncomeStreamTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeStreamTag
     */
    select?: IncomeStreamTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeStreamTagInclude<ExtArgs> | null
  }


  /**
   * Model DebtTag
   */

  export type AggregateDebtTag = {
    _count: DebtTagCountAggregateOutputType | null
    _min: DebtTagMinAggregateOutputType | null
    _max: DebtTagMaxAggregateOutputType | null
  }

  export type DebtTagMinAggregateOutputType = {
    id: string | null
    debtId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type DebtTagMaxAggregateOutputType = {
    id: string | null
    debtId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type DebtTagCountAggregateOutputType = {
    id: number
    debtId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type DebtTagMinAggregateInputType = {
    id?: true
    debtId?: true
    tagId?: true
    createdAt?: true
  }

  export type DebtTagMaxAggregateInputType = {
    id?: true
    debtId?: true
    tagId?: true
    createdAt?: true
  }

  export type DebtTagCountAggregateInputType = {
    id?: true
    debtId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type DebtTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtTag to aggregate.
     */
    where?: DebtTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtTags to fetch.
     */
    orderBy?: DebtTagOrderByWithRelationInput | DebtTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtTags
    **/
    _count?: true | DebtTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtTagMaxAggregateInputType
  }

  export type GetDebtTagAggregateType<T extends DebtTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtTag[P]>
      : GetScalarType<T[P], AggregateDebtTag[P]>
  }




  export type DebtTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtTagWhereInput
    orderBy?: DebtTagOrderByWithAggregationInput | DebtTagOrderByWithAggregationInput[]
    by: DebtTagScalarFieldEnum[] | DebtTagScalarFieldEnum
    having?: DebtTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtTagCountAggregateInputType | true
    _min?: DebtTagMinAggregateInputType
    _max?: DebtTagMaxAggregateInputType
  }

  export type DebtTagGroupByOutputType = {
    id: string
    debtId: string
    tagId: string
    createdAt: Date
    _count: DebtTagCountAggregateOutputType | null
    _min: DebtTagMinAggregateOutputType | null
    _max: DebtTagMaxAggregateOutputType | null
  }

  type GetDebtTagGroupByPayload<T extends DebtTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtTagGroupByOutputType[P]>
            : GetScalarType<T[P], DebtTagGroupByOutputType[P]>
        }
      >
    >


  export type DebtTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtId?: boolean
    tagId?: boolean
    createdAt?: boolean
    debt?: boolean | DebtDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtTag"]>


  export type DebtTagSelectScalar = {
    id?: boolean
    debtId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type DebtTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debt?: boolean | DebtDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $DebtTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtTag"
    objects: {
      debt: Prisma.$DebtPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["debtTag"]>
    composites: {}
  }

  type DebtTagGetPayload<S extends boolean | null | undefined | DebtTagDefaultArgs> = $Result.GetResult<Prisma.$DebtTagPayload, S>

  type DebtTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DebtTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DebtTagCountAggregateInputType | true
    }

  export interface DebtTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtTag'], meta: { name: 'DebtTag' } }
    /**
     * Find zero or one DebtTag that matches the filter.
     * @param {DebtTagFindUniqueArgs} args - Arguments to find a DebtTag
     * @example
     * // Get one DebtTag
     * const debtTag = await prisma.debtTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtTagFindUniqueArgs>(args: SelectSubset<T, DebtTagFindUniqueArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DebtTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DebtTagFindUniqueOrThrowArgs} args - Arguments to find a DebtTag
     * @example
     * // Get one DebtTag
     * const debtTag = await prisma.debtTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DebtTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagFindFirstArgs} args - Arguments to find a DebtTag
     * @example
     * // Get one DebtTag
     * const debtTag = await prisma.debtTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtTagFindFirstArgs>(args?: SelectSubset<T, DebtTagFindFirstArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DebtTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagFindFirstOrThrowArgs} args - Arguments to find a DebtTag
     * @example
     * // Get one DebtTag
     * const debtTag = await prisma.debtTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DebtTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtTags
     * const debtTags = await prisma.debtTag.findMany()
     * 
     * // Get first 10 DebtTags
     * const debtTags = await prisma.debtTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtTagWithIdOnly = await prisma.debtTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtTagFindManyArgs>(args?: SelectSubset<T, DebtTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DebtTag.
     * @param {DebtTagCreateArgs} args - Arguments to create a DebtTag.
     * @example
     * // Create one DebtTag
     * const DebtTag = await prisma.debtTag.create({
     *   data: {
     *     // ... data to create a DebtTag
     *   }
     * })
     * 
     */
    create<T extends DebtTagCreateArgs>(args: SelectSubset<T, DebtTagCreateArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DebtTags.
     * @param {DebtTagCreateManyArgs} args - Arguments to create many DebtTags.
     * @example
     * // Create many DebtTags
     * const debtTag = await prisma.debtTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtTagCreateManyArgs>(args?: SelectSubset<T, DebtTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DebtTag.
     * @param {DebtTagDeleteArgs} args - Arguments to delete one DebtTag.
     * @example
     * // Delete one DebtTag
     * const DebtTag = await prisma.debtTag.delete({
     *   where: {
     *     // ... filter to delete one DebtTag
     *   }
     * })
     * 
     */
    delete<T extends DebtTagDeleteArgs>(args: SelectSubset<T, DebtTagDeleteArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DebtTag.
     * @param {DebtTagUpdateArgs} args - Arguments to update one DebtTag.
     * @example
     * // Update one DebtTag
     * const debtTag = await prisma.debtTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtTagUpdateArgs>(args: SelectSubset<T, DebtTagUpdateArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DebtTags.
     * @param {DebtTagDeleteManyArgs} args - Arguments to filter DebtTags to delete.
     * @example
     * // Delete a few DebtTags
     * const { count } = await prisma.debtTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtTagDeleteManyArgs>(args?: SelectSubset<T, DebtTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtTags
     * const debtTag = await prisma.debtTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtTagUpdateManyArgs>(args: SelectSubset<T, DebtTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DebtTag.
     * @param {DebtTagUpsertArgs} args - Arguments to update or create a DebtTag.
     * @example
     * // Update or create a DebtTag
     * const debtTag = await prisma.debtTag.upsert({
     *   create: {
     *     // ... data to create a DebtTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtTag we want to update
     *   }
     * })
     */
    upsert<T extends DebtTagUpsertArgs>(args: SelectSubset<T, DebtTagUpsertArgs<ExtArgs>>): Prisma__DebtTagClient<$Result.GetResult<Prisma.$DebtTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DebtTags that matches the filter.
     * @param {DebtTagFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const debtTag = await prisma.debtTag.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DebtTagFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DebtTag.
     * @param {DebtTagAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const debtTag = await prisma.debtTag.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DebtTagAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DebtTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagCountArgs} args - Arguments to filter DebtTags to count.
     * @example
     * // Count the number of DebtTags
     * const count = await prisma.debtTag.count({
     *   where: {
     *     // ... the filter for the DebtTags we want to count
     *   }
     * })
    **/
    count<T extends DebtTagCountArgs>(
      args?: Subset<T, DebtTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtTagAggregateArgs>(args: Subset<T, DebtTagAggregateArgs>): Prisma.PrismaPromise<GetDebtTagAggregateType<T>>

    /**
     * Group by DebtTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtTagGroupByArgs['orderBy'] }
        : { orderBy?: DebtTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtTag model
   */
  readonly fields: DebtTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debt<T extends DebtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtDefaultArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtTag model
   */ 
  interface DebtTagFieldRefs {
    readonly id: FieldRef<"DebtTag", 'String'>
    readonly debtId: FieldRef<"DebtTag", 'String'>
    readonly tagId: FieldRef<"DebtTag", 'String'>
    readonly createdAt: FieldRef<"DebtTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DebtTag findUnique
   */
  export type DebtTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * Filter, which DebtTag to fetch.
     */
    where: DebtTagWhereUniqueInput
  }

  /**
   * DebtTag findUniqueOrThrow
   */
  export type DebtTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * Filter, which DebtTag to fetch.
     */
    where: DebtTagWhereUniqueInput
  }

  /**
   * DebtTag findFirst
   */
  export type DebtTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * Filter, which DebtTag to fetch.
     */
    where?: DebtTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtTags to fetch.
     */
    orderBy?: DebtTagOrderByWithRelationInput | DebtTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtTags.
     */
    cursor?: DebtTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtTags.
     */
    distinct?: DebtTagScalarFieldEnum | DebtTagScalarFieldEnum[]
  }

  /**
   * DebtTag findFirstOrThrow
   */
  export type DebtTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * Filter, which DebtTag to fetch.
     */
    where?: DebtTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtTags to fetch.
     */
    orderBy?: DebtTagOrderByWithRelationInput | DebtTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtTags.
     */
    cursor?: DebtTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtTags.
     */
    distinct?: DebtTagScalarFieldEnum | DebtTagScalarFieldEnum[]
  }

  /**
   * DebtTag findMany
   */
  export type DebtTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * Filter, which DebtTags to fetch.
     */
    where?: DebtTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtTags to fetch.
     */
    orderBy?: DebtTagOrderByWithRelationInput | DebtTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtTags.
     */
    cursor?: DebtTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtTags.
     */
    skip?: number
    distinct?: DebtTagScalarFieldEnum | DebtTagScalarFieldEnum[]
  }

  /**
   * DebtTag create
   */
  export type DebtTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtTag.
     */
    data: XOR<DebtTagCreateInput, DebtTagUncheckedCreateInput>
  }

  /**
   * DebtTag createMany
   */
  export type DebtTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtTags.
     */
    data: DebtTagCreateManyInput | DebtTagCreateManyInput[]
  }

  /**
   * DebtTag update
   */
  export type DebtTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtTag.
     */
    data: XOR<DebtTagUpdateInput, DebtTagUncheckedUpdateInput>
    /**
     * Choose, which DebtTag to update.
     */
    where: DebtTagWhereUniqueInput
  }

  /**
   * DebtTag updateMany
   */
  export type DebtTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtTags.
     */
    data: XOR<DebtTagUpdateManyMutationInput, DebtTagUncheckedUpdateManyInput>
    /**
     * Filter which DebtTags to update
     */
    where?: DebtTagWhereInput
  }

  /**
   * DebtTag upsert
   */
  export type DebtTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtTag to update in case it exists.
     */
    where: DebtTagWhereUniqueInput
    /**
     * In case the DebtTag found by the `where` argument doesn't exist, create a new DebtTag with this data.
     */
    create: XOR<DebtTagCreateInput, DebtTagUncheckedCreateInput>
    /**
     * In case the DebtTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtTagUpdateInput, DebtTagUncheckedUpdateInput>
  }

  /**
   * DebtTag delete
   */
  export type DebtTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
    /**
     * Filter which DebtTag to delete.
     */
    where: DebtTagWhereUniqueInput
  }

  /**
   * DebtTag deleteMany
   */
  export type DebtTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtTags to delete
     */
    where?: DebtTagWhereInput
  }

  /**
   * DebtTag findRaw
   */
  export type DebtTagFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DebtTag aggregateRaw
   */
  export type DebtTagAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DebtTag without action
   */
  export type DebtTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtTag
     */
    select?: DebtTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtTagInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    type: 'type',
    currency: 'currency',
    plaidItemId: 'plaidItemId',
    plaidAccountId: 'plaidAccountId',
    plaidMask: 'plaidMask',
    plaidType: 'plaidType',
    plaidSubtype: 'plaidSubtype',
    createdAt: 'createdAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    kind: 'kind',
    createdAt: 'createdAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    date: 'date',
    amountDollars: 'amountDollars',
    categoryId: 'categoryId',
    merchant: 'merchant',
    note: 'note',
    plaidTransactionId: 'plaidTransactionId',
    pending: 'pending',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TagRuleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    pattern: 'pattern',
    matchType: 'matchType',
    sourceField: 'sourceField',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagRuleScalarFieldEnum = (typeof TagRuleScalarFieldEnum)[keyof typeof TagRuleScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    amountDollars: 'amountDollars',
    period: 'period',
    categoryId: 'categoryId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    amountDollars: 'amountDollars',
    dueDayOfMonth: 'dueDayOfMonth',
    dueDate: 'dueDate',
    frequency: 'frequency',
    isEssential: 'isEssential',
    autopay: 'autopay',
    createdAt: 'createdAt'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    amountDollars: 'amountDollars',
    billingDayOfMonth: 'billingDayOfMonth',
    frequency: 'frequency',
    cancelable: 'cancelable',
    createdAt: 'createdAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const IncomeStreamScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    amountDollars: 'amountDollars',
    lastAmountDollars: 'lastAmountDollars',
    cadence: 'cadence',
    nextPayDate: 'nextPayDate',
    createdAt: 'createdAt'
  };

  export type IncomeStreamScalarFieldEnum = (typeof IncomeStreamScalarFieldEnum)[keyof typeof IncomeStreamScalarFieldEnum]


  export const DebtScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    principalDollars: 'principalDollars',
    aprBps: 'aprBps',
    minPaymentDollars: 'minPaymentDollars',
    estimatedMonthlyPaymentDollars: 'estimatedMonthlyPaymentDollars',
    dueDayOfMonth: 'dueDayOfMonth',
    estimatedPayoffDate: 'estimatedPayoffDate',
    createdAt: 'createdAt'
  };

  export type DebtScalarFieldEnum = (typeof DebtScalarFieldEnum)[keyof typeof DebtScalarFieldEnum]


  export const SavingsGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    targetDollars: 'targetDollars',
    currentDollars: 'currentDollars',
    ruleType: 'ruleType',
    ruleValueBpsOrDollars: 'ruleValueBpsOrDollars',
    priority: 'priority',
    createdAt: 'createdAt'
  };

  export type SavingsGoalScalarFieldEnum = (typeof SavingsGoalScalarFieldEnum)[keyof typeof SavingsGoalScalarFieldEnum]


  export const MandatorySavingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    monthsToSave: 'monthsToSave',
    targetDollars: 'targetDollars',
    currentDollars: 'currentDollars',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MandatorySavingsScalarFieldEnum = (typeof MandatorySavingsScalarFieldEnum)[keyof typeof MandatorySavingsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    entityType: 'entityType',
    entityId: 'entityId',
    milestonePct: 'milestonePct',
    message: 'message',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    strategy: 'strategy',
    horizonMonths: 'horizonMonths',
    startDate: 'startDate',
    rulesJson: 'rulesJson',
    summaryJson: 'summaryJson',
    warningsJson: 'warningsJson',
    createdAt: 'createdAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanItemScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    date: 'date',
    type: 'type',
    entityId: 'entityId',
    amountDollars: 'amountDollars',
    notes: 'notes',
    balanceSnapshotJson: 'balanceSnapshotJson',
    createdAt: 'createdAt'
  };

  export type PlanItemScalarFieldEnum = (typeof PlanItemScalarFieldEnum)[keyof typeof PlanItemScalarFieldEnum]


  export const DebtPaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    debtId: 'debtId',
    amountDollars: 'amountDollars',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt'
  };

  export type DebtPaymentScalarFieldEnum = (typeof DebtPaymentScalarFieldEnum)[keyof typeof DebtPaymentScalarFieldEnum]


  export const PlaidItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId',
    accessTokenEncrypted: 'accessTokenEncrypted',
    institutionId: 'institutionId',
    institutionName: 'institutionName',
    transactionsCursor: 'transactionsCursor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaidItemScalarFieldEnum = (typeof PlaidItemScalarFieldEnum)[keyof typeof PlaidItemScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagRuleTagScalarFieldEnum: {
    id: 'id',
    tagRuleId: 'tagRuleId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type TagRuleTagScalarFieldEnum = (typeof TagRuleTagScalarFieldEnum)[keyof typeof TagRuleTagScalarFieldEnum]


  export const TransactionTagScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type TransactionTagScalarFieldEnum = (typeof TransactionTagScalarFieldEnum)[keyof typeof TransactionTagScalarFieldEnum]


  export const IncomeStreamTagScalarFieldEnum: {
    id: 'id',
    incomeStreamId: 'incomeStreamId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type IncomeStreamTagScalarFieldEnum = (typeof IncomeStreamTagScalarFieldEnum)[keyof typeof IncomeStreamTagScalarFieldEnum]


  export const DebtTagScalarFieldEnum: {
    id: 'id',
    debtId: 'debtId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type DebtTagScalarFieldEnum = (typeof DebtTagScalarFieldEnum)[keyof typeof DebtTagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'CategoryKind'
   */
  export type EnumCategoryKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryKind'>
    


  /**
   * Reference to a field of type 'CategoryKind[]'
   */
  export type ListEnumCategoryKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryKind[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TagRuleMatchType'
   */
  export type EnumTagRuleMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagRuleMatchType'>
    


  /**
   * Reference to a field of type 'TagRuleMatchType[]'
   */
  export type ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagRuleMatchType[]'>
    


  /**
   * Reference to a field of type 'TagRuleSourceField'
   */
  export type EnumTagRuleSourceFieldFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagRuleSourceField'>
    


  /**
   * Reference to a field of type 'TagRuleSourceField[]'
   */
  export type ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagRuleSourceField[]'>
    


  /**
   * Reference to a field of type 'BudgetPeriod'
   */
  export type EnumBudgetPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetPeriod'>
    


  /**
   * Reference to a field of type 'BudgetPeriod[]'
   */
  export type ListEnumBudgetPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetPeriod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BillFrequency'
   */
  export type EnumBillFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillFrequency'>
    


  /**
   * Reference to a field of type 'BillFrequency[]'
   */
  export type ListEnumBillFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillFrequency[]'>
    


  /**
   * Reference to a field of type 'SubscriptionFrequency'
   */
  export type EnumSubscriptionFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionFrequency'>
    


  /**
   * Reference to a field of type 'SubscriptionFrequency[]'
   */
  export type ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionFrequency[]'>
    


  /**
   * Reference to a field of type 'IncomeCadence'
   */
  export type EnumIncomeCadenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeCadence'>
    


  /**
   * Reference to a field of type 'IncomeCadence[]'
   */
  export type ListEnumIncomeCadenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeCadence[]'>
    


  /**
   * Reference to a field of type 'SavingsRuleType'
   */
  export type EnumSavingsRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SavingsRuleType'>
    


  /**
   * Reference to a field of type 'SavingsRuleType[]'
   */
  export type ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SavingsRuleType[]'>
    


  /**
   * Reference to a field of type 'PlanStrategy'
   */
  export type EnumPlanStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanStrategy'>
    


  /**
   * Reference to a field of type 'PlanStrategy[]'
   */
  export type ListEnumPlanStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanStrategy[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PlanItemType'
   */
  export type EnumPlanItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanItemType'>
    


  /**
   * Reference to a field of type 'PlanItemType[]'
   */
  export type ListEnumPlanItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanItemType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    categories?: CategoryListRelationFilter
    transactions?: TransactionListRelationFilter
    tags?: TagListRelationFilter
    bills?: BillListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    incomeStreams?: IncomeStreamListRelationFilter
    debts?: DebtListRelationFilter
    debtPayments?: DebtPaymentListRelationFilter
    savingsGoals?: SavingsGoalListRelationFilter
    mandatorySavings?: XOR<MandatorySavingsNullableRelationFilter, MandatorySavingsWhereInput> | null
    plans?: PlanListRelationFilter
    plaidItems?: PlaidItemListRelationFilter
    budgets?: BudgetListRelationFilter
    tagRules?: TagRuleListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    bills?: BillOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    incomeStreams?: IncomeStreamOrderByRelationAggregateInput
    debts?: DebtOrderByRelationAggregateInput
    debtPayments?: DebtPaymentOrderByRelationAggregateInput
    savingsGoals?: SavingsGoalOrderByRelationAggregateInput
    mandatorySavings?: MandatorySavingsOrderByWithRelationInput
    plans?: PlanOrderByRelationAggregateInput
    plaidItems?: PlaidItemOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    tagRules?: TagRuleOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    categories?: CategoryListRelationFilter
    transactions?: TransactionListRelationFilter
    tags?: TagListRelationFilter
    bills?: BillListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    incomeStreams?: IncomeStreamListRelationFilter
    debts?: DebtListRelationFilter
    debtPayments?: DebtPaymentListRelationFilter
    savingsGoals?: SavingsGoalListRelationFilter
    mandatorySavings?: XOR<MandatorySavingsNullableRelationFilter, MandatorySavingsWhereInput> | null
    plans?: PlanListRelationFilter
    plaidItems?: PlaidItemListRelationFilter
    budgets?: BudgetListRelationFilter
    tagRules?: TagRuleListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    currency?: StringFilter<"Account"> | string
    plaidItemId?: StringNullableFilter<"Account"> | string | null
    plaidAccountId?: StringNullableFilter<"Account"> | string | null
    plaidMask?: StringNullableFilter<"Account"> | string | null
    plaidType?: StringNullableFilter<"Account"> | string | null
    plaidSubtype?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plaidItem?: XOR<PlaidItemNullableRelationFilter, PlaidItemWhereInput> | null
    transactions?: TransactionListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    plaidItemId?: SortOrder
    plaidAccountId?: SortOrder
    plaidMask?: SortOrder
    plaidType?: SortOrder
    plaidSubtype?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plaidItem?: PlaidItemOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    plaidAccountId?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    currency?: StringFilter<"Account"> | string
    plaidItemId?: StringNullableFilter<"Account"> | string | null
    plaidMask?: StringNullableFilter<"Account"> | string | null
    plaidType?: StringNullableFilter<"Account"> | string | null
    plaidSubtype?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plaidItem?: XOR<PlaidItemNullableRelationFilter, PlaidItemWhereInput> | null
    transactions?: TransactionListRelationFilter
  }, "id" | "plaidAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    plaidItemId?: SortOrder
    plaidAccountId?: SortOrder
    plaidMask?: SortOrder
    plaidType?: SortOrder
    plaidSubtype?: SortOrder
    createdAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    currency?: StringWithAggregatesFilter<"Account"> | string
    plaidItemId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    plaidAccountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    plaidMask?: StringNullableWithAggregatesFilter<"Account"> | string | null
    plaidType?: StringNullableWithAggregatesFilter<"Account"> | string | null
    plaidSubtype?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    userId?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    kind?: EnumCategoryKindFilter<"Category"> | $Enums.CategoryKind
    createdAt?: DateTimeFilter<"Category"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
    budgets?: BudgetListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    userId?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    kind?: EnumCategoryKindFilter<"Category"> | $Enums.CategoryKind
    createdAt?: DateTimeFilter<"Category"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
    budgets?: BudgetListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    userId?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    kind?: EnumCategoryKindWithAggregatesFilter<"Category"> | $Enums.CategoryKind
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    accountId?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    amountDollars?: FloatFilter<"Transaction"> | number
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    merchant?: StringNullableFilter<"Transaction"> | string | null
    note?: StringNullableFilter<"Transaction"> | string | null
    plaidTransactionId?: StringNullableFilter<"Transaction"> | string | null
    pending?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    transactionTags?: TransactionTagListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    amountDollars?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    note?: SortOrder
    plaidTransactionId?: SortOrder
    pending?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    transactionTags?: TransactionTagOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    plaidTransactionId?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    accountId?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    amountDollars?: FloatFilter<"Transaction"> | number
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    merchant?: StringNullableFilter<"Transaction"> | string | null
    note?: StringNullableFilter<"Transaction"> | string | null
    pending?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    transactionTags?: TransactionTagListRelationFilter
  }, "id" | "plaidTransactionId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    amountDollars?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    note?: SortOrder
    plaidTransactionId?: SortOrder
    pending?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    accountId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    amountDollars?: FloatWithAggregatesFilter<"Transaction"> | number
    categoryId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    merchant?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    note?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    plaidTransactionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    pending?: BoolWithAggregatesFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TagRuleWhereInput = {
    AND?: TagRuleWhereInput | TagRuleWhereInput[]
    OR?: TagRuleWhereInput[]
    NOT?: TagRuleWhereInput | TagRuleWhereInput[]
    id?: StringFilter<"TagRule"> | string
    userId?: StringFilter<"TagRule"> | string
    name?: StringFilter<"TagRule"> | string
    pattern?: StringFilter<"TagRule"> | string
    matchType?: EnumTagRuleMatchTypeFilter<"TagRule"> | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFilter<"TagRule"> | $Enums.TagRuleSourceField
    createdAt?: DateTimeFilter<"TagRule"> | Date | string
    updatedAt?: DateTimeFilter<"TagRule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tags?: TagRuleTagListRelationFilter
  }

  export type TagRuleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    pattern?: SortOrder
    matchType?: SortOrder
    sourceField?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tags?: TagRuleTagOrderByRelationAggregateInput
  }

  export type TagRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagRuleWhereInput | TagRuleWhereInput[]
    OR?: TagRuleWhereInput[]
    NOT?: TagRuleWhereInput | TagRuleWhereInput[]
    userId?: StringFilter<"TagRule"> | string
    name?: StringFilter<"TagRule"> | string
    pattern?: StringFilter<"TagRule"> | string
    matchType?: EnumTagRuleMatchTypeFilter<"TagRule"> | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFilter<"TagRule"> | $Enums.TagRuleSourceField
    createdAt?: DateTimeFilter<"TagRule"> | Date | string
    updatedAt?: DateTimeFilter<"TagRule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tags?: TagRuleTagListRelationFilter
  }, "id">

  export type TagRuleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    pattern?: SortOrder
    matchType?: SortOrder
    sourceField?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagRuleCountOrderByAggregateInput
    _max?: TagRuleMaxOrderByAggregateInput
    _min?: TagRuleMinOrderByAggregateInput
  }

  export type TagRuleScalarWhereWithAggregatesInput = {
    AND?: TagRuleScalarWhereWithAggregatesInput | TagRuleScalarWhereWithAggregatesInput[]
    OR?: TagRuleScalarWhereWithAggregatesInput[]
    NOT?: TagRuleScalarWhereWithAggregatesInput | TagRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TagRule"> | string
    userId?: StringWithAggregatesFilter<"TagRule"> | string
    name?: StringWithAggregatesFilter<"TagRule"> | string
    pattern?: StringWithAggregatesFilter<"TagRule"> | string
    matchType?: EnumTagRuleMatchTypeWithAggregatesFilter<"TagRule"> | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldWithAggregatesFilter<"TagRule"> | $Enums.TagRuleSourceField
    createdAt?: DateTimeWithAggregatesFilter<"TagRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TagRule"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    userId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    amountDollars?: FloatFilter<"Budget"> | number
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    categoryId?: StringNullableFilter<"Budget"> | string | null
    tagId?: StringNullableFilter<"Budget"> | string | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tag?: XOR<TagNullableRelationFilter, TagWhereInput> | null
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    period?: SortOrder
    categoryId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    userId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    amountDollars?: FloatFilter<"Budget"> | number
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    categoryId?: StringNullableFilter<"Budget"> | string | null
    tagId?: StringNullableFilter<"Budget"> | string | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    tag?: XOR<TagNullableRelationFilter, TagWhereInput> | null
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    period?: SortOrder
    categoryId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    userId?: StringWithAggregatesFilter<"Budget"> | string
    name?: StringWithAggregatesFilter<"Budget"> | string
    amountDollars?: FloatWithAggregatesFilter<"Budget"> | number
    period?: EnumBudgetPeriodWithAggregatesFilter<"Budget"> | $Enums.BudgetPeriod
    categoryId?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    tagId?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: StringFilter<"Bill"> | string
    userId?: StringFilter<"Bill"> | string
    name?: StringFilter<"Bill"> | string
    amountDollars?: FloatFilter<"Bill"> | number
    dueDayOfMonth?: IntNullableFilter<"Bill"> | number | null
    dueDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    frequency?: EnumBillFrequencyFilter<"Bill"> | $Enums.BillFrequency
    isEssential?: BoolFilter<"Bill"> | boolean
    autopay?: BoolFilter<"Bill"> | boolean
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    dueDate?: SortOrder
    frequency?: SortOrder
    isEssential?: SortOrder
    autopay?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    userId?: StringFilter<"Bill"> | string
    name?: StringFilter<"Bill"> | string
    amountDollars?: FloatFilter<"Bill"> | number
    dueDayOfMonth?: IntNullableFilter<"Bill"> | number | null
    dueDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    frequency?: EnumBillFrequencyFilter<"Bill"> | $Enums.BillFrequency
    isEssential?: BoolFilter<"Bill"> | boolean
    autopay?: BoolFilter<"Bill"> | boolean
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    dueDate?: SortOrder
    frequency?: SortOrder
    isEssential?: SortOrder
    autopay?: SortOrder
    createdAt?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bill"> | string
    userId?: StringWithAggregatesFilter<"Bill"> | string
    name?: StringWithAggregatesFilter<"Bill"> | string
    amountDollars?: FloatWithAggregatesFilter<"Bill"> | number
    dueDayOfMonth?: IntNullableWithAggregatesFilter<"Bill"> | number | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Bill"> | Date | string | null
    frequency?: EnumBillFrequencyWithAggregatesFilter<"Bill"> | $Enums.BillFrequency
    isEssential?: BoolWithAggregatesFilter<"Bill"> | boolean
    autopay?: BoolWithAggregatesFilter<"Bill"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    name?: StringFilter<"Subscription"> | string
    amountDollars?: FloatFilter<"Subscription"> | number
    billingDayOfMonth?: IntFilter<"Subscription"> | number
    frequency?: EnumSubscriptionFrequencyFilter<"Subscription"> | $Enums.SubscriptionFrequency
    cancelable?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
    frequency?: SortOrder
    cancelable?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    name?: StringFilter<"Subscription"> | string
    amountDollars?: FloatFilter<"Subscription"> | number
    billingDayOfMonth?: IntFilter<"Subscription"> | number
    frequency?: EnumSubscriptionFrequencyFilter<"Subscription"> | $Enums.SubscriptionFrequency
    cancelable?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
    frequency?: SortOrder
    cancelable?: SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    name?: StringWithAggregatesFilter<"Subscription"> | string
    amountDollars?: FloatWithAggregatesFilter<"Subscription"> | number
    billingDayOfMonth?: IntWithAggregatesFilter<"Subscription"> | number
    frequency?: EnumSubscriptionFrequencyWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionFrequency
    cancelable?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type IncomeStreamWhereInput = {
    AND?: IncomeStreamWhereInput | IncomeStreamWhereInput[]
    OR?: IncomeStreamWhereInput[]
    NOT?: IncomeStreamWhereInput | IncomeStreamWhereInput[]
    id?: StringFilter<"IncomeStream"> | string
    userId?: StringFilter<"IncomeStream"> | string
    name?: StringFilter<"IncomeStream"> | string
    amountDollars?: FloatFilter<"IncomeStream"> | number
    lastAmountDollars?: FloatNullableFilter<"IncomeStream"> | number | null
    cadence?: EnumIncomeCadenceFilter<"IncomeStream"> | $Enums.IncomeCadence
    nextPayDate?: DateTimeFilter<"IncomeStream"> | Date | string
    createdAt?: DateTimeFilter<"IncomeStream"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    incomeStreamTags?: IncomeStreamTagListRelationFilter
  }

  export type IncomeStreamOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
    cadence?: SortOrder
    nextPayDate?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    incomeStreamTags?: IncomeStreamTagOrderByRelationAggregateInput
  }

  export type IncomeStreamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncomeStreamWhereInput | IncomeStreamWhereInput[]
    OR?: IncomeStreamWhereInput[]
    NOT?: IncomeStreamWhereInput | IncomeStreamWhereInput[]
    userId?: StringFilter<"IncomeStream"> | string
    name?: StringFilter<"IncomeStream"> | string
    amountDollars?: FloatFilter<"IncomeStream"> | number
    lastAmountDollars?: FloatNullableFilter<"IncomeStream"> | number | null
    cadence?: EnumIncomeCadenceFilter<"IncomeStream"> | $Enums.IncomeCadence
    nextPayDate?: DateTimeFilter<"IncomeStream"> | Date | string
    createdAt?: DateTimeFilter<"IncomeStream"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    incomeStreamTags?: IncomeStreamTagListRelationFilter
  }, "id">

  export type IncomeStreamOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
    cadence?: SortOrder
    nextPayDate?: SortOrder
    createdAt?: SortOrder
    _count?: IncomeStreamCountOrderByAggregateInput
    _avg?: IncomeStreamAvgOrderByAggregateInput
    _max?: IncomeStreamMaxOrderByAggregateInput
    _min?: IncomeStreamMinOrderByAggregateInput
    _sum?: IncomeStreamSumOrderByAggregateInput
  }

  export type IncomeStreamScalarWhereWithAggregatesInput = {
    AND?: IncomeStreamScalarWhereWithAggregatesInput | IncomeStreamScalarWhereWithAggregatesInput[]
    OR?: IncomeStreamScalarWhereWithAggregatesInput[]
    NOT?: IncomeStreamScalarWhereWithAggregatesInput | IncomeStreamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncomeStream"> | string
    userId?: StringWithAggregatesFilter<"IncomeStream"> | string
    name?: StringWithAggregatesFilter<"IncomeStream"> | string
    amountDollars?: FloatWithAggregatesFilter<"IncomeStream"> | number
    lastAmountDollars?: FloatNullableWithAggregatesFilter<"IncomeStream"> | number | null
    cadence?: EnumIncomeCadenceWithAggregatesFilter<"IncomeStream"> | $Enums.IncomeCadence
    nextPayDate?: DateTimeWithAggregatesFilter<"IncomeStream"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"IncomeStream"> | Date | string
  }

  export type DebtWhereInput = {
    AND?: DebtWhereInput | DebtWhereInput[]
    OR?: DebtWhereInput[]
    NOT?: DebtWhereInput | DebtWhereInput[]
    id?: StringFilter<"Debt"> | string
    userId?: StringFilter<"Debt"> | string
    name?: StringFilter<"Debt"> | string
    principalDollars?: FloatFilter<"Debt"> | number
    aprBps?: IntFilter<"Debt"> | number
    minPaymentDollars?: FloatFilter<"Debt"> | number
    estimatedMonthlyPaymentDollars?: FloatNullableFilter<"Debt"> | number | null
    dueDayOfMonth?: IntFilter<"Debt"> | number
    estimatedPayoffDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: DebtPaymentListRelationFilter
    debtTags?: DebtTagListRelationFilter
  }

  export type DebtOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    estimatedPayoffDate?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payments?: DebtPaymentOrderByRelationAggregateInput
    debtTags?: DebtTagOrderByRelationAggregateInput
  }

  export type DebtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtWhereInput | DebtWhereInput[]
    OR?: DebtWhereInput[]
    NOT?: DebtWhereInput | DebtWhereInput[]
    userId?: StringFilter<"Debt"> | string
    name?: StringFilter<"Debt"> | string
    principalDollars?: FloatFilter<"Debt"> | number
    aprBps?: IntFilter<"Debt"> | number
    minPaymentDollars?: FloatFilter<"Debt"> | number
    estimatedMonthlyPaymentDollars?: FloatNullableFilter<"Debt"> | number | null
    dueDayOfMonth?: IntFilter<"Debt"> | number
    estimatedPayoffDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: DebtPaymentListRelationFilter
    debtTags?: DebtTagListRelationFilter
  }, "id">

  export type DebtOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    estimatedPayoffDate?: SortOrder
    createdAt?: SortOrder
    _count?: DebtCountOrderByAggregateInput
    _avg?: DebtAvgOrderByAggregateInput
    _max?: DebtMaxOrderByAggregateInput
    _min?: DebtMinOrderByAggregateInput
    _sum?: DebtSumOrderByAggregateInput
  }

  export type DebtScalarWhereWithAggregatesInput = {
    AND?: DebtScalarWhereWithAggregatesInput | DebtScalarWhereWithAggregatesInput[]
    OR?: DebtScalarWhereWithAggregatesInput[]
    NOT?: DebtScalarWhereWithAggregatesInput | DebtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Debt"> | string
    userId?: StringWithAggregatesFilter<"Debt"> | string
    name?: StringWithAggregatesFilter<"Debt"> | string
    principalDollars?: FloatWithAggregatesFilter<"Debt"> | number
    aprBps?: IntWithAggregatesFilter<"Debt"> | number
    minPaymentDollars?: FloatWithAggregatesFilter<"Debt"> | number
    estimatedMonthlyPaymentDollars?: FloatNullableWithAggregatesFilter<"Debt"> | number | null
    dueDayOfMonth?: IntWithAggregatesFilter<"Debt"> | number
    estimatedPayoffDate?: DateTimeNullableWithAggregatesFilter<"Debt"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Debt"> | Date | string
  }

  export type SavingsGoalWhereInput = {
    AND?: SavingsGoalWhereInput | SavingsGoalWhereInput[]
    OR?: SavingsGoalWhereInput[]
    NOT?: SavingsGoalWhereInput | SavingsGoalWhereInput[]
    id?: StringFilter<"SavingsGoal"> | string
    userId?: StringFilter<"SavingsGoal"> | string
    name?: StringFilter<"SavingsGoal"> | string
    targetDollars?: FloatFilter<"SavingsGoal"> | number
    currentDollars?: FloatFilter<"SavingsGoal"> | number
    ruleType?: EnumSavingsRuleTypeFilter<"SavingsGoal"> | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFilter<"SavingsGoal"> | number
    priority?: IntFilter<"SavingsGoal"> | number
    createdAt?: DateTimeFilter<"SavingsGoal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SavingsGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleType?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SavingsGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavingsGoalWhereInput | SavingsGoalWhereInput[]
    OR?: SavingsGoalWhereInput[]
    NOT?: SavingsGoalWhereInput | SavingsGoalWhereInput[]
    userId?: StringFilter<"SavingsGoal"> | string
    name?: StringFilter<"SavingsGoal"> | string
    targetDollars?: FloatFilter<"SavingsGoal"> | number
    currentDollars?: FloatFilter<"SavingsGoal"> | number
    ruleType?: EnumSavingsRuleTypeFilter<"SavingsGoal"> | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFilter<"SavingsGoal"> | number
    priority?: IntFilter<"SavingsGoal"> | number
    createdAt?: DateTimeFilter<"SavingsGoal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SavingsGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleType?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    _count?: SavingsGoalCountOrderByAggregateInput
    _avg?: SavingsGoalAvgOrderByAggregateInput
    _max?: SavingsGoalMaxOrderByAggregateInput
    _min?: SavingsGoalMinOrderByAggregateInput
    _sum?: SavingsGoalSumOrderByAggregateInput
  }

  export type SavingsGoalScalarWhereWithAggregatesInput = {
    AND?: SavingsGoalScalarWhereWithAggregatesInput | SavingsGoalScalarWhereWithAggregatesInput[]
    OR?: SavingsGoalScalarWhereWithAggregatesInput[]
    NOT?: SavingsGoalScalarWhereWithAggregatesInput | SavingsGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavingsGoal"> | string
    userId?: StringWithAggregatesFilter<"SavingsGoal"> | string
    name?: StringWithAggregatesFilter<"SavingsGoal"> | string
    targetDollars?: FloatWithAggregatesFilter<"SavingsGoal"> | number
    currentDollars?: FloatWithAggregatesFilter<"SavingsGoal"> | number
    ruleType?: EnumSavingsRuleTypeWithAggregatesFilter<"SavingsGoal"> | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatWithAggregatesFilter<"SavingsGoal"> | number
    priority?: IntWithAggregatesFilter<"SavingsGoal"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SavingsGoal"> | Date | string
  }

  export type MandatorySavingsWhereInput = {
    AND?: MandatorySavingsWhereInput | MandatorySavingsWhereInput[]
    OR?: MandatorySavingsWhereInput[]
    NOT?: MandatorySavingsWhereInput | MandatorySavingsWhereInput[]
    id?: StringFilter<"MandatorySavings"> | string
    userId?: StringFilter<"MandatorySavings"> | string
    monthsToSave?: IntFilter<"MandatorySavings"> | number
    targetDollars?: FloatFilter<"MandatorySavings"> | number
    currentDollars?: FloatFilter<"MandatorySavings"> | number
    createdAt?: DateTimeFilter<"MandatorySavings"> | Date | string
    updatedAt?: DateTimeFilter<"MandatorySavings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MandatorySavingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MandatorySavingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: MandatorySavingsWhereInput | MandatorySavingsWhereInput[]
    OR?: MandatorySavingsWhereInput[]
    NOT?: MandatorySavingsWhereInput | MandatorySavingsWhereInput[]
    monthsToSave?: IntFilter<"MandatorySavings"> | number
    targetDollars?: FloatFilter<"MandatorySavings"> | number
    currentDollars?: FloatFilter<"MandatorySavings"> | number
    createdAt?: DateTimeFilter<"MandatorySavings"> | Date | string
    updatedAt?: DateTimeFilter<"MandatorySavings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type MandatorySavingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MandatorySavingsCountOrderByAggregateInput
    _avg?: MandatorySavingsAvgOrderByAggregateInput
    _max?: MandatorySavingsMaxOrderByAggregateInput
    _min?: MandatorySavingsMinOrderByAggregateInput
    _sum?: MandatorySavingsSumOrderByAggregateInput
  }

  export type MandatorySavingsScalarWhereWithAggregatesInput = {
    AND?: MandatorySavingsScalarWhereWithAggregatesInput | MandatorySavingsScalarWhereWithAggregatesInput[]
    OR?: MandatorySavingsScalarWhereWithAggregatesInput[]
    NOT?: MandatorySavingsScalarWhereWithAggregatesInput | MandatorySavingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MandatorySavings"> | string
    userId?: StringWithAggregatesFilter<"MandatorySavings"> | string
    monthsToSave?: IntWithAggregatesFilter<"MandatorySavings"> | number
    targetDollars?: FloatWithAggregatesFilter<"MandatorySavings"> | number
    currentDollars?: FloatWithAggregatesFilter<"MandatorySavings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MandatorySavings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MandatorySavings"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    milestonePct?: IntNullableFilter<"Notification"> | number | null
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    milestonePct?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    milestonePct?: IntNullableFilter<"Notification"> | number | null
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    milestonePct?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    entityType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    milestonePct?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    message?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    userId?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    strategy?: EnumPlanStrategyFilter<"Plan"> | $Enums.PlanStrategy
    horizonMonths?: IntFilter<"Plan"> | number
    startDate?: DateTimeFilter<"Plan"> | Date | string
    rulesJson?: JsonFilter<"Plan">
    summaryJson?: JsonFilter<"Plan">
    warningsJson?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: PlanItemListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    horizonMonths?: SortOrder
    startDate?: SortOrder
    rulesJson?: SortOrder
    summaryJson?: SortOrder
    warningsJson?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: PlanItemOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    userId?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    strategy?: EnumPlanStrategyFilter<"Plan"> | $Enums.PlanStrategy
    horizonMonths?: IntFilter<"Plan"> | number
    startDate?: DateTimeFilter<"Plan"> | Date | string
    rulesJson?: JsonFilter<"Plan">
    summaryJson?: JsonFilter<"Plan">
    warningsJson?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: PlanItemListRelationFilter
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    horizonMonths?: SortOrder
    startDate?: SortOrder
    rulesJson?: SortOrder
    summaryJson?: SortOrder
    warningsJson?: SortOrder
    createdAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    userId?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    strategy?: EnumPlanStrategyWithAggregatesFilter<"Plan"> | $Enums.PlanStrategy
    horizonMonths?: IntWithAggregatesFilter<"Plan"> | number
    startDate?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    rulesJson?: JsonWithAggregatesFilter<"Plan">
    summaryJson?: JsonWithAggregatesFilter<"Plan">
    warningsJson?: JsonWithAggregatesFilter<"Plan">
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type PlanItemWhereInput = {
    AND?: PlanItemWhereInput | PlanItemWhereInput[]
    OR?: PlanItemWhereInput[]
    NOT?: PlanItemWhereInput | PlanItemWhereInput[]
    id?: StringFilter<"PlanItem"> | string
    planId?: StringFilter<"PlanItem"> | string
    date?: DateTimeFilter<"PlanItem"> | Date | string
    type?: EnumPlanItemTypeFilter<"PlanItem"> | $Enums.PlanItemType
    entityId?: StringNullableFilter<"PlanItem"> | string | null
    amountDollars?: FloatFilter<"PlanItem"> | number
    notes?: StringNullableFilter<"PlanItem"> | string | null
    balanceSnapshotJson?: JsonNullableFilter<"PlanItem">
    createdAt?: DateTimeFilter<"PlanItem"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }

  export type PlanItemOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    amountDollars?: SortOrder
    notes?: SortOrder
    balanceSnapshotJson?: SortOrder
    createdAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanItemWhereInput | PlanItemWhereInput[]
    OR?: PlanItemWhereInput[]
    NOT?: PlanItemWhereInput | PlanItemWhereInput[]
    planId?: StringFilter<"PlanItem"> | string
    date?: DateTimeFilter<"PlanItem"> | Date | string
    type?: EnumPlanItemTypeFilter<"PlanItem"> | $Enums.PlanItemType
    entityId?: StringNullableFilter<"PlanItem"> | string | null
    amountDollars?: FloatFilter<"PlanItem"> | number
    notes?: StringNullableFilter<"PlanItem"> | string | null
    balanceSnapshotJson?: JsonNullableFilter<"PlanItem">
    createdAt?: DateTimeFilter<"PlanItem"> | Date | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanItemOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    amountDollars?: SortOrder
    notes?: SortOrder
    balanceSnapshotJson?: SortOrder
    createdAt?: SortOrder
    _count?: PlanItemCountOrderByAggregateInput
    _avg?: PlanItemAvgOrderByAggregateInput
    _max?: PlanItemMaxOrderByAggregateInput
    _min?: PlanItemMinOrderByAggregateInput
    _sum?: PlanItemSumOrderByAggregateInput
  }

  export type PlanItemScalarWhereWithAggregatesInput = {
    AND?: PlanItemScalarWhereWithAggregatesInput | PlanItemScalarWhereWithAggregatesInput[]
    OR?: PlanItemScalarWhereWithAggregatesInput[]
    NOT?: PlanItemScalarWhereWithAggregatesInput | PlanItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanItem"> | string
    planId?: StringWithAggregatesFilter<"PlanItem"> | string
    date?: DateTimeWithAggregatesFilter<"PlanItem"> | Date | string
    type?: EnumPlanItemTypeWithAggregatesFilter<"PlanItem"> | $Enums.PlanItemType
    entityId?: StringNullableWithAggregatesFilter<"PlanItem"> | string | null
    amountDollars?: FloatWithAggregatesFilter<"PlanItem"> | number
    notes?: StringNullableWithAggregatesFilter<"PlanItem"> | string | null
    balanceSnapshotJson?: JsonNullableWithAggregatesFilter<"PlanItem">
    createdAt?: DateTimeWithAggregatesFilter<"PlanItem"> | Date | string
  }

  export type DebtPaymentWhereInput = {
    AND?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    OR?: DebtPaymentWhereInput[]
    NOT?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    id?: StringFilter<"DebtPayment"> | string
    userId?: StringFilter<"DebtPayment"> | string
    debtId?: StringFilter<"DebtPayment"> | string
    amountDollars?: FloatFilter<"DebtPayment"> | number
    paymentDate?: DateTimeFilter<"DebtPayment"> | Date | string
    createdAt?: DateTimeFilter<"DebtPayment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    debt?: XOR<DebtRelationFilter, DebtWhereInput>
  }

  export type DebtPaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    debtId?: SortOrder
    amountDollars?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    debt?: DebtOrderByWithRelationInput
  }

  export type DebtPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    OR?: DebtPaymentWhereInput[]
    NOT?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    userId?: StringFilter<"DebtPayment"> | string
    debtId?: StringFilter<"DebtPayment"> | string
    amountDollars?: FloatFilter<"DebtPayment"> | number
    paymentDate?: DateTimeFilter<"DebtPayment"> | Date | string
    createdAt?: DateTimeFilter<"DebtPayment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    debt?: XOR<DebtRelationFilter, DebtWhereInput>
  }, "id">

  export type DebtPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    debtId?: SortOrder
    amountDollars?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    _count?: DebtPaymentCountOrderByAggregateInput
    _avg?: DebtPaymentAvgOrderByAggregateInput
    _max?: DebtPaymentMaxOrderByAggregateInput
    _min?: DebtPaymentMinOrderByAggregateInput
    _sum?: DebtPaymentSumOrderByAggregateInput
  }

  export type DebtPaymentScalarWhereWithAggregatesInput = {
    AND?: DebtPaymentScalarWhereWithAggregatesInput | DebtPaymentScalarWhereWithAggregatesInput[]
    OR?: DebtPaymentScalarWhereWithAggregatesInput[]
    NOT?: DebtPaymentScalarWhereWithAggregatesInput | DebtPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DebtPayment"> | string
    userId?: StringWithAggregatesFilter<"DebtPayment"> | string
    debtId?: StringWithAggregatesFilter<"DebtPayment"> | string
    amountDollars?: FloatWithAggregatesFilter<"DebtPayment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"DebtPayment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DebtPayment"> | Date | string
  }

  export type PlaidItemWhereInput = {
    AND?: PlaidItemWhereInput | PlaidItemWhereInput[]
    OR?: PlaidItemWhereInput[]
    NOT?: PlaidItemWhereInput | PlaidItemWhereInput[]
    id?: StringFilter<"PlaidItem"> | string
    userId?: StringFilter<"PlaidItem"> | string
    itemId?: StringFilter<"PlaidItem"> | string
    accessTokenEncrypted?: StringFilter<"PlaidItem"> | string
    institutionId?: StringNullableFilter<"PlaidItem"> | string | null
    institutionName?: StringNullableFilter<"PlaidItem"> | string | null
    transactionsCursor?: StringNullableFilter<"PlaidItem"> | string | null
    createdAt?: DateTimeFilter<"PlaidItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlaidItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    accounts?: AccountListRelationFilter
  }

  export type PlaidItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    accessTokenEncrypted?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    transactionsCursor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type PlaidItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId?: string
    AND?: PlaidItemWhereInput | PlaidItemWhereInput[]
    OR?: PlaidItemWhereInput[]
    NOT?: PlaidItemWhereInput | PlaidItemWhereInput[]
    userId?: StringFilter<"PlaidItem"> | string
    accessTokenEncrypted?: StringFilter<"PlaidItem"> | string
    institutionId?: StringNullableFilter<"PlaidItem"> | string | null
    institutionName?: StringNullableFilter<"PlaidItem"> | string | null
    transactionsCursor?: StringNullableFilter<"PlaidItem"> | string | null
    createdAt?: DateTimeFilter<"PlaidItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlaidItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    accounts?: AccountListRelationFilter
  }, "id" | "itemId">

  export type PlaidItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    accessTokenEncrypted?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    transactionsCursor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlaidItemCountOrderByAggregateInput
    _max?: PlaidItemMaxOrderByAggregateInput
    _min?: PlaidItemMinOrderByAggregateInput
  }

  export type PlaidItemScalarWhereWithAggregatesInput = {
    AND?: PlaidItemScalarWhereWithAggregatesInput | PlaidItemScalarWhereWithAggregatesInput[]
    OR?: PlaidItemScalarWhereWithAggregatesInput[]
    NOT?: PlaidItemScalarWhereWithAggregatesInput | PlaidItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlaidItem"> | string
    userId?: StringWithAggregatesFilter<"PlaidItem"> | string
    itemId?: StringWithAggregatesFilter<"PlaidItem"> | string
    accessTokenEncrypted?: StringWithAggregatesFilter<"PlaidItem"> | string
    institutionId?: StringNullableWithAggregatesFilter<"PlaidItem"> | string | null
    institutionName?: StringNullableWithAggregatesFilter<"PlaidItem"> | string | null
    transactionsCursor?: StringNullableWithAggregatesFilter<"PlaidItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlaidItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlaidItem"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    userId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactionTags?: TransactionTagListRelationFilter
    incomeStreamTags?: IncomeStreamTagListRelationFilter
    debtTags?: DebtTagListRelationFilter
    budgets?: BudgetListRelationFilter
    tagRuleTags?: TagRuleTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactionTags?: TransactionTagOrderByRelationAggregateInput
    incomeStreamTags?: IncomeStreamTagOrderByRelationAggregateInput
    debtTags?: DebtTagOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    tagRuleTags?: TagRuleTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_name?: TagUserIdNameCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    userId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactionTags?: TransactionTagListRelationFilter
    incomeStreamTags?: IncomeStreamTagListRelationFilter
    debtTags?: DebtTagListRelationFilter
    budgets?: BudgetListRelationFilter
    tagRuleTags?: TagRuleTagListRelationFilter
  }, "id" | "userId_name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    userId?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TagRuleTagWhereInput = {
    AND?: TagRuleTagWhereInput | TagRuleTagWhereInput[]
    OR?: TagRuleTagWhereInput[]
    NOT?: TagRuleTagWhereInput | TagRuleTagWhereInput[]
    id?: StringFilter<"TagRuleTag"> | string
    tagRuleId?: StringFilter<"TagRuleTag"> | string
    tagId?: StringFilter<"TagRuleTag"> | string
    createdAt?: DateTimeFilter<"TagRuleTag"> | Date | string
    tagRule?: XOR<TagRuleRelationFilter, TagRuleWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type TagRuleTagOrderByWithRelationInput = {
    id?: SortOrder
    tagRuleId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    tagRule?: TagRuleOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TagRuleTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagRuleId_tagId?: TagRuleTagTagRuleIdTagIdCompoundUniqueInput
    AND?: TagRuleTagWhereInput | TagRuleTagWhereInput[]
    OR?: TagRuleTagWhereInput[]
    NOT?: TagRuleTagWhereInput | TagRuleTagWhereInput[]
    tagRuleId?: StringFilter<"TagRuleTag"> | string
    tagId?: StringFilter<"TagRuleTag"> | string
    createdAt?: DateTimeFilter<"TagRuleTag"> | Date | string
    tagRule?: XOR<TagRuleRelationFilter, TagRuleWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "tagRuleId_tagId">

  export type TagRuleTagOrderByWithAggregationInput = {
    id?: SortOrder
    tagRuleId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: TagRuleTagCountOrderByAggregateInput
    _max?: TagRuleTagMaxOrderByAggregateInput
    _min?: TagRuleTagMinOrderByAggregateInput
  }

  export type TagRuleTagScalarWhereWithAggregatesInput = {
    AND?: TagRuleTagScalarWhereWithAggregatesInput | TagRuleTagScalarWhereWithAggregatesInput[]
    OR?: TagRuleTagScalarWhereWithAggregatesInput[]
    NOT?: TagRuleTagScalarWhereWithAggregatesInput | TagRuleTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TagRuleTag"> | string
    tagRuleId?: StringWithAggregatesFilter<"TagRuleTag"> | string
    tagId?: StringWithAggregatesFilter<"TagRuleTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TagRuleTag"> | Date | string
  }

  export type TransactionTagWhereInput = {
    AND?: TransactionTagWhereInput | TransactionTagWhereInput[]
    OR?: TransactionTagWhereInput[]
    NOT?: TransactionTagWhereInput | TransactionTagWhereInput[]
    id?: StringFilter<"TransactionTag"> | string
    transactionId?: StringFilter<"TransactionTag"> | string
    tagId?: StringFilter<"TransactionTag"> | string
    createdAt?: DateTimeFilter<"TransactionTag"> | Date | string
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type TransactionTagOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TransactionTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId_tagId?: TransactionTagTransactionIdTagIdCompoundUniqueInput
    AND?: TransactionTagWhereInput | TransactionTagWhereInput[]
    OR?: TransactionTagWhereInput[]
    NOT?: TransactionTagWhereInput | TransactionTagWhereInput[]
    transactionId?: StringFilter<"TransactionTag"> | string
    tagId?: StringFilter<"TransactionTag"> | string
    createdAt?: DateTimeFilter<"TransactionTag"> | Date | string
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "transactionId_tagId">

  export type TransactionTagOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionTagCountOrderByAggregateInput
    _max?: TransactionTagMaxOrderByAggregateInput
    _min?: TransactionTagMinOrderByAggregateInput
  }

  export type TransactionTagScalarWhereWithAggregatesInput = {
    AND?: TransactionTagScalarWhereWithAggregatesInput | TransactionTagScalarWhereWithAggregatesInput[]
    OR?: TransactionTagScalarWhereWithAggregatesInput[]
    NOT?: TransactionTagScalarWhereWithAggregatesInput | TransactionTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionTag"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionTag"> | string
    tagId?: StringWithAggregatesFilter<"TransactionTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TransactionTag"> | Date | string
  }

  export type IncomeStreamTagWhereInput = {
    AND?: IncomeStreamTagWhereInput | IncomeStreamTagWhereInput[]
    OR?: IncomeStreamTagWhereInput[]
    NOT?: IncomeStreamTagWhereInput | IncomeStreamTagWhereInput[]
    id?: StringFilter<"IncomeStreamTag"> | string
    incomeStreamId?: StringFilter<"IncomeStreamTag"> | string
    tagId?: StringFilter<"IncomeStreamTag"> | string
    createdAt?: DateTimeFilter<"IncomeStreamTag"> | Date | string
    incomeStream?: XOR<IncomeStreamRelationFilter, IncomeStreamWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type IncomeStreamTagOrderByWithRelationInput = {
    id?: SortOrder
    incomeStreamId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    incomeStream?: IncomeStreamOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type IncomeStreamTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    incomeStreamId_tagId?: IncomeStreamTagIncomeStreamIdTagIdCompoundUniqueInput
    AND?: IncomeStreamTagWhereInput | IncomeStreamTagWhereInput[]
    OR?: IncomeStreamTagWhereInput[]
    NOT?: IncomeStreamTagWhereInput | IncomeStreamTagWhereInput[]
    incomeStreamId?: StringFilter<"IncomeStreamTag"> | string
    tagId?: StringFilter<"IncomeStreamTag"> | string
    createdAt?: DateTimeFilter<"IncomeStreamTag"> | Date | string
    incomeStream?: XOR<IncomeStreamRelationFilter, IncomeStreamWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "incomeStreamId_tagId">

  export type IncomeStreamTagOrderByWithAggregationInput = {
    id?: SortOrder
    incomeStreamId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: IncomeStreamTagCountOrderByAggregateInput
    _max?: IncomeStreamTagMaxOrderByAggregateInput
    _min?: IncomeStreamTagMinOrderByAggregateInput
  }

  export type IncomeStreamTagScalarWhereWithAggregatesInput = {
    AND?: IncomeStreamTagScalarWhereWithAggregatesInput | IncomeStreamTagScalarWhereWithAggregatesInput[]
    OR?: IncomeStreamTagScalarWhereWithAggregatesInput[]
    NOT?: IncomeStreamTagScalarWhereWithAggregatesInput | IncomeStreamTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncomeStreamTag"> | string
    incomeStreamId?: StringWithAggregatesFilter<"IncomeStreamTag"> | string
    tagId?: StringWithAggregatesFilter<"IncomeStreamTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncomeStreamTag"> | Date | string
  }

  export type DebtTagWhereInput = {
    AND?: DebtTagWhereInput | DebtTagWhereInput[]
    OR?: DebtTagWhereInput[]
    NOT?: DebtTagWhereInput | DebtTagWhereInput[]
    id?: StringFilter<"DebtTag"> | string
    debtId?: StringFilter<"DebtTag"> | string
    tagId?: StringFilter<"DebtTag"> | string
    createdAt?: DateTimeFilter<"DebtTag"> | Date | string
    debt?: XOR<DebtRelationFilter, DebtWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type DebtTagOrderByWithRelationInput = {
    id?: SortOrder
    debtId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    debt?: DebtOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type DebtTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    debtId_tagId?: DebtTagDebtIdTagIdCompoundUniqueInput
    AND?: DebtTagWhereInput | DebtTagWhereInput[]
    OR?: DebtTagWhereInput[]
    NOT?: DebtTagWhereInput | DebtTagWhereInput[]
    debtId?: StringFilter<"DebtTag"> | string
    tagId?: StringFilter<"DebtTag"> | string
    createdAt?: DateTimeFilter<"DebtTag"> | Date | string
    debt?: XOR<DebtRelationFilter, DebtWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "debtId_tagId">

  export type DebtTagOrderByWithAggregationInput = {
    id?: SortOrder
    debtId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: DebtTagCountOrderByAggregateInput
    _max?: DebtTagMaxOrderByAggregateInput
    _min?: DebtTagMinOrderByAggregateInput
  }

  export type DebtTagScalarWhereWithAggregatesInput = {
    AND?: DebtTagScalarWhereWithAggregatesInput | DebtTagScalarWhereWithAggregatesInput[]
    OR?: DebtTagScalarWhereWithAggregatesInput[]
    NOT?: DebtTagScalarWhereWithAggregatesInput | DebtTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DebtTag"> | string
    debtId?: StringWithAggregatesFilter<"DebtTag"> | string
    tagId?: StringWithAggregatesFilter<"DebtTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DebtTag"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
    plaidItem?: PlaidItemCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidItemId?: string | null
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
    plaidItem?: PlaidItemUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidItemId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidItemId?: string | null
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidItemId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCategoriesInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    userId: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleCreateInput = {
    id?: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTagRulesInput
    tags?: TagRuleTagCreateNestedManyWithoutTagRuleInput
  }

  export type TagRuleUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagRuleTagUncheckedCreateNestedManyWithoutTagRuleInput
  }

  export type TagRuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagRulesNestedInput
    tags?: TagRuleTagUpdateManyWithoutTagRuleNestedInput
  }

  export type TagRuleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagRuleTagUncheckedUpdateManyWithoutTagRuleNestedInput
  }

  export type TagRuleCreateManyInput = {
    id?: string
    userId: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagRuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
    category?: CategoryCreateNestedOneWithoutBudgetsInput
    tag?: TagCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId?: string | null
    tagId?: string | null
    createdAt?: Date | string
  }

  export type BudgetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
    category?: CategoryUpdateOneWithoutBudgetsNestedInput
    tag?: TagUpdateOneWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateManyInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId?: string | null
    tagId?: string | null
    createdAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateInput = {
    id?: string
    name: string
    amountDollars: number
    dueDayOfMonth?: number | null
    dueDate?: Date | string | null
    frequency: $Enums.BillFrequency
    isEssential?: boolean
    autopay?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
  }

  export type BillUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    dueDayOfMonth?: number | null
    dueDate?: Date | string | null
    frequency: $Enums.BillFrequency
    isEssential?: boolean
    autopay?: boolean
    createdAt?: Date | string
  }

  export type BillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
  }

  export type BillUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateManyInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    dueDayOfMonth?: number | null
    dueDate?: Date | string | null
    frequency: $Enums.BillFrequency
    isEssential?: boolean
    autopay?: boolean
    createdAt?: Date | string
  }

  export type BillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamCreateInput = {
    id?: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutIncomeStreamsInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutIncomeStreamInput
  }

  export type IncomeStreamUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutIncomeStreamInput
  }

  export type IncomeStreamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIncomeStreamsNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutIncomeStreamNestedInput
  }

  export type IncomeStreamUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutIncomeStreamNestedInput
  }

  export type IncomeStreamCreateManyInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
  }

  export type IncomeStreamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtCreateInput = {
    id?: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDebtsInput
    payments?: DebtPaymentCreateNestedManyWithoutDebtInput
    debtTags?: DebtTagCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    payments?: DebtPaymentUncheckedCreateNestedManyWithoutDebtInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDebtsNestedInput
    payments?: DebtPaymentUpdateManyWithoutDebtNestedInput
    debtTags?: DebtTagUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtCreateManyInput = {
    id?: string
    userId: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
  }

  export type DebtUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavingsGoalCreateInput = {
    id?: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavingsGoalsInput
  }

  export type SavingsGoalUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority?: number
    createdAt?: Date | string
  }

  export type SavingsGoalUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavingsGoalsNestedInput
  }

  export type SavingsGoalUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavingsGoalCreateManyInput = {
    id?: string
    userId: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority?: number
    createdAt?: Date | string
  }

  export type SavingsGoalUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavingsGoalUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandatorySavingsCreateInput = {
    id?: string
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMandatorySavingsInput
  }

  export type MandatorySavingsUncheckedCreateInput = {
    id?: string
    userId: string
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MandatorySavingsUpdateInput = {
    monthsToSave?: IntFieldUpdateOperationsInput | number
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMandatorySavingsNestedInput
  }

  export type MandatorySavingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    monthsToSave?: IntFieldUpdateOperationsInput | number
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandatorySavingsCreateManyInput = {
    id?: string
    userId: string
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MandatorySavingsUpdateManyMutationInput = {
    monthsToSave?: IntFieldUpdateOperationsInput | number
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandatorySavingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    monthsToSave?: IntFieldUpdateOperationsInput | number
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    entityType?: string | null
    entityId?: string | null
    milestonePct?: number | null
    message: string
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    entityType?: string | null
    entityId?: string | null
    milestonePct?: number | null
    message: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    entityType?: string | null
    entityId?: string | null
    milestonePct?: number | null
    message: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlansInput
    items?: PlanItemCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
    items?: PlanItemUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlansNestedInput
    items?: PlanItemUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PlanItemUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    userId: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanItemCreateInput = {
    id?: string
    date: Date | string
    type: $Enums.PlanItemType
    entityId?: string | null
    amountDollars: number
    notes?: string | null
    balanceSnapshotJson?: InputJsonValue | null
    createdAt?: Date | string
    plan: PlanCreateNestedOneWithoutItemsInput
  }

  export type PlanItemUncheckedCreateInput = {
    id?: string
    planId: string
    date: Date | string
    type: $Enums.PlanItemType
    entityId?: string | null
    amountDollars: number
    notes?: string | null
    balanceSnapshotJson?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type PlanItemUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PlanItemUncheckedUpdateInput = {
    planId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanItemCreateManyInput = {
    id?: string
    planId: string
    date: Date | string
    type: $Enums.PlanItemType
    entityId?: string | null
    amountDollars: number
    notes?: string | null
    balanceSnapshotJson?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type PlanItemUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanItemUncheckedUpdateManyInput = {
    planId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentCreateInput = {
    id?: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDebtPaymentsInput
    debt: DebtCreateNestedOneWithoutPaymentsInput
  }

  export type DebtPaymentUncheckedCreateInput = {
    id?: string
    userId: string
    debtId: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type DebtPaymentUpdateInput = {
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDebtPaymentsNestedInput
    debt?: DebtUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type DebtPaymentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    debtId?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentCreateManyInput = {
    id?: string
    userId: string
    debtId: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type DebtPaymentUpdateManyMutationInput = {
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    debtId?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaidItemCreateInput = {
    id?: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaidItemsInput
    accounts?: AccountCreateNestedManyWithoutPlaidItemInput
  }

  export type PlaidItemUncheckedCreateInput = {
    id?: string
    userId: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutPlaidItemInput
  }

  export type PlaidItemUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaidItemsNestedInput
    accounts?: AccountUpdateManyWithoutPlaidItemNestedInput
  }

  export type PlaidItemUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutPlaidItemNestedInput
  }

  export type PlaidItemCreateManyInput = {
    id?: string
    userId: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaidItemUpdateManyMutationInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaidItemUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutTagInput
    debtTags?: DebtTagCreateNestedManyWithoutTagInput
    budgets?: BudgetCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutTagInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUpdateManyWithoutTagNestedInput
    budgets?: BudgetUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutTagNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagCreateInput = {
    id?: string
    createdAt?: Date | string
    tagRule: TagRuleCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutTagRuleTagsInput
  }

  export type TagRuleTagUncheckedCreateInput = {
    id?: string
    tagRuleId: string
    tagId: string
    createdAt?: Date | string
  }

  export type TagRuleTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagRule?: TagRuleUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTagRuleTagsNestedInput
  }

  export type TagRuleTagUncheckedUpdateInput = {
    tagRuleId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagCreateManyInput = {
    id?: string
    tagRuleId: string
    tagId: string
    createdAt?: Date | string
  }

  export type TagRuleTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagUncheckedUpdateManyInput = {
    tagRuleId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagCreateInput = {
    id?: string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutTransactionTagsInput
    tag: TagCreateNestedOneWithoutTransactionTagsInput
  }

  export type TransactionTagUncheckedCreateInput = {
    id?: string
    transactionId: string
    tagId: string
    createdAt?: Date | string
  }

  export type TransactionTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutTransactionTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTransactionTagsNestedInput
  }

  export type TransactionTagUncheckedUpdateInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagCreateManyInput = {
    id?: string
    transactionId: string
    tagId: string
    createdAt?: Date | string
  }

  export type TransactionTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagUncheckedUpdateManyInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagCreateInput = {
    id?: string
    createdAt?: Date | string
    incomeStream: IncomeStreamCreateNestedOneWithoutIncomeStreamTagsInput
    tag: TagCreateNestedOneWithoutIncomeStreamTagsInput
  }

  export type IncomeStreamTagUncheckedCreateInput = {
    id?: string
    incomeStreamId: string
    tagId: string
    createdAt?: Date | string
  }

  export type IncomeStreamTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomeStream?: IncomeStreamUpdateOneRequiredWithoutIncomeStreamTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutIncomeStreamTagsNestedInput
  }

  export type IncomeStreamTagUncheckedUpdateInput = {
    incomeStreamId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagCreateManyInput = {
    id?: string
    incomeStreamId: string
    tagId: string
    createdAt?: Date | string
  }

  export type IncomeStreamTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagUncheckedUpdateManyInput = {
    incomeStreamId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagCreateInput = {
    id?: string
    createdAt?: Date | string
    debt: DebtCreateNestedOneWithoutDebtTagsInput
    tag: TagCreateNestedOneWithoutDebtTagsInput
  }

  export type DebtTagUncheckedCreateInput = {
    id?: string
    debtId: string
    tagId: string
    createdAt?: Date | string
  }

  export type DebtTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneRequiredWithoutDebtTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutDebtTagsNestedInput
  }

  export type DebtTagUncheckedUpdateInput = {
    debtId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagCreateManyInput = {
    id?: string
    debtId: string
    tagId: string
    createdAt?: Date | string
  }

  export type DebtTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagUncheckedUpdateManyInput = {
    debtId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type IncomeStreamListRelationFilter = {
    every?: IncomeStreamWhereInput
    some?: IncomeStreamWhereInput
    none?: IncomeStreamWhereInput
  }

  export type DebtListRelationFilter = {
    every?: DebtWhereInput
    some?: DebtWhereInput
    none?: DebtWhereInput
  }

  export type DebtPaymentListRelationFilter = {
    every?: DebtPaymentWhereInput
    some?: DebtPaymentWhereInput
    none?: DebtPaymentWhereInput
  }

  export type SavingsGoalListRelationFilter = {
    every?: SavingsGoalWhereInput
    some?: SavingsGoalWhereInput
    none?: SavingsGoalWhereInput
  }

  export type MandatorySavingsNullableRelationFilter = {
    is?: MandatorySavingsWhereInput | null
    isNot?: MandatorySavingsWhereInput | null
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type PlaidItemListRelationFilter = {
    every?: PlaidItemWhereInput
    some?: PlaidItemWhereInput
    none?: PlaidItemWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type TagRuleListRelationFilter = {
    every?: TagRuleWhereInput
    some?: TagRuleWhereInput
    none?: TagRuleWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomeStreamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavingsGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaidItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PlaidItemNullableRelationFilter = {
    is?: PlaidItemWhereInput | null
    isNot?: PlaidItemWhereInput | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    plaidItemId?: SortOrder
    plaidAccountId?: SortOrder
    plaidMask?: SortOrder
    plaidType?: SortOrder
    plaidSubtype?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    plaidItemId?: SortOrder
    plaidAccountId?: SortOrder
    plaidMask?: SortOrder
    plaidType?: SortOrder
    plaidSubtype?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    plaidItemId?: SortOrder
    plaidAccountId?: SortOrder
    plaidMask?: SortOrder
    plaidType?: SortOrder
    plaidSubtype?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumCategoryKindFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryKind | EnumCategoryKindFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryKindFilter<$PrismaModel> | $Enums.CategoryKind
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCategoryKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryKind | EnumCategoryKindFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryKindWithAggregatesFilter<$PrismaModel> | $Enums.CategoryKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryKindFilter<$PrismaModel>
    _max?: NestedEnumCategoryKindFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TransactionTagListRelationFilter = {
    every?: TransactionTagWhereInput
    some?: TransactionTagWhereInput
    none?: TransactionTagWhereInput
  }

  export type TransactionTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    amountDollars?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    note?: SortOrder
    plaidTransactionId?: SortOrder
    pending?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    amountDollars?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    note?: SortOrder
    plaidTransactionId?: SortOrder
    pending?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    amountDollars?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    note?: SortOrder
    plaidTransactionId?: SortOrder
    pending?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumTagRuleMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleMatchType | EnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleMatchTypeFilter<$PrismaModel> | $Enums.TagRuleMatchType
  }

  export type EnumTagRuleSourceFieldFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleSourceField | EnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleSourceFieldFilter<$PrismaModel> | $Enums.TagRuleSourceField
  }

  export type TagRuleTagListRelationFilter = {
    every?: TagRuleTagWhereInput
    some?: TagRuleTagWhereInput
    none?: TagRuleTagWhereInput
  }

  export type TagRuleTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagRuleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    pattern?: SortOrder
    matchType?: SortOrder
    sourceField?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    pattern?: SortOrder
    matchType?: SortOrder
    sourceField?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagRuleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    pattern?: SortOrder
    matchType?: SortOrder
    sourceField?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTagRuleMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleMatchType | EnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagRuleMatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagRuleMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumTagRuleMatchTypeFilter<$PrismaModel>
  }

  export type EnumTagRuleSourceFieldWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleSourceField | EnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleSourceFieldWithAggregatesFilter<$PrismaModel> | $Enums.TagRuleSourceField
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagRuleSourceFieldFilter<$PrismaModel>
    _max?: NestedEnumTagRuleSourceFieldFilter<$PrismaModel>
  }

  export type EnumBudgetPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodFilter<$PrismaModel> | $Enums.BudgetPeriod
  }

  export type TagNullableRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    period?: SortOrder
    categoryId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    period?: SortOrder
    categoryId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    period?: SortOrder
    categoryId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type EnumBudgetPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel> | $Enums.BudgetPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetPeriodFilter<$PrismaModel>
    _max?: NestedEnumBudgetPeriodFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type EnumBillFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.BillFrequency | EnumBillFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumBillFrequencyFilter<$PrismaModel> | $Enums.BillFrequency
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    dueDate?: SortOrder
    frequency?: SortOrder
    isEssential?: SortOrder
    autopay?: SortOrder
    createdAt?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    dueDate?: SortOrder
    frequency?: SortOrder
    isEssential?: SortOrder
    autopay?: SortOrder
    createdAt?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    dueDate?: SortOrder
    frequency?: SortOrder
    isEssential?: SortOrder
    autopay?: SortOrder
    createdAt?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    amountDollars?: SortOrder
    dueDayOfMonth?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumBillFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillFrequency | EnumBillFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumBillFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.BillFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillFrequencyFilter<$PrismaModel>
    _max?: NestedEnumBillFrequencyFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumSubscriptionFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionFrequency | EnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionFrequencyFilter<$PrismaModel> | $Enums.SubscriptionFrequency
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
    frequency?: SortOrder
    cancelable?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
    frequency?: SortOrder
    cancelable?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
    frequency?: SortOrder
    cancelable?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    amountDollars?: SortOrder
    billingDayOfMonth?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumSubscriptionFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionFrequency | EnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionFrequencyFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionFrequencyFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type EnumIncomeCadenceFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCadence | EnumIncomeCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCadenceFilter<$PrismaModel> | $Enums.IncomeCadence
  }

  export type IncomeStreamTagListRelationFilter = {
    every?: IncomeStreamTagWhereInput
    some?: IncomeStreamTagWhereInput
    none?: IncomeStreamTagWhereInput
  }

  export type IncomeStreamTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomeStreamCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
    cadence?: SortOrder
    nextPayDate?: SortOrder
    createdAt?: SortOrder
  }

  export type IncomeStreamAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
  }

  export type IncomeStreamMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
    cadence?: SortOrder
    nextPayDate?: SortOrder
    createdAt?: SortOrder
  }

  export type IncomeStreamMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
    cadence?: SortOrder
    nextPayDate?: SortOrder
    createdAt?: SortOrder
  }

  export type IncomeStreamSumOrderByAggregateInput = {
    amountDollars?: SortOrder
    lastAmountDollars?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumIncomeCadenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCadence | EnumIncomeCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCadenceWithAggregatesFilter<$PrismaModel> | $Enums.IncomeCadence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeCadenceFilter<$PrismaModel>
    _max?: NestedEnumIncomeCadenceFilter<$PrismaModel>
  }

  export type DebtTagListRelationFilter = {
    every?: DebtTagWhereInput
    some?: DebtTagWhereInput
    none?: DebtTagWhereInput
  }

  export type DebtTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    estimatedPayoffDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtAvgOrderByAggregateInput = {
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
  }

  export type DebtMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    estimatedPayoffDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
    estimatedPayoffDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtSumOrderByAggregateInput = {
    principalDollars?: SortOrder
    aprBps?: SortOrder
    minPaymentDollars?: SortOrder
    estimatedMonthlyPaymentDollars?: SortOrder
    dueDayOfMonth?: SortOrder
  }

  export type EnumSavingsRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SavingsRuleType | EnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavingsRuleTypeFilter<$PrismaModel> | $Enums.SavingsRuleType
  }

  export type SavingsGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleType?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type SavingsGoalAvgOrderByAggregateInput = {
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
  }

  export type SavingsGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleType?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type SavingsGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleType?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type SavingsGoalSumOrderByAggregateInput = {
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    ruleValueBpsOrDollars?: SortOrder
    priority?: SortOrder
  }

  export type EnumSavingsRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SavingsRuleType | EnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavingsRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SavingsRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSavingsRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumSavingsRuleTypeFilter<$PrismaModel>
  }

  export type MandatorySavingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MandatorySavingsAvgOrderByAggregateInput = {
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
  }

  export type MandatorySavingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MandatorySavingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MandatorySavingsSumOrderByAggregateInput = {
    monthsToSave?: SortOrder
    targetDollars?: SortOrder
    currentDollars?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    milestonePct?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    milestonePct?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    milestonePct?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    milestonePct?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    milestonePct?: SortOrder
  }

  export type EnumPlanStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStrategy | EnumPlanStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanStrategyFilter<$PrismaModel> | $Enums.PlanStrategy
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type PlanItemListRelationFilter = {
    every?: PlanItemWhereInput
    some?: PlanItemWhereInput
    none?: PlanItemWhereInput
  }

  export type PlanItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    horizonMonths?: SortOrder
    startDate?: SortOrder
    rulesJson?: SortOrder
    summaryJson?: SortOrder
    warningsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    horizonMonths?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    horizonMonths?: SortOrder
    startDate?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    horizonMonths?: SortOrder
    startDate?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    horizonMonths?: SortOrder
  }

  export type EnumPlanStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStrategy | EnumPlanStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanStrategyWithAggregatesFilter<$PrismaModel> | $Enums.PlanStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanStrategyFilter<$PrismaModel>
    _max?: NestedEnumPlanStrategyFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPlanItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanItemType | EnumPlanItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanItemTypeFilter<$PrismaModel> | $Enums.PlanItemType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type PlanItemCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    amountDollars?: SortOrder
    notes?: SortOrder
    balanceSnapshotJson?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanItemAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type PlanItemMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    amountDollars?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanItemMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    amountDollars?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanItemSumOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type EnumPlanItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanItemType | EnumPlanItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanItemTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanItemTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DebtRelationFilter = {
    is?: DebtWhereInput
    isNot?: DebtWhereInput
  }

  export type DebtPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    debtId?: SortOrder
    amountDollars?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtPaymentAvgOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type DebtPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    debtId?: SortOrder
    amountDollars?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    debtId?: SortOrder
    amountDollars?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtPaymentSumOrderByAggregateInput = {
    amountDollars?: SortOrder
  }

  export type PlaidItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    accessTokenEncrypted?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    transactionsCursor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaidItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    accessTokenEncrypted?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    transactionsCursor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaidItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    accessTokenEncrypted?: SortOrder
    institutionId?: SortOrder
    institutionName?: SortOrder
    transactionsCursor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TagRuleRelationFilter = {
    is?: TagRuleWhereInput
    isNot?: TagRuleWhereInput
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TagRuleTagTagRuleIdTagIdCompoundUniqueInput = {
    tagRuleId: string
    tagId: string
  }

  export type TagRuleTagCountOrderByAggregateInput = {
    id?: SortOrder
    tagRuleId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TagRuleTagMaxOrderByAggregateInput = {
    id?: SortOrder
    tagRuleId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TagRuleTagMinOrderByAggregateInput = {
    id?: SortOrder
    tagRuleId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type TransactionTagTransactionIdTagIdCompoundUniqueInput = {
    transactionId: string
    tagId: string
  }

  export type TransactionTagCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionTagMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionTagMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type IncomeStreamRelationFilter = {
    is?: IncomeStreamWhereInput
    isNot?: IncomeStreamWhereInput
  }

  export type IncomeStreamTagIncomeStreamIdTagIdCompoundUniqueInput = {
    incomeStreamId: string
    tagId: string
  }

  export type IncomeStreamTagCountOrderByAggregateInput = {
    id?: SortOrder
    incomeStreamId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type IncomeStreamTagMaxOrderByAggregateInput = {
    id?: SortOrder
    incomeStreamId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type IncomeStreamTagMinOrderByAggregateInput = {
    id?: SortOrder
    incomeStreamId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtTagDebtIdTagIdCompoundUniqueInput = {
    debtId: string
    tagId: string
  }

  export type DebtTagCountOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtTagMaxOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtTagMinOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutUserInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type BillCreateNestedManyWithoutUserInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type IncomeStreamCreateNestedManyWithoutUserInput = {
    create?: XOR<IncomeStreamCreateWithoutUserInput, IncomeStreamUncheckedCreateWithoutUserInput> | IncomeStreamCreateWithoutUserInput[] | IncomeStreamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncomeStreamCreateOrConnectWithoutUserInput | IncomeStreamCreateOrConnectWithoutUserInput[]
    createMany?: IncomeStreamCreateManyUserInputEnvelope
    connect?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
  }

  export type DebtCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtCreateWithoutUserInput, DebtUncheckedCreateWithoutUserInput> | DebtCreateWithoutUserInput[] | DebtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutUserInput | DebtCreateOrConnectWithoutUserInput[]
    createMany?: DebtCreateManyUserInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type DebtPaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtPaymentCreateWithoutUserInput, DebtPaymentUncheckedCreateWithoutUserInput> | DebtPaymentCreateWithoutUserInput[] | DebtPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutUserInput | DebtPaymentCreateOrConnectWithoutUserInput[]
    createMany?: DebtPaymentCreateManyUserInputEnvelope
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
  }

  export type SavingsGoalCreateNestedManyWithoutUserInput = {
    create?: XOR<SavingsGoalCreateWithoutUserInput, SavingsGoalUncheckedCreateWithoutUserInput> | SavingsGoalCreateWithoutUserInput[] | SavingsGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavingsGoalCreateOrConnectWithoutUserInput | SavingsGoalCreateOrConnectWithoutUserInput[]
    createMany?: SavingsGoalCreateManyUserInputEnvelope
    connect?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
  }

  export type MandatorySavingsCreateNestedOneWithoutUserInput = {
    create?: XOR<MandatorySavingsCreateWithoutUserInput, MandatorySavingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MandatorySavingsCreateOrConnectWithoutUserInput
    connect?: MandatorySavingsWhereUniqueInput
  }

  export type PlanCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type PlaidItemCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaidItemCreateWithoutUserInput, PlaidItemUncheckedCreateWithoutUserInput> | PlaidItemCreateWithoutUserInput[] | PlaidItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaidItemCreateOrConnectWithoutUserInput | PlaidItemCreateOrConnectWithoutUserInput[]
    createMany?: PlaidItemCreateManyUserInputEnvelope
    connect?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type TagRuleCreateNestedManyWithoutUserInput = {
    create?: XOR<TagRuleCreateWithoutUserInput, TagRuleUncheckedCreateWithoutUserInput> | TagRuleCreateWithoutUserInput[] | TagRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagRuleCreateOrConnectWithoutUserInput | TagRuleCreateOrConnectWithoutUserInput[]
    createMany?: TagRuleCreateManyUserInputEnvelope
    connect?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type IncomeStreamUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IncomeStreamCreateWithoutUserInput, IncomeStreamUncheckedCreateWithoutUserInput> | IncomeStreamCreateWithoutUserInput[] | IncomeStreamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncomeStreamCreateOrConnectWithoutUserInput | IncomeStreamCreateOrConnectWithoutUserInput[]
    createMany?: IncomeStreamCreateManyUserInputEnvelope
    connect?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
  }

  export type DebtUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtCreateWithoutUserInput, DebtUncheckedCreateWithoutUserInput> | DebtCreateWithoutUserInput[] | DebtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutUserInput | DebtCreateOrConnectWithoutUserInput[]
    createMany?: DebtCreateManyUserInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type DebtPaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtPaymentCreateWithoutUserInput, DebtPaymentUncheckedCreateWithoutUserInput> | DebtPaymentCreateWithoutUserInput[] | DebtPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutUserInput | DebtPaymentCreateOrConnectWithoutUserInput[]
    createMany?: DebtPaymentCreateManyUserInputEnvelope
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
  }

  export type SavingsGoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavingsGoalCreateWithoutUserInput, SavingsGoalUncheckedCreateWithoutUserInput> | SavingsGoalCreateWithoutUserInput[] | SavingsGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavingsGoalCreateOrConnectWithoutUserInput | SavingsGoalCreateOrConnectWithoutUserInput[]
    createMany?: SavingsGoalCreateManyUserInputEnvelope
    connect?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
  }

  export type MandatorySavingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MandatorySavingsCreateWithoutUserInput, MandatorySavingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MandatorySavingsCreateOrConnectWithoutUserInput
    connect?: MandatorySavingsWhereUniqueInput
  }

  export type PlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type PlaidItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaidItemCreateWithoutUserInput, PlaidItemUncheckedCreateWithoutUserInput> | PlaidItemCreateWithoutUserInput[] | PlaidItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaidItemCreateOrConnectWithoutUserInput | PlaidItemCreateOrConnectWithoutUserInput[]
    createMany?: PlaidItemCreateManyUserInputEnvelope
    connect?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type TagRuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TagRuleCreateWithoutUserInput, TagRuleUncheckedCreateWithoutUserInput> | TagRuleCreateWithoutUserInput[] | TagRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagRuleCreateOrConnectWithoutUserInput | TagRuleCreateOrConnectWithoutUserInput[]
    createMany?: TagRuleCreateManyUserInputEnvelope
    connect?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutUserInput | CategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutUserInput | CategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutUserInput | CategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutUserNestedInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutUserInput | TagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutUserInput | TagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TagUpdateManyWithWhereWithoutUserInput | TagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type BillUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutUserInput | BillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutUserInput | BillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillUpdateManyWithWhereWithoutUserInput | BillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type IncomeStreamUpdateManyWithoutUserNestedInput = {
    create?: XOR<IncomeStreamCreateWithoutUserInput, IncomeStreamUncheckedCreateWithoutUserInput> | IncomeStreamCreateWithoutUserInput[] | IncomeStreamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncomeStreamCreateOrConnectWithoutUserInput | IncomeStreamCreateOrConnectWithoutUserInput[]
    upsert?: IncomeStreamUpsertWithWhereUniqueWithoutUserInput | IncomeStreamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IncomeStreamCreateManyUserInputEnvelope
    set?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    disconnect?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    delete?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    connect?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    update?: IncomeStreamUpdateWithWhereUniqueWithoutUserInput | IncomeStreamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IncomeStreamUpdateManyWithWhereWithoutUserInput | IncomeStreamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IncomeStreamScalarWhereInput | IncomeStreamScalarWhereInput[]
  }

  export type DebtUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtCreateWithoutUserInput, DebtUncheckedCreateWithoutUserInput> | DebtCreateWithoutUserInput[] | DebtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutUserInput | DebtCreateOrConnectWithoutUserInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutUserInput | DebtUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtCreateManyUserInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutUserInput | DebtUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutUserInput | DebtUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type DebtPaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtPaymentCreateWithoutUserInput, DebtPaymentUncheckedCreateWithoutUserInput> | DebtPaymentCreateWithoutUserInput[] | DebtPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutUserInput | DebtPaymentCreateOrConnectWithoutUserInput[]
    upsert?: DebtPaymentUpsertWithWhereUniqueWithoutUserInput | DebtPaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtPaymentCreateManyUserInputEnvelope
    set?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    disconnect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    delete?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    update?: DebtPaymentUpdateWithWhereUniqueWithoutUserInput | DebtPaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtPaymentUpdateManyWithWhereWithoutUserInput | DebtPaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
  }

  export type SavingsGoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavingsGoalCreateWithoutUserInput, SavingsGoalUncheckedCreateWithoutUserInput> | SavingsGoalCreateWithoutUserInput[] | SavingsGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavingsGoalCreateOrConnectWithoutUserInput | SavingsGoalCreateOrConnectWithoutUserInput[]
    upsert?: SavingsGoalUpsertWithWhereUniqueWithoutUserInput | SavingsGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavingsGoalCreateManyUserInputEnvelope
    set?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    disconnect?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    delete?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    connect?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    update?: SavingsGoalUpdateWithWhereUniqueWithoutUserInput | SavingsGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavingsGoalUpdateManyWithWhereWithoutUserInput | SavingsGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavingsGoalScalarWhereInput | SavingsGoalScalarWhereInput[]
  }

  export type MandatorySavingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<MandatorySavingsCreateWithoutUserInput, MandatorySavingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MandatorySavingsCreateOrConnectWithoutUserInput
    upsert?: MandatorySavingsUpsertWithoutUserInput
    disconnect?: MandatorySavingsWhereInput | boolean
    delete?: MandatorySavingsWhereInput | boolean
    connect?: MandatorySavingsWhereUniqueInput
    update?: XOR<XOR<MandatorySavingsUpdateToOneWithWhereWithoutUserInput, MandatorySavingsUpdateWithoutUserInput>, MandatorySavingsUncheckedUpdateWithoutUserInput>
  }

  export type PlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutUserInput | PlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutUserInput | PlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutUserInput | PlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type PlaidItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaidItemCreateWithoutUserInput, PlaidItemUncheckedCreateWithoutUserInput> | PlaidItemCreateWithoutUserInput[] | PlaidItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaidItemCreateOrConnectWithoutUserInput | PlaidItemCreateOrConnectWithoutUserInput[]
    upsert?: PlaidItemUpsertWithWhereUniqueWithoutUserInput | PlaidItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaidItemCreateManyUserInputEnvelope
    set?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    disconnect?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    delete?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    connect?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    update?: PlaidItemUpdateWithWhereUniqueWithoutUserInput | PlaidItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaidItemUpdateManyWithWhereWithoutUserInput | PlaidItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaidItemScalarWhereInput | PlaidItemScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type TagRuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<TagRuleCreateWithoutUserInput, TagRuleUncheckedCreateWithoutUserInput> | TagRuleCreateWithoutUserInput[] | TagRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagRuleCreateOrConnectWithoutUserInput | TagRuleCreateOrConnectWithoutUserInput[]
    upsert?: TagRuleUpsertWithWhereUniqueWithoutUserInput | TagRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TagRuleCreateManyUserInputEnvelope
    set?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    disconnect?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    delete?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    connect?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    update?: TagRuleUpdateWithWhereUniqueWithoutUserInput | TagRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TagRuleUpdateManyWithWhereWithoutUserInput | TagRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TagRuleScalarWhereInput | TagRuleScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutUserInput | CategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutUserInput | CategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutUserInput | CategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput> | TagCreateWithoutUserInput[] | TagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagCreateOrConnectWithoutUserInput | TagCreateOrConnectWithoutUserInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutUserInput | TagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TagCreateManyUserInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutUserInput | TagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TagUpdateManyWithWhereWithoutUserInput | TagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutUserInput | BillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutUserInput | BillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillUpdateManyWithWhereWithoutUserInput | BillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type IncomeStreamUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IncomeStreamCreateWithoutUserInput, IncomeStreamUncheckedCreateWithoutUserInput> | IncomeStreamCreateWithoutUserInput[] | IncomeStreamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncomeStreamCreateOrConnectWithoutUserInput | IncomeStreamCreateOrConnectWithoutUserInput[]
    upsert?: IncomeStreamUpsertWithWhereUniqueWithoutUserInput | IncomeStreamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IncomeStreamCreateManyUserInputEnvelope
    set?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    disconnect?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    delete?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    connect?: IncomeStreamWhereUniqueInput | IncomeStreamWhereUniqueInput[]
    update?: IncomeStreamUpdateWithWhereUniqueWithoutUserInput | IncomeStreamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IncomeStreamUpdateManyWithWhereWithoutUserInput | IncomeStreamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IncomeStreamScalarWhereInput | IncomeStreamScalarWhereInput[]
  }

  export type DebtUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtCreateWithoutUserInput, DebtUncheckedCreateWithoutUserInput> | DebtCreateWithoutUserInput[] | DebtUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutUserInput | DebtCreateOrConnectWithoutUserInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutUserInput | DebtUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtCreateManyUserInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutUserInput | DebtUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutUserInput | DebtUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type DebtPaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtPaymentCreateWithoutUserInput, DebtPaymentUncheckedCreateWithoutUserInput> | DebtPaymentCreateWithoutUserInput[] | DebtPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutUserInput | DebtPaymentCreateOrConnectWithoutUserInput[]
    upsert?: DebtPaymentUpsertWithWhereUniqueWithoutUserInput | DebtPaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtPaymentCreateManyUserInputEnvelope
    set?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    disconnect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    delete?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    update?: DebtPaymentUpdateWithWhereUniqueWithoutUserInput | DebtPaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtPaymentUpdateManyWithWhereWithoutUserInput | DebtPaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
  }

  export type SavingsGoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavingsGoalCreateWithoutUserInput, SavingsGoalUncheckedCreateWithoutUserInput> | SavingsGoalCreateWithoutUserInput[] | SavingsGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavingsGoalCreateOrConnectWithoutUserInput | SavingsGoalCreateOrConnectWithoutUserInput[]
    upsert?: SavingsGoalUpsertWithWhereUniqueWithoutUserInput | SavingsGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavingsGoalCreateManyUserInputEnvelope
    set?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    disconnect?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    delete?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    connect?: SavingsGoalWhereUniqueInput | SavingsGoalWhereUniqueInput[]
    update?: SavingsGoalUpdateWithWhereUniqueWithoutUserInput | SavingsGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavingsGoalUpdateManyWithWhereWithoutUserInput | SavingsGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavingsGoalScalarWhereInput | SavingsGoalScalarWhereInput[]
  }

  export type MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MandatorySavingsCreateWithoutUserInput, MandatorySavingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MandatorySavingsCreateOrConnectWithoutUserInput
    upsert?: MandatorySavingsUpsertWithoutUserInput
    disconnect?: MandatorySavingsWhereInput | boolean
    delete?: MandatorySavingsWhereInput | boolean
    connect?: MandatorySavingsWhereUniqueInput
    update?: XOR<XOR<MandatorySavingsUpdateToOneWithWhereWithoutUserInput, MandatorySavingsUpdateWithoutUserInput>, MandatorySavingsUncheckedUpdateWithoutUserInput>
  }

  export type PlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutUserInput | PlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutUserInput | PlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutUserInput | PlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type PlaidItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaidItemCreateWithoutUserInput, PlaidItemUncheckedCreateWithoutUserInput> | PlaidItemCreateWithoutUserInput[] | PlaidItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaidItemCreateOrConnectWithoutUserInput | PlaidItemCreateOrConnectWithoutUserInput[]
    upsert?: PlaidItemUpsertWithWhereUniqueWithoutUserInput | PlaidItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaidItemCreateManyUserInputEnvelope
    set?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    disconnect?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    delete?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    connect?: PlaidItemWhereUniqueInput | PlaidItemWhereUniqueInput[]
    update?: PlaidItemUpdateWithWhereUniqueWithoutUserInput | PlaidItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaidItemUpdateManyWithWhereWithoutUserInput | PlaidItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaidItemScalarWhereInput | PlaidItemScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type TagRuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TagRuleCreateWithoutUserInput, TagRuleUncheckedCreateWithoutUserInput> | TagRuleCreateWithoutUserInput[] | TagRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TagRuleCreateOrConnectWithoutUserInput | TagRuleCreateOrConnectWithoutUserInput[]
    upsert?: TagRuleUpsertWithWhereUniqueWithoutUserInput | TagRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TagRuleCreateManyUserInputEnvelope
    set?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    disconnect?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    delete?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    connect?: TagRuleWhereUniqueInput | TagRuleWhereUniqueInput[]
    update?: TagRuleUpdateWithWhereUniqueWithoutUserInput | TagRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TagRuleUpdateManyWithWhereWithoutUserInput | TagRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TagRuleScalarWhereInput | TagRuleScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type PlaidItemCreateNestedOneWithoutAccountsInput = {
    create?: XOR<PlaidItemCreateWithoutAccountsInput, PlaidItemUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: PlaidItemCreateOrConnectWithoutAccountsInput
    connect?: PlaidItemWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type PlaidItemUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<PlaidItemCreateWithoutAccountsInput, PlaidItemUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: PlaidItemCreateOrConnectWithoutAccountsInput
    upsert?: PlaidItemUpsertWithoutAccountsInput
    disconnect?: boolean
    delete?: PlaidItemWhereInput | boolean
    connect?: PlaidItemWhereUniqueInput
    update?: XOR<XOR<PlaidItemUpdateToOneWithWhereWithoutAccountsInput, PlaidItemUpdateWithoutAccountsInput>, PlaidItemUncheckedUpdateWithoutAccountsInput>
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BudgetCreateWithoutCategoryInput, BudgetUncheckedCreateWithoutCategoryInput> | BudgetCreateWithoutCategoryInput[] | BudgetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoryInput | BudgetCreateOrConnectWithoutCategoryInput[]
    createMany?: BudgetCreateManyCategoryInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BudgetCreateWithoutCategoryInput, BudgetUncheckedCreateWithoutCategoryInput> | BudgetCreateWithoutCategoryInput[] | BudgetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoryInput | BudgetCreateOrConnectWithoutCategoryInput[]
    createMany?: BudgetCreateManyCategoryInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type EnumCategoryKindFieldUpdateOperationsInput = {
    set?: $Enums.CategoryKind
  }

  export type UserUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    upsert?: UserUpsertWithoutCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCategoriesInput, UserUpdateWithoutCategoriesInput>, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type TransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BudgetCreateWithoutCategoryInput, BudgetUncheckedCreateWithoutCategoryInput> | BudgetCreateWithoutCategoryInput[] | BudgetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoryInput | BudgetCreateOrConnectWithoutCategoryInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutCategoryInput | BudgetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BudgetCreateManyCategoryInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutCategoryInput | BudgetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutCategoryInput | BudgetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BudgetCreateWithoutCategoryInput, BudgetUncheckedCreateWithoutCategoryInput> | BudgetCreateWithoutCategoryInput[] | BudgetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoryInput | BudgetCreateOrConnectWithoutCategoryInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutCategoryInput | BudgetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BudgetCreateManyCategoryInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutCategoryInput | BudgetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutCategoryInput | BudgetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TransactionTagCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
  }

  export type TransactionTagUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    upsert?: AccountUpsertWithoutTransactionsInput
    disconnect?: boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsInput, AccountUpdateWithoutTransactionsInput>, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type CategoryUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionsInput
    upsert?: CategoryUpsertWithoutTransactionsInput
    disconnect?: boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTransactionsInput, CategoryUpdateWithoutTransactionsInput>, CategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionTagUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionTagUpsertWithWhereUniqueWithoutTransactionInput | TransactionTagUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    set?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    disconnect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    delete?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    update?: TransactionTagUpdateWithWhereUniqueWithoutTransactionInput | TransactionTagUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionTagUpdateManyWithWhereWithoutTransactionInput | TransactionTagUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
  }

  export type TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionTagUpsertWithWhereUniqueWithoutTransactionInput | TransactionTagUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    set?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    disconnect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    delete?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    update?: TransactionTagUpdateWithWhereUniqueWithoutTransactionInput | TransactionTagUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionTagUpdateManyWithWhereWithoutTransactionInput | TransactionTagUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTagRulesInput = {
    create?: XOR<UserCreateWithoutTagRulesInput, UserUncheckedCreateWithoutTagRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagRulesInput
    connect?: UserWhereUniqueInput
  }

  export type TagRuleTagCreateNestedManyWithoutTagRuleInput = {
    create?: XOR<TagRuleTagCreateWithoutTagRuleInput, TagRuleTagUncheckedCreateWithoutTagRuleInput> | TagRuleTagCreateWithoutTagRuleInput[] | TagRuleTagUncheckedCreateWithoutTagRuleInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagRuleInput | TagRuleTagCreateOrConnectWithoutTagRuleInput[]
    createMany?: TagRuleTagCreateManyTagRuleInputEnvelope
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
  }

  export type TagRuleTagUncheckedCreateNestedManyWithoutTagRuleInput = {
    create?: XOR<TagRuleTagCreateWithoutTagRuleInput, TagRuleTagUncheckedCreateWithoutTagRuleInput> | TagRuleTagCreateWithoutTagRuleInput[] | TagRuleTagUncheckedCreateWithoutTagRuleInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagRuleInput | TagRuleTagCreateOrConnectWithoutTagRuleInput[]
    createMany?: TagRuleTagCreateManyTagRuleInputEnvelope
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
  }

  export type EnumTagRuleMatchTypeFieldUpdateOperationsInput = {
    set?: $Enums.TagRuleMatchType
  }

  export type EnumTagRuleSourceFieldFieldUpdateOperationsInput = {
    set?: $Enums.TagRuleSourceField
  }

  export type UserUpdateOneRequiredWithoutTagRulesNestedInput = {
    create?: XOR<UserCreateWithoutTagRulesInput, UserUncheckedCreateWithoutTagRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagRulesInput
    upsert?: UserUpsertWithoutTagRulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTagRulesInput, UserUpdateWithoutTagRulesInput>, UserUncheckedUpdateWithoutTagRulesInput>
  }

  export type TagRuleTagUpdateManyWithoutTagRuleNestedInput = {
    create?: XOR<TagRuleTagCreateWithoutTagRuleInput, TagRuleTagUncheckedCreateWithoutTagRuleInput> | TagRuleTagCreateWithoutTagRuleInput[] | TagRuleTagUncheckedCreateWithoutTagRuleInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagRuleInput | TagRuleTagCreateOrConnectWithoutTagRuleInput[]
    upsert?: TagRuleTagUpsertWithWhereUniqueWithoutTagRuleInput | TagRuleTagUpsertWithWhereUniqueWithoutTagRuleInput[]
    createMany?: TagRuleTagCreateManyTagRuleInputEnvelope
    set?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    disconnect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    delete?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    update?: TagRuleTagUpdateWithWhereUniqueWithoutTagRuleInput | TagRuleTagUpdateWithWhereUniqueWithoutTagRuleInput[]
    updateMany?: TagRuleTagUpdateManyWithWhereWithoutTagRuleInput | TagRuleTagUpdateManyWithWhereWithoutTagRuleInput[]
    deleteMany?: TagRuleTagScalarWhereInput | TagRuleTagScalarWhereInput[]
  }

  export type TagRuleTagUncheckedUpdateManyWithoutTagRuleNestedInput = {
    create?: XOR<TagRuleTagCreateWithoutTagRuleInput, TagRuleTagUncheckedCreateWithoutTagRuleInput> | TagRuleTagCreateWithoutTagRuleInput[] | TagRuleTagUncheckedCreateWithoutTagRuleInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagRuleInput | TagRuleTagCreateOrConnectWithoutTagRuleInput[]
    upsert?: TagRuleTagUpsertWithWhereUniqueWithoutTagRuleInput | TagRuleTagUpsertWithWhereUniqueWithoutTagRuleInput[]
    createMany?: TagRuleTagCreateManyTagRuleInputEnvelope
    set?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    disconnect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    delete?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    update?: TagRuleTagUpdateWithWhereUniqueWithoutTagRuleInput | TagRuleTagUpdateWithWhereUniqueWithoutTagRuleInput[]
    updateMany?: TagRuleTagUpdateManyWithWhereWithoutTagRuleInput | TagRuleTagUpdateManyWithWhereWithoutTagRuleInput[]
    deleteMany?: TagRuleTagScalarWhereInput | TagRuleTagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBudgetsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<TagCreateWithoutBudgetsInput, TagUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: TagCreateOrConnectWithoutBudgetsInput
    connect?: TagWhereUniqueInput
  }

  export type EnumBudgetPeriodFieldUpdateOperationsInput = {
    set?: $Enums.BudgetPeriod
  }

  export type UserUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    upsert?: UserUpsertWithoutBudgetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBudgetsInput, UserUpdateWithoutBudgetsInput>, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type CategoryUpdateOneWithoutBudgetsNestedInput = {
    create?: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBudgetsInput
    upsert?: CategoryUpsertWithoutBudgetsInput
    disconnect?: boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBudgetsInput, CategoryUpdateWithoutBudgetsInput>, CategoryUncheckedUpdateWithoutBudgetsInput>
  }

  export type TagUpdateOneWithoutBudgetsNestedInput = {
    create?: XOR<TagCreateWithoutBudgetsInput, TagUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: TagCreateOrConnectWithoutBudgetsInput
    upsert?: TagUpsertWithoutBudgetsInput
    disconnect?: boolean
    delete?: TagWhereInput | boolean
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutBudgetsInput, TagUpdateWithoutBudgetsInput>, TagUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserCreateNestedOneWithoutBillsInput = {
    create?: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EnumBillFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.BillFrequency
  }

  export type UserUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillsInput
    upsert?: UserUpsertWithoutBillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBillsInput, UserUpdateWithoutBillsInput>, UserUncheckedUpdateWithoutBillsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSubscriptionFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionFrequency
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutIncomeStreamsInput = {
    create?: XOR<UserCreateWithoutIncomeStreamsInput, UserUncheckedCreateWithoutIncomeStreamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomeStreamsInput
    connect?: UserWhereUniqueInput
  }

  export type IncomeStreamTagCreateNestedManyWithoutIncomeStreamInput = {
    create?: XOR<IncomeStreamTagCreateWithoutIncomeStreamInput, IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput> | IncomeStreamTagCreateWithoutIncomeStreamInput[] | IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput | IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput[]
    createMany?: IncomeStreamTagCreateManyIncomeStreamInputEnvelope
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
  }

  export type IncomeStreamTagUncheckedCreateNestedManyWithoutIncomeStreamInput = {
    create?: XOR<IncomeStreamTagCreateWithoutIncomeStreamInput, IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput> | IncomeStreamTagCreateWithoutIncomeStreamInput[] | IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput | IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput[]
    createMany?: IncomeStreamTagCreateManyIncomeStreamInputEnvelope
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EnumIncomeCadenceFieldUpdateOperationsInput = {
    set?: $Enums.IncomeCadence
  }

  export type UserUpdateOneRequiredWithoutIncomeStreamsNestedInput = {
    create?: XOR<UserCreateWithoutIncomeStreamsInput, UserUncheckedCreateWithoutIncomeStreamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomeStreamsInput
    upsert?: UserUpsertWithoutIncomeStreamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIncomeStreamsInput, UserUpdateWithoutIncomeStreamsInput>, UserUncheckedUpdateWithoutIncomeStreamsInput>
  }

  export type IncomeStreamTagUpdateManyWithoutIncomeStreamNestedInput = {
    create?: XOR<IncomeStreamTagCreateWithoutIncomeStreamInput, IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput> | IncomeStreamTagCreateWithoutIncomeStreamInput[] | IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput | IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput[]
    upsert?: IncomeStreamTagUpsertWithWhereUniqueWithoutIncomeStreamInput | IncomeStreamTagUpsertWithWhereUniqueWithoutIncomeStreamInput[]
    createMany?: IncomeStreamTagCreateManyIncomeStreamInputEnvelope
    set?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    disconnect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    delete?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    update?: IncomeStreamTagUpdateWithWhereUniqueWithoutIncomeStreamInput | IncomeStreamTagUpdateWithWhereUniqueWithoutIncomeStreamInput[]
    updateMany?: IncomeStreamTagUpdateManyWithWhereWithoutIncomeStreamInput | IncomeStreamTagUpdateManyWithWhereWithoutIncomeStreamInput[]
    deleteMany?: IncomeStreamTagScalarWhereInput | IncomeStreamTagScalarWhereInput[]
  }

  export type IncomeStreamTagUncheckedUpdateManyWithoutIncomeStreamNestedInput = {
    create?: XOR<IncomeStreamTagCreateWithoutIncomeStreamInput, IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput> | IncomeStreamTagCreateWithoutIncomeStreamInput[] | IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput | IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput[]
    upsert?: IncomeStreamTagUpsertWithWhereUniqueWithoutIncomeStreamInput | IncomeStreamTagUpsertWithWhereUniqueWithoutIncomeStreamInput[]
    createMany?: IncomeStreamTagCreateManyIncomeStreamInputEnvelope
    set?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    disconnect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    delete?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    update?: IncomeStreamTagUpdateWithWhereUniqueWithoutIncomeStreamInput | IncomeStreamTagUpdateWithWhereUniqueWithoutIncomeStreamInput[]
    updateMany?: IncomeStreamTagUpdateManyWithWhereWithoutIncomeStreamInput | IncomeStreamTagUpdateManyWithWhereWithoutIncomeStreamInput[]
    deleteMany?: IncomeStreamTagScalarWhereInput | IncomeStreamTagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDebtsInput = {
    create?: XOR<UserCreateWithoutDebtsInput, UserUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtPaymentCreateNestedManyWithoutDebtInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
  }

  export type DebtTagCreateNestedManyWithoutDebtInput = {
    create?: XOR<DebtTagCreateWithoutDebtInput, DebtTagUncheckedCreateWithoutDebtInput> | DebtTagCreateWithoutDebtInput[] | DebtTagUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutDebtInput | DebtTagCreateOrConnectWithoutDebtInput[]
    createMany?: DebtTagCreateManyDebtInputEnvelope
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
  }

  export type DebtPaymentUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
  }

  export type DebtTagUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<DebtTagCreateWithoutDebtInput, DebtTagUncheckedCreateWithoutDebtInput> | DebtTagCreateWithoutDebtInput[] | DebtTagUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutDebtInput | DebtTagCreateOrConnectWithoutDebtInput[]
    createMany?: DebtTagCreateManyDebtInputEnvelope
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDebtsNestedInput = {
    create?: XOR<UserCreateWithoutDebtsInput, UserUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtsInput
    upsert?: UserUpsertWithoutDebtsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtsInput, UserUpdateWithoutDebtsInput>, UserUncheckedUpdateWithoutDebtsInput>
  }

  export type DebtPaymentUpdateManyWithoutDebtNestedInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    upsert?: DebtPaymentUpsertWithWhereUniqueWithoutDebtInput | DebtPaymentUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    set?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    disconnect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    delete?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    update?: DebtPaymentUpdateWithWhereUniqueWithoutDebtInput | DebtPaymentUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: DebtPaymentUpdateManyWithWhereWithoutDebtInput | DebtPaymentUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
  }

  export type DebtTagUpdateManyWithoutDebtNestedInput = {
    create?: XOR<DebtTagCreateWithoutDebtInput, DebtTagUncheckedCreateWithoutDebtInput> | DebtTagCreateWithoutDebtInput[] | DebtTagUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutDebtInput | DebtTagCreateOrConnectWithoutDebtInput[]
    upsert?: DebtTagUpsertWithWhereUniqueWithoutDebtInput | DebtTagUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: DebtTagCreateManyDebtInputEnvelope
    set?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    disconnect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    delete?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    update?: DebtTagUpdateWithWhereUniqueWithoutDebtInput | DebtTagUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: DebtTagUpdateManyWithWhereWithoutDebtInput | DebtTagUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: DebtTagScalarWhereInput | DebtTagScalarWhereInput[]
  }

  export type DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    upsert?: DebtPaymentUpsertWithWhereUniqueWithoutDebtInput | DebtPaymentUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    set?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    disconnect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    delete?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    update?: DebtPaymentUpdateWithWhereUniqueWithoutDebtInput | DebtPaymentUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: DebtPaymentUpdateManyWithWhereWithoutDebtInput | DebtPaymentUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
  }

  export type DebtTagUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<DebtTagCreateWithoutDebtInput, DebtTagUncheckedCreateWithoutDebtInput> | DebtTagCreateWithoutDebtInput[] | DebtTagUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutDebtInput | DebtTagCreateOrConnectWithoutDebtInput[]
    upsert?: DebtTagUpsertWithWhereUniqueWithoutDebtInput | DebtTagUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: DebtTagCreateManyDebtInputEnvelope
    set?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    disconnect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    delete?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    update?: DebtTagUpdateWithWhereUniqueWithoutDebtInput | DebtTagUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: DebtTagUpdateManyWithWhereWithoutDebtInput | DebtTagUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: DebtTagScalarWhereInput | DebtTagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSavingsGoalsInput = {
    create?: XOR<UserCreateWithoutSavingsGoalsInput, UserUncheckedCreateWithoutSavingsGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavingsGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSavingsRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.SavingsRuleType
  }

  export type UserUpdateOneRequiredWithoutSavingsGoalsNestedInput = {
    create?: XOR<UserCreateWithoutSavingsGoalsInput, UserUncheckedCreateWithoutSavingsGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavingsGoalsInput
    upsert?: UserUpsertWithoutSavingsGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavingsGoalsInput, UserUpdateWithoutSavingsGoalsInput>, UserUncheckedUpdateWithoutSavingsGoalsInput>
  }

  export type UserCreateNestedOneWithoutMandatorySavingsInput = {
    create?: XOR<UserCreateWithoutMandatorySavingsInput, UserUncheckedCreateWithoutMandatorySavingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMandatorySavingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMandatorySavingsNestedInput = {
    create?: XOR<UserCreateWithoutMandatorySavingsInput, UserUncheckedCreateWithoutMandatorySavingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMandatorySavingsInput
    upsert?: UserUpsertWithoutMandatorySavingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMandatorySavingsInput, UserUpdateWithoutMandatorySavingsInput>, UserUncheckedUpdateWithoutMandatorySavingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPlansInput = {
    create?: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlansInput
    connect?: UserWhereUniqueInput
  }

  export type PlanItemCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanItemCreateWithoutPlanInput, PlanItemUncheckedCreateWithoutPlanInput> | PlanItemCreateWithoutPlanInput[] | PlanItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanItemCreateOrConnectWithoutPlanInput | PlanItemCreateOrConnectWithoutPlanInput[]
    createMany?: PlanItemCreateManyPlanInputEnvelope
    connect?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
  }

  export type PlanItemUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanItemCreateWithoutPlanInput, PlanItemUncheckedCreateWithoutPlanInput> | PlanItemCreateWithoutPlanInput[] | PlanItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanItemCreateOrConnectWithoutPlanInput | PlanItemCreateOrConnectWithoutPlanInput[]
    createMany?: PlanItemCreateManyPlanInputEnvelope
    connect?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
  }

  export type EnumPlanStrategyFieldUpdateOperationsInput = {
    set?: $Enums.PlanStrategy
  }

  export type UserUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlansInput
    upsert?: UserUpsertWithoutPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlansInput, UserUpdateWithoutPlansInput>, UserUncheckedUpdateWithoutPlansInput>
  }

  export type PlanItemUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanItemCreateWithoutPlanInput, PlanItemUncheckedCreateWithoutPlanInput> | PlanItemCreateWithoutPlanInput[] | PlanItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanItemCreateOrConnectWithoutPlanInput | PlanItemCreateOrConnectWithoutPlanInput[]
    upsert?: PlanItemUpsertWithWhereUniqueWithoutPlanInput | PlanItemUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanItemCreateManyPlanInputEnvelope
    set?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    disconnect?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    delete?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    connect?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    update?: PlanItemUpdateWithWhereUniqueWithoutPlanInput | PlanItemUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanItemUpdateManyWithWhereWithoutPlanInput | PlanItemUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanItemScalarWhereInput | PlanItemScalarWhereInput[]
  }

  export type PlanItemUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanItemCreateWithoutPlanInput, PlanItemUncheckedCreateWithoutPlanInput> | PlanItemCreateWithoutPlanInput[] | PlanItemUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanItemCreateOrConnectWithoutPlanInput | PlanItemCreateOrConnectWithoutPlanInput[]
    upsert?: PlanItemUpsertWithWhereUniqueWithoutPlanInput | PlanItemUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanItemCreateManyPlanInputEnvelope
    set?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    disconnect?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    delete?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    connect?: PlanItemWhereUniqueInput | PlanItemWhereUniqueInput[]
    update?: PlanItemUpdateWithWhereUniqueWithoutPlanInput | PlanItemUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanItemUpdateManyWithWhereWithoutPlanInput | PlanItemUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanItemScalarWhereInput | PlanItemScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutItemsInput = {
    create?: XOR<PlanCreateWithoutItemsInput, PlanUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutItemsInput
    connect?: PlanWhereUniqueInput
  }

  export type EnumPlanItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanItemType
  }

  export type PlanUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PlanCreateWithoutItemsInput, PlanUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutItemsInput
    upsert?: PlanUpsertWithoutItemsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutItemsInput, PlanUpdateWithoutItemsInput>, PlanUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutDebtPaymentsInput = {
    create?: XOR<UserCreateWithoutDebtPaymentsInput, UserUncheckedCreateWithoutDebtPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutPaymentsInput
    connect?: DebtWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDebtPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutDebtPaymentsInput, UserUncheckedCreateWithoutDebtPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtPaymentsInput
    upsert?: UserUpsertWithoutDebtPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtPaymentsInput, UserUpdateWithoutDebtPaymentsInput>, UserUncheckedUpdateWithoutDebtPaymentsInput>
  }

  export type DebtUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutPaymentsInput
    upsert?: DebtUpsertWithoutPaymentsInput
    connect?: DebtWhereUniqueInput
    update?: XOR<XOR<DebtUpdateToOneWithWhereWithoutPaymentsInput, DebtUpdateWithoutPaymentsInput>, DebtUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutPlaidItemsInput = {
    create?: XOR<UserCreateWithoutPlaidItemsInput, UserUncheckedCreateWithoutPlaidItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaidItemsInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutPlaidItemInput = {
    create?: XOR<AccountCreateWithoutPlaidItemInput, AccountUncheckedCreateWithoutPlaidItemInput> | AccountCreateWithoutPlaidItemInput[] | AccountUncheckedCreateWithoutPlaidItemInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutPlaidItemInput | AccountCreateOrConnectWithoutPlaidItemInput[]
    createMany?: AccountCreateManyPlaidItemInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutPlaidItemInput = {
    create?: XOR<AccountCreateWithoutPlaidItemInput, AccountUncheckedCreateWithoutPlaidItemInput> | AccountCreateWithoutPlaidItemInput[] | AccountUncheckedCreateWithoutPlaidItemInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutPlaidItemInput | AccountCreateOrConnectWithoutPlaidItemInput[]
    createMany?: AccountCreateManyPlaidItemInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPlaidItemsNestedInput = {
    create?: XOR<UserCreateWithoutPlaidItemsInput, UserUncheckedCreateWithoutPlaidItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaidItemsInput
    upsert?: UserUpsertWithoutPlaidItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaidItemsInput, UserUpdateWithoutPlaidItemsInput>, UserUncheckedUpdateWithoutPlaidItemsInput>
  }

  export type AccountUpdateManyWithoutPlaidItemNestedInput = {
    create?: XOR<AccountCreateWithoutPlaidItemInput, AccountUncheckedCreateWithoutPlaidItemInput> | AccountCreateWithoutPlaidItemInput[] | AccountUncheckedCreateWithoutPlaidItemInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutPlaidItemInput | AccountCreateOrConnectWithoutPlaidItemInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutPlaidItemInput | AccountUpsertWithWhereUniqueWithoutPlaidItemInput[]
    createMany?: AccountCreateManyPlaidItemInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutPlaidItemInput | AccountUpdateWithWhereUniqueWithoutPlaidItemInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutPlaidItemInput | AccountUpdateManyWithWhereWithoutPlaidItemInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutPlaidItemNestedInput = {
    create?: XOR<AccountCreateWithoutPlaidItemInput, AccountUncheckedCreateWithoutPlaidItemInput> | AccountCreateWithoutPlaidItemInput[] | AccountUncheckedCreateWithoutPlaidItemInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutPlaidItemInput | AccountCreateOrConnectWithoutPlaidItemInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutPlaidItemInput | AccountUpsertWithWhereUniqueWithoutPlaidItemInput[]
    createMany?: AccountCreateManyPlaidItemInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutPlaidItemInput | AccountUpdateWithWhereUniqueWithoutPlaidItemInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutPlaidItemInput | AccountUpdateManyWithWhereWithoutPlaidItemInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTagsInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionTagCreateNestedManyWithoutTagInput = {
    create?: XOR<TransactionTagCreateWithoutTagInput, TransactionTagUncheckedCreateWithoutTagInput> | TransactionTagCreateWithoutTagInput[] | TransactionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTagInput | TransactionTagCreateOrConnectWithoutTagInput[]
    createMany?: TransactionTagCreateManyTagInputEnvelope
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
  }

  export type IncomeStreamTagCreateNestedManyWithoutTagInput = {
    create?: XOR<IncomeStreamTagCreateWithoutTagInput, IncomeStreamTagUncheckedCreateWithoutTagInput> | IncomeStreamTagCreateWithoutTagInput[] | IncomeStreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutTagInput | IncomeStreamTagCreateOrConnectWithoutTagInput[]
    createMany?: IncomeStreamTagCreateManyTagInputEnvelope
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
  }

  export type DebtTagCreateNestedManyWithoutTagInput = {
    create?: XOR<DebtTagCreateWithoutTagInput, DebtTagUncheckedCreateWithoutTagInput> | DebtTagCreateWithoutTagInput[] | DebtTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutTagInput | DebtTagCreateOrConnectWithoutTagInput[]
    createMany?: DebtTagCreateManyTagInputEnvelope
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutTagInput = {
    create?: XOR<BudgetCreateWithoutTagInput, BudgetUncheckedCreateWithoutTagInput> | BudgetCreateWithoutTagInput[] | BudgetUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTagInput | BudgetCreateOrConnectWithoutTagInput[]
    createMany?: BudgetCreateManyTagInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type TagRuleTagCreateNestedManyWithoutTagInput = {
    create?: XOR<TagRuleTagCreateWithoutTagInput, TagRuleTagUncheckedCreateWithoutTagInput> | TagRuleTagCreateWithoutTagInput[] | TagRuleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagInput | TagRuleTagCreateOrConnectWithoutTagInput[]
    createMany?: TagRuleTagCreateManyTagInputEnvelope
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
  }

  export type TransactionTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TransactionTagCreateWithoutTagInput, TransactionTagUncheckedCreateWithoutTagInput> | TransactionTagCreateWithoutTagInput[] | TransactionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTagInput | TransactionTagCreateOrConnectWithoutTagInput[]
    createMany?: TransactionTagCreateManyTagInputEnvelope
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
  }

  export type IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<IncomeStreamTagCreateWithoutTagInput, IncomeStreamTagUncheckedCreateWithoutTagInput> | IncomeStreamTagCreateWithoutTagInput[] | IncomeStreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutTagInput | IncomeStreamTagCreateOrConnectWithoutTagInput[]
    createMany?: IncomeStreamTagCreateManyTagInputEnvelope
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
  }

  export type DebtTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<DebtTagCreateWithoutTagInput, DebtTagUncheckedCreateWithoutTagInput> | DebtTagCreateWithoutTagInput[] | DebtTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutTagInput | DebtTagCreateOrConnectWithoutTagInput[]
    createMany?: DebtTagCreateManyTagInputEnvelope
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<BudgetCreateWithoutTagInput, BudgetUncheckedCreateWithoutTagInput> | BudgetCreateWithoutTagInput[] | BudgetUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTagInput | BudgetCreateOrConnectWithoutTagInput[]
    createMany?: BudgetCreateManyTagInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type TagRuleTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagRuleTagCreateWithoutTagInput, TagRuleTagUncheckedCreateWithoutTagInput> | TagRuleTagCreateWithoutTagInput[] | TagRuleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagInput | TagRuleTagCreateOrConnectWithoutTagInput[]
    createMany?: TagRuleTagCreateManyTagInputEnvelope
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    upsert?: UserUpsertWithoutTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTagsInput, UserUpdateWithoutTagsInput>, UserUncheckedUpdateWithoutTagsInput>
  }

  export type TransactionTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<TransactionTagCreateWithoutTagInput, TransactionTagUncheckedCreateWithoutTagInput> | TransactionTagCreateWithoutTagInput[] | TransactionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTagInput | TransactionTagCreateOrConnectWithoutTagInput[]
    upsert?: TransactionTagUpsertWithWhereUniqueWithoutTagInput | TransactionTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TransactionTagCreateManyTagInputEnvelope
    set?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    disconnect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    delete?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    update?: TransactionTagUpdateWithWhereUniqueWithoutTagInput | TransactionTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TransactionTagUpdateManyWithWhereWithoutTagInput | TransactionTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
  }

  export type IncomeStreamTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<IncomeStreamTagCreateWithoutTagInput, IncomeStreamTagUncheckedCreateWithoutTagInput> | IncomeStreamTagCreateWithoutTagInput[] | IncomeStreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutTagInput | IncomeStreamTagCreateOrConnectWithoutTagInput[]
    upsert?: IncomeStreamTagUpsertWithWhereUniqueWithoutTagInput | IncomeStreamTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: IncomeStreamTagCreateManyTagInputEnvelope
    set?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    disconnect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    delete?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    update?: IncomeStreamTagUpdateWithWhereUniqueWithoutTagInput | IncomeStreamTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: IncomeStreamTagUpdateManyWithWhereWithoutTagInput | IncomeStreamTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: IncomeStreamTagScalarWhereInput | IncomeStreamTagScalarWhereInput[]
  }

  export type DebtTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<DebtTagCreateWithoutTagInput, DebtTagUncheckedCreateWithoutTagInput> | DebtTagCreateWithoutTagInput[] | DebtTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutTagInput | DebtTagCreateOrConnectWithoutTagInput[]
    upsert?: DebtTagUpsertWithWhereUniqueWithoutTagInput | DebtTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DebtTagCreateManyTagInputEnvelope
    set?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    disconnect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    delete?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    update?: DebtTagUpdateWithWhereUniqueWithoutTagInput | DebtTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DebtTagUpdateManyWithWhereWithoutTagInput | DebtTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DebtTagScalarWhereInput | DebtTagScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutTagNestedInput = {
    create?: XOR<BudgetCreateWithoutTagInput, BudgetUncheckedCreateWithoutTagInput> | BudgetCreateWithoutTagInput[] | BudgetUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTagInput | BudgetCreateOrConnectWithoutTagInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutTagInput | BudgetUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BudgetCreateManyTagInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutTagInput | BudgetUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutTagInput | BudgetUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type TagRuleTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagRuleTagCreateWithoutTagInput, TagRuleTagUncheckedCreateWithoutTagInput> | TagRuleTagCreateWithoutTagInput[] | TagRuleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagInput | TagRuleTagCreateOrConnectWithoutTagInput[]
    upsert?: TagRuleTagUpsertWithWhereUniqueWithoutTagInput | TagRuleTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagRuleTagCreateManyTagInputEnvelope
    set?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    disconnect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    delete?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    update?: TagRuleTagUpdateWithWhereUniqueWithoutTagInput | TagRuleTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagRuleTagUpdateManyWithWhereWithoutTagInput | TagRuleTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagRuleTagScalarWhereInput | TagRuleTagScalarWhereInput[]
  }

  export type TransactionTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TransactionTagCreateWithoutTagInput, TransactionTagUncheckedCreateWithoutTagInput> | TransactionTagCreateWithoutTagInput[] | TransactionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTagInput | TransactionTagCreateOrConnectWithoutTagInput[]
    upsert?: TransactionTagUpsertWithWhereUniqueWithoutTagInput | TransactionTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TransactionTagCreateManyTagInputEnvelope
    set?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    disconnect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    delete?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    update?: TransactionTagUpdateWithWhereUniqueWithoutTagInput | TransactionTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TransactionTagUpdateManyWithWhereWithoutTagInput | TransactionTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
  }

  export type IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<IncomeStreamTagCreateWithoutTagInput, IncomeStreamTagUncheckedCreateWithoutTagInput> | IncomeStreamTagCreateWithoutTagInput[] | IncomeStreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: IncomeStreamTagCreateOrConnectWithoutTagInput | IncomeStreamTagCreateOrConnectWithoutTagInput[]
    upsert?: IncomeStreamTagUpsertWithWhereUniqueWithoutTagInput | IncomeStreamTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: IncomeStreamTagCreateManyTagInputEnvelope
    set?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    disconnect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    delete?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    connect?: IncomeStreamTagWhereUniqueInput | IncomeStreamTagWhereUniqueInput[]
    update?: IncomeStreamTagUpdateWithWhereUniqueWithoutTagInput | IncomeStreamTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: IncomeStreamTagUpdateManyWithWhereWithoutTagInput | IncomeStreamTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: IncomeStreamTagScalarWhereInput | IncomeStreamTagScalarWhereInput[]
  }

  export type DebtTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<DebtTagCreateWithoutTagInput, DebtTagUncheckedCreateWithoutTagInput> | DebtTagCreateWithoutTagInput[] | DebtTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DebtTagCreateOrConnectWithoutTagInput | DebtTagCreateOrConnectWithoutTagInput[]
    upsert?: DebtTagUpsertWithWhereUniqueWithoutTagInput | DebtTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DebtTagCreateManyTagInputEnvelope
    set?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    disconnect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    delete?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    connect?: DebtTagWhereUniqueInput | DebtTagWhereUniqueInput[]
    update?: DebtTagUpdateWithWhereUniqueWithoutTagInput | DebtTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DebtTagUpdateManyWithWhereWithoutTagInput | DebtTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DebtTagScalarWhereInput | DebtTagScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<BudgetCreateWithoutTagInput, BudgetUncheckedCreateWithoutTagInput> | BudgetCreateWithoutTagInput[] | BudgetUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTagInput | BudgetCreateOrConnectWithoutTagInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutTagInput | BudgetUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BudgetCreateManyTagInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutTagInput | BudgetUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutTagInput | BudgetUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type TagRuleTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagRuleTagCreateWithoutTagInput, TagRuleTagUncheckedCreateWithoutTagInput> | TagRuleTagCreateWithoutTagInput[] | TagRuleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagRuleTagCreateOrConnectWithoutTagInput | TagRuleTagCreateOrConnectWithoutTagInput[]
    upsert?: TagRuleTagUpsertWithWhereUniqueWithoutTagInput | TagRuleTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagRuleTagCreateManyTagInputEnvelope
    set?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    disconnect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    delete?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    connect?: TagRuleTagWhereUniqueInput | TagRuleTagWhereUniqueInput[]
    update?: TagRuleTagUpdateWithWhereUniqueWithoutTagInput | TagRuleTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagRuleTagUpdateManyWithWhereWithoutTagInput | TagRuleTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagRuleTagScalarWhereInput | TagRuleTagScalarWhereInput[]
  }

  export type TagRuleCreateNestedOneWithoutTagsInput = {
    create?: XOR<TagRuleCreateWithoutTagsInput, TagRuleUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TagRuleCreateOrConnectWithoutTagsInput
    connect?: TagRuleWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTagRuleTagsInput = {
    create?: XOR<TagCreateWithoutTagRuleTagsInput, TagUncheckedCreateWithoutTagRuleTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTagRuleTagsInput
    connect?: TagWhereUniqueInput
  }

  export type TagRuleUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<TagRuleCreateWithoutTagsInput, TagRuleUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TagRuleCreateOrConnectWithoutTagsInput
    upsert?: TagRuleUpsertWithoutTagsInput
    connect?: TagRuleWhereUniqueInput
    update?: XOR<XOR<TagRuleUpdateToOneWithWhereWithoutTagsInput, TagRuleUpdateWithoutTagsInput>, TagRuleUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTagRuleTagsNestedInput = {
    create?: XOR<TagCreateWithoutTagRuleTagsInput, TagUncheckedCreateWithoutTagRuleTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTagRuleTagsInput
    upsert?: TagUpsertWithoutTagRuleTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTagRuleTagsInput, TagUpdateWithoutTagRuleTagsInput>, TagUncheckedUpdateWithoutTagRuleTagsInput>
  }

  export type TransactionCreateNestedOneWithoutTransactionTagsInput = {
    create?: XOR<TransactionCreateWithoutTransactionTagsInput, TransactionUncheckedCreateWithoutTransactionTagsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTransactionTagsInput
    connect?: TransactionWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTransactionTagsInput = {
    create?: XOR<TagCreateWithoutTransactionTagsInput, TagUncheckedCreateWithoutTransactionTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTransactionTagsInput
    connect?: TagWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutTransactionTagsNestedInput = {
    create?: XOR<TransactionCreateWithoutTransactionTagsInput, TransactionUncheckedCreateWithoutTransactionTagsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTransactionTagsInput
    upsert?: TransactionUpsertWithoutTransactionTagsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutTransactionTagsInput, TransactionUpdateWithoutTransactionTagsInput>, TransactionUncheckedUpdateWithoutTransactionTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTransactionTagsNestedInput = {
    create?: XOR<TagCreateWithoutTransactionTagsInput, TagUncheckedCreateWithoutTransactionTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTransactionTagsInput
    upsert?: TagUpsertWithoutTransactionTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTransactionTagsInput, TagUpdateWithoutTransactionTagsInput>, TagUncheckedUpdateWithoutTransactionTagsInput>
  }

  export type IncomeStreamCreateNestedOneWithoutIncomeStreamTagsInput = {
    create?: XOR<IncomeStreamCreateWithoutIncomeStreamTagsInput, IncomeStreamUncheckedCreateWithoutIncomeStreamTagsInput>
    connectOrCreate?: IncomeStreamCreateOrConnectWithoutIncomeStreamTagsInput
    connect?: IncomeStreamWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutIncomeStreamTagsInput = {
    create?: XOR<TagCreateWithoutIncomeStreamTagsInput, TagUncheckedCreateWithoutIncomeStreamTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutIncomeStreamTagsInput
    connect?: TagWhereUniqueInput
  }

  export type IncomeStreamUpdateOneRequiredWithoutIncomeStreamTagsNestedInput = {
    create?: XOR<IncomeStreamCreateWithoutIncomeStreamTagsInput, IncomeStreamUncheckedCreateWithoutIncomeStreamTagsInput>
    connectOrCreate?: IncomeStreamCreateOrConnectWithoutIncomeStreamTagsInput
    upsert?: IncomeStreamUpsertWithoutIncomeStreamTagsInput
    connect?: IncomeStreamWhereUniqueInput
    update?: XOR<XOR<IncomeStreamUpdateToOneWithWhereWithoutIncomeStreamTagsInput, IncomeStreamUpdateWithoutIncomeStreamTagsInput>, IncomeStreamUncheckedUpdateWithoutIncomeStreamTagsInput>
  }

  export type TagUpdateOneRequiredWithoutIncomeStreamTagsNestedInput = {
    create?: XOR<TagCreateWithoutIncomeStreamTagsInput, TagUncheckedCreateWithoutIncomeStreamTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutIncomeStreamTagsInput
    upsert?: TagUpsertWithoutIncomeStreamTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutIncomeStreamTagsInput, TagUpdateWithoutIncomeStreamTagsInput>, TagUncheckedUpdateWithoutIncomeStreamTagsInput>
  }

  export type DebtCreateNestedOneWithoutDebtTagsInput = {
    create?: XOR<DebtCreateWithoutDebtTagsInput, DebtUncheckedCreateWithoutDebtTagsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutDebtTagsInput
    connect?: DebtWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutDebtTagsInput = {
    create?: XOR<TagCreateWithoutDebtTagsInput, TagUncheckedCreateWithoutDebtTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutDebtTagsInput
    connect?: TagWhereUniqueInput
  }

  export type DebtUpdateOneRequiredWithoutDebtTagsNestedInput = {
    create?: XOR<DebtCreateWithoutDebtTagsInput, DebtUncheckedCreateWithoutDebtTagsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutDebtTagsInput
    upsert?: DebtUpsertWithoutDebtTagsInput
    connect?: DebtWhereUniqueInput
    update?: XOR<XOR<DebtUpdateToOneWithWhereWithoutDebtTagsInput, DebtUpdateWithoutDebtTagsInput>, DebtUncheckedUpdateWithoutDebtTagsInput>
  }

  export type TagUpdateOneRequiredWithoutDebtTagsNestedInput = {
    create?: XOR<TagCreateWithoutDebtTagsInput, TagUncheckedCreateWithoutDebtTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutDebtTagsInput
    upsert?: TagUpsertWithoutDebtTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutDebtTagsInput, TagUpdateWithoutDebtTagsInput>, TagUncheckedUpdateWithoutDebtTagsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumCategoryKindFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryKind | EnumCategoryKindFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryKindFilter<$PrismaModel> | $Enums.CategoryKind
  }

  export type NestedEnumCategoryKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryKind | EnumCategoryKindFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryKind[] | ListEnumCategoryKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryKindWithAggregatesFilter<$PrismaModel> | $Enums.CategoryKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryKindFilter<$PrismaModel>
    _max?: NestedEnumCategoryKindFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumTagRuleMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleMatchType | EnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleMatchTypeFilter<$PrismaModel> | $Enums.TagRuleMatchType
  }

  export type NestedEnumTagRuleSourceFieldFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleSourceField | EnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleSourceFieldFilter<$PrismaModel> | $Enums.TagRuleSourceField
  }

  export type NestedEnumTagRuleMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleMatchType | EnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleMatchType[] | ListEnumTagRuleMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagRuleMatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagRuleMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumTagRuleMatchTypeFilter<$PrismaModel>
  }

  export type NestedEnumTagRuleSourceFieldWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagRuleSourceField | EnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    in?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagRuleSourceField[] | ListEnumTagRuleSourceFieldFieldRefInput<$PrismaModel>
    not?: NestedEnumTagRuleSourceFieldWithAggregatesFilter<$PrismaModel> | $Enums.TagRuleSourceField
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagRuleSourceFieldFilter<$PrismaModel>
    _max?: NestedEnumTagRuleSourceFieldFilter<$PrismaModel>
  }

  export type NestedEnumBudgetPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodFilter<$PrismaModel> | $Enums.BudgetPeriod
  }

  export type NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel> | $Enums.BudgetPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetPeriodFilter<$PrismaModel>
    _max?: NestedEnumBudgetPeriodFilter<$PrismaModel>
  }

  export type NestedEnumBillFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.BillFrequency | EnumBillFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumBillFrequencyFilter<$PrismaModel> | $Enums.BillFrequency
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumBillFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillFrequency | EnumBillFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillFrequency[] | ListEnumBillFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumBillFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.BillFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillFrequencyFilter<$PrismaModel>
    _max?: NestedEnumBillFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionFrequency | EnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionFrequencyFilter<$PrismaModel> | $Enums.SubscriptionFrequency
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionFrequency | EnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionFrequency[] | ListEnumSubscriptionFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionFrequencyFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumIncomeCadenceFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCadence | EnumIncomeCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCadenceFilter<$PrismaModel> | $Enums.IncomeCadence
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumIncomeCadenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCadence | EnumIncomeCadenceFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCadence[] | ListEnumIncomeCadenceFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCadenceWithAggregatesFilter<$PrismaModel> | $Enums.IncomeCadence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeCadenceFilter<$PrismaModel>
    _max?: NestedEnumIncomeCadenceFilter<$PrismaModel>
  }

  export type NestedEnumSavingsRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SavingsRuleType | EnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavingsRuleTypeFilter<$PrismaModel> | $Enums.SavingsRuleType
  }

  export type NestedEnumSavingsRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SavingsRuleType | EnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SavingsRuleType[] | ListEnumSavingsRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSavingsRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SavingsRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSavingsRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumSavingsRuleTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlanStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStrategy | EnumPlanStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanStrategyFilter<$PrismaModel> | $Enums.PlanStrategy
  }

  export type NestedEnumPlanStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStrategy | EnumPlanStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanStrategy[] | ListEnumPlanStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanStrategyWithAggregatesFilter<$PrismaModel> | $Enums.PlanStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanStrategyFilter<$PrismaModel>
    _max?: NestedEnumPlanStrategyFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedEnumPlanItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanItemType | EnumPlanItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanItemTypeFilter<$PrismaModel> | $Enums.PlanItemType
  }

  export type NestedEnumPlanItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanItemType | EnumPlanItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanItemType[] | ListEnumPlanItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanItemTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanItemTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    plaidItem?: PlaidItemCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidItemId?: string | null
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type CategoryCreateWithoutUserInput = {
    id?: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutUserInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput>
  }

  export type CategoryCreateManyUserInputEnvelope = {
    data: CategoryCreateManyUserInput | CategoryCreateManyUserInput[]
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
  }

  export type TagCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutTagInput
    debtTags?: DebtTagCreateNestedManyWithoutTagInput
    budgets?: BudgetCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutTagInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutUserInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
  }

  export type TagCreateManyUserInputEnvelope = {
    data: TagCreateManyUserInput | TagCreateManyUserInput[]
  }

  export type BillCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    dueDayOfMonth?: number | null
    dueDate?: Date | string | null
    frequency: $Enums.BillFrequency
    isEssential?: boolean
    autopay?: boolean
    createdAt?: Date | string
  }

  export type BillUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    dueDayOfMonth?: number | null
    dueDate?: Date | string | null
    frequency: $Enums.BillFrequency
    isEssential?: boolean
    autopay?: boolean
    createdAt?: Date | string
  }

  export type BillCreateOrConnectWithoutUserInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput>
  }

  export type BillCreateManyUserInputEnvelope = {
    data: BillCreateManyUserInput | BillCreateManyUserInput[]
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
  }

  export type IncomeStreamCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutIncomeStreamInput
  }

  export type IncomeStreamUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutIncomeStreamInput
  }

  export type IncomeStreamCreateOrConnectWithoutUserInput = {
    where: IncomeStreamWhereUniqueInput
    create: XOR<IncomeStreamCreateWithoutUserInput, IncomeStreamUncheckedCreateWithoutUserInput>
  }

  export type IncomeStreamCreateManyUserInputEnvelope = {
    data: IncomeStreamCreateManyUserInput | IncomeStreamCreateManyUserInput[]
  }

  export type DebtCreateWithoutUserInput = {
    id?: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    payments?: DebtPaymentCreateNestedManyWithoutDebtInput
    debtTags?: DebtTagCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    payments?: DebtPaymentUncheckedCreateNestedManyWithoutDebtInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutUserInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutUserInput, DebtUncheckedCreateWithoutUserInput>
  }

  export type DebtCreateManyUserInputEnvelope = {
    data: DebtCreateManyUserInput | DebtCreateManyUserInput[]
  }

  export type DebtPaymentCreateWithoutUserInput = {
    id?: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
    debt: DebtCreateNestedOneWithoutPaymentsInput
  }

  export type DebtPaymentUncheckedCreateWithoutUserInput = {
    id?: string
    debtId: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type DebtPaymentCreateOrConnectWithoutUserInput = {
    where: DebtPaymentWhereUniqueInput
    create: XOR<DebtPaymentCreateWithoutUserInput, DebtPaymentUncheckedCreateWithoutUserInput>
  }

  export type DebtPaymentCreateManyUserInputEnvelope = {
    data: DebtPaymentCreateManyUserInput | DebtPaymentCreateManyUserInput[]
  }

  export type SavingsGoalCreateWithoutUserInput = {
    id?: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority?: number
    createdAt?: Date | string
  }

  export type SavingsGoalUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority?: number
    createdAt?: Date | string
  }

  export type SavingsGoalCreateOrConnectWithoutUserInput = {
    where: SavingsGoalWhereUniqueInput
    create: XOR<SavingsGoalCreateWithoutUserInput, SavingsGoalUncheckedCreateWithoutUserInput>
  }

  export type SavingsGoalCreateManyUserInputEnvelope = {
    data: SavingsGoalCreateManyUserInput | SavingsGoalCreateManyUserInput[]
  }

  export type MandatorySavingsCreateWithoutUserInput = {
    id?: string
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MandatorySavingsUncheckedCreateWithoutUserInput = {
    id?: string
    monthsToSave: number
    targetDollars: number
    currentDollars: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MandatorySavingsCreateOrConnectWithoutUserInput = {
    where: MandatorySavingsWhereUniqueInput
    create: XOR<MandatorySavingsCreateWithoutUserInput, MandatorySavingsUncheckedCreateWithoutUserInput>
  }

  export type PlanCreateWithoutUserInput = {
    id?: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
    items?: PlanItemCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
    items?: PlanItemUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutUserInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput>
  }

  export type PlanCreateManyUserInputEnvelope = {
    data: PlanCreateManyUserInput | PlanCreateManyUserInput[]
  }

  export type PlaidItemCreateWithoutUserInput = {
    id?: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutPlaidItemInput
  }

  export type PlaidItemUncheckedCreateWithoutUserInput = {
    id?: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutPlaidItemInput
  }

  export type PlaidItemCreateOrConnectWithoutUserInput = {
    where: PlaidItemWhereUniqueInput
    create: XOR<PlaidItemCreateWithoutUserInput, PlaidItemUncheckedCreateWithoutUserInput>
  }

  export type PlaidItemCreateManyUserInputEnvelope = {
    data: PlaidItemCreateManyUserInput | PlaidItemCreateManyUserInput[]
  }

  export type BudgetCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    createdAt?: Date | string
    category?: CategoryCreateNestedOneWithoutBudgetsInput
    tag?: TagCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId?: string | null
    tagId?: string | null
    createdAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutUserInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetCreateManyUserInputEnvelope = {
    data: BudgetCreateManyUserInput | BudgetCreateManyUserInput[]
  }

  export type TagRuleCreateWithoutUserInput = {
    id?: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagRuleTagCreateNestedManyWithoutTagRuleInput
  }

  export type TagRuleUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagRuleTagUncheckedCreateNestedManyWithoutTagRuleInput
  }

  export type TagRuleCreateOrConnectWithoutUserInput = {
    where: TagRuleWhereUniqueInput
    create: XOR<TagRuleCreateWithoutUserInput, TagRuleUncheckedCreateWithoutUserInput>
  }

  export type TagRuleCreateManyUserInputEnvelope = {
    data: TagRuleCreateManyUserInput | TagRuleCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    entityType?: string | null
    entityId?: string | null
    milestonePct?: number | null
    message: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    entityType?: string | null
    entityId?: string | null
    milestonePct?: number | null
    message: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    currency?: StringFilter<"Account"> | string
    plaidItemId?: StringNullableFilter<"Account"> | string | null
    plaidAccountId?: StringNullableFilter<"Account"> | string | null
    plaidMask?: StringNullableFilter<"Account"> | string | null
    plaidType?: StringNullableFilter<"Account"> | string | null
    plaidSubtype?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutUserInput, CategoryUncheckedUpdateWithoutUserInput>
    create: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutUserInput, CategoryUncheckedUpdateWithoutUserInput>
  }

  export type CategoryUpdateManyWithWhereWithoutUserInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    userId?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    kind?: EnumCategoryKindFilter<"Category"> | $Enums.CategoryKind
    createdAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    accountId?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    amountDollars?: FloatFilter<"Transaction"> | number
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    merchant?: StringNullableFilter<"Transaction"> | string | null
    note?: StringNullableFilter<"Transaction"> | string | null
    plaidTransactionId?: StringNullableFilter<"Transaction"> | string | null
    pending?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutUserInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutUserInput, TagUncheckedUpdateWithoutUserInput>
    create: XOR<TagCreateWithoutUserInput, TagUncheckedCreateWithoutUserInput>
  }

  export type TagUpdateWithWhereUniqueWithoutUserInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutUserInput, TagUncheckedUpdateWithoutUserInput>
  }

  export type TagUpdateManyWithWhereWithoutUserInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutUserInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    userId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type BillUpsertWithWhereUniqueWithoutUserInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutUserInput, BillUncheckedUpdateWithoutUserInput>
    create: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput>
  }

  export type BillUpdateWithWhereUniqueWithoutUserInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutUserInput, BillUncheckedUpdateWithoutUserInput>
  }

  export type BillUpdateManyWithWhereWithoutUserInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutUserInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: StringFilter<"Bill"> | string
    userId?: StringFilter<"Bill"> | string
    name?: StringFilter<"Bill"> | string
    amountDollars?: FloatFilter<"Bill"> | number
    dueDayOfMonth?: IntNullableFilter<"Bill"> | number | null
    dueDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    frequency?: EnumBillFrequencyFilter<"Bill"> | $Enums.BillFrequency
    isEssential?: BoolFilter<"Bill"> | boolean
    autopay?: BoolFilter<"Bill"> | boolean
    createdAt?: DateTimeFilter<"Bill"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    name?: StringFilter<"Subscription"> | string
    amountDollars?: FloatFilter<"Subscription"> | number
    billingDayOfMonth?: IntFilter<"Subscription"> | number
    frequency?: EnumSubscriptionFrequencyFilter<"Subscription"> | $Enums.SubscriptionFrequency
    cancelable?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type IncomeStreamUpsertWithWhereUniqueWithoutUserInput = {
    where: IncomeStreamWhereUniqueInput
    update: XOR<IncomeStreamUpdateWithoutUserInput, IncomeStreamUncheckedUpdateWithoutUserInput>
    create: XOR<IncomeStreamCreateWithoutUserInput, IncomeStreamUncheckedCreateWithoutUserInput>
  }

  export type IncomeStreamUpdateWithWhereUniqueWithoutUserInput = {
    where: IncomeStreamWhereUniqueInput
    data: XOR<IncomeStreamUpdateWithoutUserInput, IncomeStreamUncheckedUpdateWithoutUserInput>
  }

  export type IncomeStreamUpdateManyWithWhereWithoutUserInput = {
    where: IncomeStreamScalarWhereInput
    data: XOR<IncomeStreamUpdateManyMutationInput, IncomeStreamUncheckedUpdateManyWithoutUserInput>
  }

  export type IncomeStreamScalarWhereInput = {
    AND?: IncomeStreamScalarWhereInput | IncomeStreamScalarWhereInput[]
    OR?: IncomeStreamScalarWhereInput[]
    NOT?: IncomeStreamScalarWhereInput | IncomeStreamScalarWhereInput[]
    id?: StringFilter<"IncomeStream"> | string
    userId?: StringFilter<"IncomeStream"> | string
    name?: StringFilter<"IncomeStream"> | string
    amountDollars?: FloatFilter<"IncomeStream"> | number
    lastAmountDollars?: FloatNullableFilter<"IncomeStream"> | number | null
    cadence?: EnumIncomeCadenceFilter<"IncomeStream"> | $Enums.IncomeCadence
    nextPayDate?: DateTimeFilter<"IncomeStream"> | Date | string
    createdAt?: DateTimeFilter<"IncomeStream"> | Date | string
  }

  export type DebtUpsertWithWhereUniqueWithoutUserInput = {
    where: DebtWhereUniqueInput
    update: XOR<DebtUpdateWithoutUserInput, DebtUncheckedUpdateWithoutUserInput>
    create: XOR<DebtCreateWithoutUserInput, DebtUncheckedCreateWithoutUserInput>
  }

  export type DebtUpdateWithWhereUniqueWithoutUserInput = {
    where: DebtWhereUniqueInput
    data: XOR<DebtUpdateWithoutUserInput, DebtUncheckedUpdateWithoutUserInput>
  }

  export type DebtUpdateManyWithWhereWithoutUserInput = {
    where: DebtScalarWhereInput
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyWithoutUserInput>
  }

  export type DebtScalarWhereInput = {
    AND?: DebtScalarWhereInput | DebtScalarWhereInput[]
    OR?: DebtScalarWhereInput[]
    NOT?: DebtScalarWhereInput | DebtScalarWhereInput[]
    id?: StringFilter<"Debt"> | string
    userId?: StringFilter<"Debt"> | string
    name?: StringFilter<"Debt"> | string
    principalDollars?: FloatFilter<"Debt"> | number
    aprBps?: IntFilter<"Debt"> | number
    minPaymentDollars?: FloatFilter<"Debt"> | number
    estimatedMonthlyPaymentDollars?: FloatNullableFilter<"Debt"> | number | null
    dueDayOfMonth?: IntFilter<"Debt"> | number
    estimatedPayoffDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    createdAt?: DateTimeFilter<"Debt"> | Date | string
  }

  export type DebtPaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: DebtPaymentWhereUniqueInput
    update: XOR<DebtPaymentUpdateWithoutUserInput, DebtPaymentUncheckedUpdateWithoutUserInput>
    create: XOR<DebtPaymentCreateWithoutUserInput, DebtPaymentUncheckedCreateWithoutUserInput>
  }

  export type DebtPaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: DebtPaymentWhereUniqueInput
    data: XOR<DebtPaymentUpdateWithoutUserInput, DebtPaymentUncheckedUpdateWithoutUserInput>
  }

  export type DebtPaymentUpdateManyWithWhereWithoutUserInput = {
    where: DebtPaymentScalarWhereInput
    data: XOR<DebtPaymentUpdateManyMutationInput, DebtPaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type DebtPaymentScalarWhereInput = {
    AND?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
    OR?: DebtPaymentScalarWhereInput[]
    NOT?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
    id?: StringFilter<"DebtPayment"> | string
    userId?: StringFilter<"DebtPayment"> | string
    debtId?: StringFilter<"DebtPayment"> | string
    amountDollars?: FloatFilter<"DebtPayment"> | number
    paymentDate?: DateTimeFilter<"DebtPayment"> | Date | string
    createdAt?: DateTimeFilter<"DebtPayment"> | Date | string
  }

  export type SavingsGoalUpsertWithWhereUniqueWithoutUserInput = {
    where: SavingsGoalWhereUniqueInput
    update: XOR<SavingsGoalUpdateWithoutUserInput, SavingsGoalUncheckedUpdateWithoutUserInput>
    create: XOR<SavingsGoalCreateWithoutUserInput, SavingsGoalUncheckedCreateWithoutUserInput>
  }

  export type SavingsGoalUpdateWithWhereUniqueWithoutUserInput = {
    where: SavingsGoalWhereUniqueInput
    data: XOR<SavingsGoalUpdateWithoutUserInput, SavingsGoalUncheckedUpdateWithoutUserInput>
  }

  export type SavingsGoalUpdateManyWithWhereWithoutUserInput = {
    where: SavingsGoalScalarWhereInput
    data: XOR<SavingsGoalUpdateManyMutationInput, SavingsGoalUncheckedUpdateManyWithoutUserInput>
  }

  export type SavingsGoalScalarWhereInput = {
    AND?: SavingsGoalScalarWhereInput | SavingsGoalScalarWhereInput[]
    OR?: SavingsGoalScalarWhereInput[]
    NOT?: SavingsGoalScalarWhereInput | SavingsGoalScalarWhereInput[]
    id?: StringFilter<"SavingsGoal"> | string
    userId?: StringFilter<"SavingsGoal"> | string
    name?: StringFilter<"SavingsGoal"> | string
    targetDollars?: FloatFilter<"SavingsGoal"> | number
    currentDollars?: FloatFilter<"SavingsGoal"> | number
    ruleType?: EnumSavingsRuleTypeFilter<"SavingsGoal"> | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFilter<"SavingsGoal"> | number
    priority?: IntFilter<"SavingsGoal"> | number
    createdAt?: DateTimeFilter<"SavingsGoal"> | Date | string
  }

  export type MandatorySavingsUpsertWithoutUserInput = {
    update: XOR<MandatorySavingsUpdateWithoutUserInput, MandatorySavingsUncheckedUpdateWithoutUserInput>
    create: XOR<MandatorySavingsCreateWithoutUserInput, MandatorySavingsUncheckedCreateWithoutUserInput>
    where?: MandatorySavingsWhereInput
  }

  export type MandatorySavingsUpdateToOneWithWhereWithoutUserInput = {
    where?: MandatorySavingsWhereInput
    data: XOR<MandatorySavingsUpdateWithoutUserInput, MandatorySavingsUncheckedUpdateWithoutUserInput>
  }

  export type MandatorySavingsUpdateWithoutUserInput = {
    monthsToSave?: IntFieldUpdateOperationsInput | number
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandatorySavingsUncheckedUpdateWithoutUserInput = {
    monthsToSave?: IntFieldUpdateOperationsInput | number
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUpsertWithWhereUniqueWithoutUserInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutUserInput, PlanUncheckedUpdateWithoutUserInput>
    create: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutUserInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutUserInput, PlanUncheckedUpdateWithoutUserInput>
  }

  export type PlanUpdateManyWithWhereWithoutUserInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutUserInput>
  }

  export type PlanScalarWhereInput = {
    AND?: PlanScalarWhereInput | PlanScalarWhereInput[]
    OR?: PlanScalarWhereInput[]
    NOT?: PlanScalarWhereInput | PlanScalarWhereInput[]
    id?: StringFilter<"Plan"> | string
    userId?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    strategy?: EnumPlanStrategyFilter<"Plan"> | $Enums.PlanStrategy
    horizonMonths?: IntFilter<"Plan"> | number
    startDate?: DateTimeFilter<"Plan"> | Date | string
    rulesJson?: JsonFilter<"Plan">
    summaryJson?: JsonFilter<"Plan">
    warningsJson?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
  }

  export type PlaidItemUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaidItemWhereUniqueInput
    update: XOR<PlaidItemUpdateWithoutUserInput, PlaidItemUncheckedUpdateWithoutUserInput>
    create: XOR<PlaidItemCreateWithoutUserInput, PlaidItemUncheckedCreateWithoutUserInput>
  }

  export type PlaidItemUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaidItemWhereUniqueInput
    data: XOR<PlaidItemUpdateWithoutUserInput, PlaidItemUncheckedUpdateWithoutUserInput>
  }

  export type PlaidItemUpdateManyWithWhereWithoutUserInput = {
    where: PlaidItemScalarWhereInput
    data: XOR<PlaidItemUpdateManyMutationInput, PlaidItemUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaidItemScalarWhereInput = {
    AND?: PlaidItemScalarWhereInput | PlaidItemScalarWhereInput[]
    OR?: PlaidItemScalarWhereInput[]
    NOT?: PlaidItemScalarWhereInput | PlaidItemScalarWhereInput[]
    id?: StringFilter<"PlaidItem"> | string
    userId?: StringFilter<"PlaidItem"> | string
    itemId?: StringFilter<"PlaidItem"> | string
    accessTokenEncrypted?: StringFilter<"PlaidItem"> | string
    institutionId?: StringNullableFilter<"PlaidItem"> | string | null
    institutionName?: StringNullableFilter<"PlaidItem"> | string | null
    transactionsCursor?: StringNullableFilter<"PlaidItem"> | string | null
    createdAt?: DateTimeFilter<"PlaidItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlaidItem"> | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUpdateManyWithWhereWithoutUserInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutUserInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    userId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    amountDollars?: FloatFilter<"Budget"> | number
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    categoryId?: StringNullableFilter<"Budget"> | string | null
    tagId?: StringNullableFilter<"Budget"> | string | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type TagRuleUpsertWithWhereUniqueWithoutUserInput = {
    where: TagRuleWhereUniqueInput
    update: XOR<TagRuleUpdateWithoutUserInput, TagRuleUncheckedUpdateWithoutUserInput>
    create: XOR<TagRuleCreateWithoutUserInput, TagRuleUncheckedCreateWithoutUserInput>
  }

  export type TagRuleUpdateWithWhereUniqueWithoutUserInput = {
    where: TagRuleWhereUniqueInput
    data: XOR<TagRuleUpdateWithoutUserInput, TagRuleUncheckedUpdateWithoutUserInput>
  }

  export type TagRuleUpdateManyWithWhereWithoutUserInput = {
    where: TagRuleScalarWhereInput
    data: XOR<TagRuleUpdateManyMutationInput, TagRuleUncheckedUpdateManyWithoutUserInput>
  }

  export type TagRuleScalarWhereInput = {
    AND?: TagRuleScalarWhereInput | TagRuleScalarWhereInput[]
    OR?: TagRuleScalarWhereInput[]
    NOT?: TagRuleScalarWhereInput | TagRuleScalarWhereInput[]
    id?: StringFilter<"TagRule"> | string
    userId?: StringFilter<"TagRule"> | string
    name?: StringFilter<"TagRule"> | string
    pattern?: StringFilter<"TagRule"> | string
    matchType?: EnumTagRuleMatchTypeFilter<"TagRule"> | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFilter<"TagRule"> | $Enums.TagRuleSourceField
    createdAt?: DateTimeFilter<"TagRule"> | Date | string
    updatedAt?: DateTimeFilter<"TagRule"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    milestonePct?: IntNullableFilter<"Notification"> | number | null
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type PlaidItemCreateWithoutAccountsInput = {
    id?: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaidItemsInput
  }

  export type PlaidItemUncheckedCreateWithoutAccountsInput = {
    id?: string
    userId: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaidItemCreateOrConnectWithoutAccountsInput = {
    where: PlaidItemWhereUniqueInput
    create: XOR<PlaidItemCreateWithoutAccountsInput, PlaidItemUncheckedCreateWithoutAccountsInput>
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    userId: string
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaidItemUpsertWithoutAccountsInput = {
    update: XOR<PlaidItemUpdateWithoutAccountsInput, PlaidItemUncheckedUpdateWithoutAccountsInput>
    create: XOR<PlaidItemCreateWithoutAccountsInput, PlaidItemUncheckedCreateWithoutAccountsInput>
    where?: PlaidItemWhereInput
  }

  export type PlaidItemUpdateToOneWithWhereWithoutAccountsInput = {
    where?: PlaidItemWhereInput
    data: XOR<PlaidItemUpdateWithoutAccountsInput, PlaidItemUncheckedUpdateWithoutAccountsInput>
  }

  export type PlaidItemUpdateWithoutAccountsInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaidItemsNestedInput
  }

  export type PlaidItemUncheckedUpdateWithoutAccountsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type UserCreateWithoutCategoriesInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCategoriesInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
  }

  export type TransactionCreateWithoutCategoryInput = {
    id?: string
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionCreateManyCategoryInputEnvelope = {
    data: TransactionCreateManyCategoryInput | TransactionCreateManyCategoryInput[]
  }

  export type BudgetCreateWithoutCategoryInput = {
    id?: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
    tag?: TagCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    tagId?: string | null
    createdAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutCategoryInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutCategoryInput, BudgetUncheckedCreateWithoutCategoryInput>
  }

  export type BudgetCreateManyCategoryInputEnvelope = {
    data: BudgetCreateManyCategoryInput | BudgetCreateManyCategoryInput[]
  }

  export type UserUpsertWithoutCategoriesInput = {
    update: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type UserUpdateWithoutCategoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCategoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BudgetUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutCategoryInput, BudgetUncheckedUpdateWithoutCategoryInput>
    create: XOR<BudgetCreateWithoutCategoryInput, BudgetUncheckedCreateWithoutCategoryInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutCategoryInput, BudgetUncheckedUpdateWithoutCategoryInput>
  }

  export type BudgetUpdateManyWithWhereWithoutCategoryInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
    plaidItem?: PlaidItemCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidItemId?: string | null
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
  }

  export type CategoryCreateWithoutTransactionsInput = {
    id?: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCategoriesInput
    budgets?: BudgetCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    budgets?: BudgetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTransactionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionTagCreateWithoutTransactionInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutTransactionTagsInput
  }

  export type TransactionTagUncheckedCreateWithoutTransactionInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type TransactionTagCreateOrConnectWithoutTransactionInput = {
    where: TransactionTagWhereUniqueInput
    create: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionTagCreateManyTransactionInputEnvelope = {
    data: TransactionTagCreateManyTransactionInput | TransactionTagCreateManyTransactionInput[]
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithoutTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
    plaidItem?: PlaidItemUpdateOneWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidItemId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutTransactionsInput = {
    update: XOR<CategoryUpdateWithoutTransactionsInput, CategoryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTransactionsInput, CategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type CategoryUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    budgets?: BudgetUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTransactionsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgets?: BudgetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TransactionTagUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionTagWhereUniqueInput
    update: XOR<TransactionTagUpdateWithoutTransactionInput, TransactionTagUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionTagUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionTagWhereUniqueInput
    data: XOR<TransactionTagUpdateWithoutTransactionInput, TransactionTagUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionTagUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionTagScalarWhereInput
    data: XOR<TransactionTagUpdateManyMutationInput, TransactionTagUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionTagScalarWhereInput = {
    AND?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
    OR?: TransactionTagScalarWhereInput[]
    NOT?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
    id?: StringFilter<"TransactionTag"> | string
    transactionId?: StringFilter<"TransactionTag"> | string
    tagId?: StringFilter<"TransactionTag"> | string
    createdAt?: DateTimeFilter<"TransactionTag"> | Date | string
  }

  export type UserCreateWithoutTagRulesInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagRulesInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagRulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagRulesInput, UserUncheckedCreateWithoutTagRulesInput>
  }

  export type TagRuleTagCreateWithoutTagRuleInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutTagRuleTagsInput
  }

  export type TagRuleTagUncheckedCreateWithoutTagRuleInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type TagRuleTagCreateOrConnectWithoutTagRuleInput = {
    where: TagRuleTagWhereUniqueInput
    create: XOR<TagRuleTagCreateWithoutTagRuleInput, TagRuleTagUncheckedCreateWithoutTagRuleInput>
  }

  export type TagRuleTagCreateManyTagRuleInputEnvelope = {
    data: TagRuleTagCreateManyTagRuleInput | TagRuleTagCreateManyTagRuleInput[]
  }

  export type UserUpsertWithoutTagRulesInput = {
    update: XOR<UserUpdateWithoutTagRulesInput, UserUncheckedUpdateWithoutTagRulesInput>
    create: XOR<UserCreateWithoutTagRulesInput, UserUncheckedCreateWithoutTagRulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTagRulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTagRulesInput, UserUncheckedUpdateWithoutTagRulesInput>
  }

  export type UserUpdateWithoutTagRulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagRulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TagRuleTagUpsertWithWhereUniqueWithoutTagRuleInput = {
    where: TagRuleTagWhereUniqueInput
    update: XOR<TagRuleTagUpdateWithoutTagRuleInput, TagRuleTagUncheckedUpdateWithoutTagRuleInput>
    create: XOR<TagRuleTagCreateWithoutTagRuleInput, TagRuleTagUncheckedCreateWithoutTagRuleInput>
  }

  export type TagRuleTagUpdateWithWhereUniqueWithoutTagRuleInput = {
    where: TagRuleTagWhereUniqueInput
    data: XOR<TagRuleTagUpdateWithoutTagRuleInput, TagRuleTagUncheckedUpdateWithoutTagRuleInput>
  }

  export type TagRuleTagUpdateManyWithWhereWithoutTagRuleInput = {
    where: TagRuleTagScalarWhereInput
    data: XOR<TagRuleTagUpdateManyMutationInput, TagRuleTagUncheckedUpdateManyWithoutTagRuleInput>
  }

  export type TagRuleTagScalarWhereInput = {
    AND?: TagRuleTagScalarWhereInput | TagRuleTagScalarWhereInput[]
    OR?: TagRuleTagScalarWhereInput[]
    NOT?: TagRuleTagScalarWhereInput | TagRuleTagScalarWhereInput[]
    id?: StringFilter<"TagRuleTag"> | string
    tagRuleId?: StringFilter<"TagRuleTag"> | string
    tagId?: StringFilter<"TagRuleTag"> | string
    createdAt?: DateTimeFilter<"TagRuleTag"> | Date | string
  }

  export type UserCreateWithoutBudgetsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBudgetsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBudgetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
  }

  export type CategoryCreateWithoutBudgetsInput = {
    id?: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCategoriesInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutBudgetsInput = {
    id?: string
    userId: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutBudgetsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
  }

  export type TagCreateWithoutBudgetsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutTagInput
    debtTags?: DebtTagCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutBudgetsInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutBudgetsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutBudgetsInput, TagUncheckedCreateWithoutBudgetsInput>
  }

  export type UserUpsertWithoutBudgetsInput = {
    update: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserUpdateWithoutBudgetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBudgetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryUpsertWithoutBudgetsInput = {
    update: XOR<CategoryUpdateWithoutBudgetsInput, CategoryUncheckedUpdateWithoutBudgetsInput>
    create: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBudgetsInput, CategoryUncheckedUpdateWithoutBudgetsInput>
  }

  export type CategoryUpdateWithoutBudgetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBudgetsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TagUpsertWithoutBudgetsInput = {
    update: XOR<TagUpdateWithoutBudgetsInput, TagUncheckedUpdateWithoutBudgetsInput>
    create: XOR<TagCreateWithoutBudgetsInput, TagUncheckedCreateWithoutBudgetsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutBudgetsInput, TagUncheckedUpdateWithoutBudgetsInput>
  }

  export type TagUpdateWithoutBudgetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutBudgetsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type UserCreateWithoutBillsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBillsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
  }

  export type UserUpsertWithoutBillsInput = {
    update: XOR<UserUpdateWithoutBillsInput, UserUncheckedUpdateWithoutBillsInput>
    create: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBillsInput, UserUncheckedUpdateWithoutBillsInput>
  }

  export type UserUpdateWithoutBillsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBillsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIncomeStreamsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIncomeStreamsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIncomeStreamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncomeStreamsInput, UserUncheckedCreateWithoutIncomeStreamsInput>
  }

  export type IncomeStreamTagCreateWithoutIncomeStreamInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutIncomeStreamTagsInput
  }

  export type IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type IncomeStreamTagCreateOrConnectWithoutIncomeStreamInput = {
    where: IncomeStreamTagWhereUniqueInput
    create: XOR<IncomeStreamTagCreateWithoutIncomeStreamInput, IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput>
  }

  export type IncomeStreamTagCreateManyIncomeStreamInputEnvelope = {
    data: IncomeStreamTagCreateManyIncomeStreamInput | IncomeStreamTagCreateManyIncomeStreamInput[]
  }

  export type UserUpsertWithoutIncomeStreamsInput = {
    update: XOR<UserUpdateWithoutIncomeStreamsInput, UserUncheckedUpdateWithoutIncomeStreamsInput>
    create: XOR<UserCreateWithoutIncomeStreamsInput, UserUncheckedCreateWithoutIncomeStreamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIncomeStreamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIncomeStreamsInput, UserUncheckedUpdateWithoutIncomeStreamsInput>
  }

  export type UserUpdateWithoutIncomeStreamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIncomeStreamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IncomeStreamTagUpsertWithWhereUniqueWithoutIncomeStreamInput = {
    where: IncomeStreamTagWhereUniqueInput
    update: XOR<IncomeStreamTagUpdateWithoutIncomeStreamInput, IncomeStreamTagUncheckedUpdateWithoutIncomeStreamInput>
    create: XOR<IncomeStreamTagCreateWithoutIncomeStreamInput, IncomeStreamTagUncheckedCreateWithoutIncomeStreamInput>
  }

  export type IncomeStreamTagUpdateWithWhereUniqueWithoutIncomeStreamInput = {
    where: IncomeStreamTagWhereUniqueInput
    data: XOR<IncomeStreamTagUpdateWithoutIncomeStreamInput, IncomeStreamTagUncheckedUpdateWithoutIncomeStreamInput>
  }

  export type IncomeStreamTagUpdateManyWithWhereWithoutIncomeStreamInput = {
    where: IncomeStreamTagScalarWhereInput
    data: XOR<IncomeStreamTagUpdateManyMutationInput, IncomeStreamTagUncheckedUpdateManyWithoutIncomeStreamInput>
  }

  export type IncomeStreamTagScalarWhereInput = {
    AND?: IncomeStreamTagScalarWhereInput | IncomeStreamTagScalarWhereInput[]
    OR?: IncomeStreamTagScalarWhereInput[]
    NOT?: IncomeStreamTagScalarWhereInput | IncomeStreamTagScalarWhereInput[]
    id?: StringFilter<"IncomeStreamTag"> | string
    incomeStreamId?: StringFilter<"IncomeStreamTag"> | string
    tagId?: StringFilter<"IncomeStreamTag"> | string
    createdAt?: DateTimeFilter<"IncomeStreamTag"> | Date | string
  }

  export type UserCreateWithoutDebtsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDebtsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDebtsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtsInput, UserUncheckedCreateWithoutDebtsInput>
  }

  export type DebtPaymentCreateWithoutDebtInput = {
    id?: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDebtPaymentsInput
  }

  export type DebtPaymentUncheckedCreateWithoutDebtInput = {
    id?: string
    userId: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type DebtPaymentCreateOrConnectWithoutDebtInput = {
    where: DebtPaymentWhereUniqueInput
    create: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput>
  }

  export type DebtPaymentCreateManyDebtInputEnvelope = {
    data: DebtPaymentCreateManyDebtInput | DebtPaymentCreateManyDebtInput[]
  }

  export type DebtTagCreateWithoutDebtInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutDebtTagsInput
  }

  export type DebtTagUncheckedCreateWithoutDebtInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type DebtTagCreateOrConnectWithoutDebtInput = {
    where: DebtTagWhereUniqueInput
    create: XOR<DebtTagCreateWithoutDebtInput, DebtTagUncheckedCreateWithoutDebtInput>
  }

  export type DebtTagCreateManyDebtInputEnvelope = {
    data: DebtTagCreateManyDebtInput | DebtTagCreateManyDebtInput[]
  }

  export type UserUpsertWithoutDebtsInput = {
    update: XOR<UserUpdateWithoutDebtsInput, UserUncheckedUpdateWithoutDebtsInput>
    create: XOR<UserCreateWithoutDebtsInput, UserUncheckedCreateWithoutDebtsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtsInput, UserUncheckedUpdateWithoutDebtsInput>
  }

  export type UserUpdateWithoutDebtsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DebtPaymentUpsertWithWhereUniqueWithoutDebtInput = {
    where: DebtPaymentWhereUniqueInput
    update: XOR<DebtPaymentUpdateWithoutDebtInput, DebtPaymentUncheckedUpdateWithoutDebtInput>
    create: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput>
  }

  export type DebtPaymentUpdateWithWhereUniqueWithoutDebtInput = {
    where: DebtPaymentWhereUniqueInput
    data: XOR<DebtPaymentUpdateWithoutDebtInput, DebtPaymentUncheckedUpdateWithoutDebtInput>
  }

  export type DebtPaymentUpdateManyWithWhereWithoutDebtInput = {
    where: DebtPaymentScalarWhereInput
    data: XOR<DebtPaymentUpdateManyMutationInput, DebtPaymentUncheckedUpdateManyWithoutDebtInput>
  }

  export type DebtTagUpsertWithWhereUniqueWithoutDebtInput = {
    where: DebtTagWhereUniqueInput
    update: XOR<DebtTagUpdateWithoutDebtInput, DebtTagUncheckedUpdateWithoutDebtInput>
    create: XOR<DebtTagCreateWithoutDebtInput, DebtTagUncheckedCreateWithoutDebtInput>
  }

  export type DebtTagUpdateWithWhereUniqueWithoutDebtInput = {
    where: DebtTagWhereUniqueInput
    data: XOR<DebtTagUpdateWithoutDebtInput, DebtTagUncheckedUpdateWithoutDebtInput>
  }

  export type DebtTagUpdateManyWithWhereWithoutDebtInput = {
    where: DebtTagScalarWhereInput
    data: XOR<DebtTagUpdateManyMutationInput, DebtTagUncheckedUpdateManyWithoutDebtInput>
  }

  export type DebtTagScalarWhereInput = {
    AND?: DebtTagScalarWhereInput | DebtTagScalarWhereInput[]
    OR?: DebtTagScalarWhereInput[]
    NOT?: DebtTagScalarWhereInput | DebtTagScalarWhereInput[]
    id?: StringFilter<"DebtTag"> | string
    debtId?: StringFilter<"DebtTag"> | string
    tagId?: StringFilter<"DebtTag"> | string
    createdAt?: DateTimeFilter<"DebtTag"> | Date | string
  }

  export type UserCreateWithoutSavingsGoalsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavingsGoalsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavingsGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavingsGoalsInput, UserUncheckedCreateWithoutSavingsGoalsInput>
  }

  export type UserUpsertWithoutSavingsGoalsInput = {
    update: XOR<UserUpdateWithoutSavingsGoalsInput, UserUncheckedUpdateWithoutSavingsGoalsInput>
    create: XOR<UserCreateWithoutSavingsGoalsInput, UserUncheckedCreateWithoutSavingsGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavingsGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavingsGoalsInput, UserUncheckedUpdateWithoutSavingsGoalsInput>
  }

  export type UserUpdateWithoutSavingsGoalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavingsGoalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMandatorySavingsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMandatorySavingsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMandatorySavingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMandatorySavingsInput, UserUncheckedCreateWithoutMandatorySavingsInput>
  }

  export type UserUpsertWithoutMandatorySavingsInput = {
    update: XOR<UserUpdateWithoutMandatorySavingsInput, UserUncheckedUpdateWithoutMandatorySavingsInput>
    create: XOR<UserCreateWithoutMandatorySavingsInput, UserUncheckedCreateWithoutMandatorySavingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMandatorySavingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMandatorySavingsInput, UserUncheckedUpdateWithoutMandatorySavingsInput>
  }

  export type UserUpdateWithoutMandatorySavingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMandatorySavingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlansInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlansInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
  }

  export type PlanItemCreateWithoutPlanInput = {
    id?: string
    date: Date | string
    type: $Enums.PlanItemType
    entityId?: string | null
    amountDollars: number
    notes?: string | null
    balanceSnapshotJson?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type PlanItemUncheckedCreateWithoutPlanInput = {
    id?: string
    date: Date | string
    type: $Enums.PlanItemType
    entityId?: string | null
    amountDollars: number
    notes?: string | null
    balanceSnapshotJson?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type PlanItemCreateOrConnectWithoutPlanInput = {
    where: PlanItemWhereUniqueInput
    create: XOR<PlanItemCreateWithoutPlanInput, PlanItemUncheckedCreateWithoutPlanInput>
  }

  export type PlanItemCreateManyPlanInputEnvelope = {
    data: PlanItemCreateManyPlanInput | PlanItemCreateManyPlanInput[]
  }

  export type UserUpsertWithoutPlansInput = {
    update: XOR<UserUpdateWithoutPlansInput, UserUncheckedUpdateWithoutPlansInput>
    create: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlansInput, UserUncheckedUpdateWithoutPlansInput>
  }

  export type UserUpdateWithoutPlansInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlansInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanItemUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanItemWhereUniqueInput
    update: XOR<PlanItemUpdateWithoutPlanInput, PlanItemUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanItemCreateWithoutPlanInput, PlanItemUncheckedCreateWithoutPlanInput>
  }

  export type PlanItemUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanItemWhereUniqueInput
    data: XOR<PlanItemUpdateWithoutPlanInput, PlanItemUncheckedUpdateWithoutPlanInput>
  }

  export type PlanItemUpdateManyWithWhereWithoutPlanInput = {
    where: PlanItemScalarWhereInput
    data: XOR<PlanItemUpdateManyMutationInput, PlanItemUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanItemScalarWhereInput = {
    AND?: PlanItemScalarWhereInput | PlanItemScalarWhereInput[]
    OR?: PlanItemScalarWhereInput[]
    NOT?: PlanItemScalarWhereInput | PlanItemScalarWhereInput[]
    id?: StringFilter<"PlanItem"> | string
    planId?: StringFilter<"PlanItem"> | string
    date?: DateTimeFilter<"PlanItem"> | Date | string
    type?: EnumPlanItemTypeFilter<"PlanItem"> | $Enums.PlanItemType
    entityId?: StringNullableFilter<"PlanItem"> | string | null
    amountDollars?: FloatFilter<"PlanItem"> | number
    notes?: StringNullableFilter<"PlanItem"> | string | null
    balanceSnapshotJson?: JsonNullableFilter<"PlanItem">
    createdAt?: DateTimeFilter<"PlanItem"> | Date | string
  }

  export type PlanCreateWithoutItemsInput = {
    id?: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
  }

  export type PlanCreateOrConnectWithoutItemsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutItemsInput, PlanUncheckedCreateWithoutItemsInput>
  }

  export type PlanUpsertWithoutItemsInput = {
    update: XOR<PlanUpdateWithoutItemsInput, PlanUncheckedUpdateWithoutItemsInput>
    create: XOR<PlanCreateWithoutItemsInput, PlanUncheckedCreateWithoutItemsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutItemsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutItemsInput, PlanUncheckedUpdateWithoutItemsInput>
  }

  export type PlanUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutItemsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDebtPaymentsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDebtPaymentsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDebtPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtPaymentsInput, UserUncheckedCreateWithoutDebtPaymentsInput>
  }

  export type DebtCreateWithoutPaymentsInput = {
    id?: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDebtsInput
    debtTags?: DebtTagCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutPaymentsInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutDebtPaymentsInput = {
    update: XOR<UserUpdateWithoutDebtPaymentsInput, UserUncheckedUpdateWithoutDebtPaymentsInput>
    create: XOR<UserCreateWithoutDebtPaymentsInput, UserUncheckedCreateWithoutDebtPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtPaymentsInput, UserUncheckedUpdateWithoutDebtPaymentsInput>
  }

  export type UserUpdateWithoutDebtPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DebtUpsertWithoutPaymentsInput = {
    update: XOR<DebtUpdateWithoutPaymentsInput, DebtUncheckedUpdateWithoutPaymentsInput>
    create: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
    where?: DebtWhereInput
  }

  export type DebtUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: DebtWhereInput
    data: XOR<DebtUpdateWithoutPaymentsInput, DebtUncheckedUpdateWithoutPaymentsInput>
  }

  export type DebtUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDebtsNestedInput
    debtTags?: DebtTagUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutPaymentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtTags?: DebtTagUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type UserCreateWithoutPlaidItemsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    tags?: TagCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaidItemsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    tags?: TagUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaidItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaidItemsInput, UserUncheckedCreateWithoutPlaidItemsInput>
  }

  export type AccountCreateWithoutPlaidItemInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutPlaidItemInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutPlaidItemInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPlaidItemInput, AccountUncheckedCreateWithoutPlaidItemInput>
  }

  export type AccountCreateManyPlaidItemInputEnvelope = {
    data: AccountCreateManyPlaidItemInput | AccountCreateManyPlaidItemInput[]
  }

  export type UserUpsertWithoutPlaidItemsInput = {
    update: XOR<UserUpdateWithoutPlaidItemsInput, UserUncheckedUpdateWithoutPlaidItemsInput>
    create: XOR<UserCreateWithoutPlaidItemsInput, UserUncheckedCreateWithoutPlaidItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaidItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaidItemsInput, UserUncheckedUpdateWithoutPlaidItemsInput>
  }

  export type UserUpdateWithoutPlaidItemsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    tags?: TagUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaidItemsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    tags?: TagUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutPlaidItemInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutPlaidItemInput, AccountUncheckedUpdateWithoutPlaidItemInput>
    create: XOR<AccountCreateWithoutPlaidItemInput, AccountUncheckedCreateWithoutPlaidItemInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutPlaidItemInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutPlaidItemInput, AccountUncheckedUpdateWithoutPlaidItemInput>
  }

  export type AccountUpdateManyWithWhereWithoutPlaidItemInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutPlaidItemInput>
  }

  export type UserCreateWithoutTagsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bills?: BillCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamCreateNestedManyWithoutUserInput
    debts?: DebtCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsCreateNestedOneWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    tagRules?: TagRuleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagsInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    incomeStreams?: IncomeStreamUncheckedCreateNestedManyWithoutUserInput
    debts?: DebtUncheckedCreateNestedManyWithoutUserInput
    debtPayments?: DebtPaymentUncheckedCreateNestedManyWithoutUserInput
    savingsGoals?: SavingsGoalUncheckedCreateNestedManyWithoutUserInput
    mandatorySavings?: MandatorySavingsUncheckedCreateNestedOneWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    plaidItems?: PlaidItemUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    tagRules?: TagRuleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
  }

  export type TransactionTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutTransactionTagsInput
  }

  export type TransactionTagUncheckedCreateWithoutTagInput = {
    id?: string
    transactionId: string
    createdAt?: Date | string
  }

  export type TransactionTagCreateOrConnectWithoutTagInput = {
    where: TransactionTagWhereUniqueInput
    create: XOR<TransactionTagCreateWithoutTagInput, TransactionTagUncheckedCreateWithoutTagInput>
  }

  export type TransactionTagCreateManyTagInputEnvelope = {
    data: TransactionTagCreateManyTagInput | TransactionTagCreateManyTagInput[]
  }

  export type IncomeStreamTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    incomeStream: IncomeStreamCreateNestedOneWithoutIncomeStreamTagsInput
  }

  export type IncomeStreamTagUncheckedCreateWithoutTagInput = {
    id?: string
    incomeStreamId: string
    createdAt?: Date | string
  }

  export type IncomeStreamTagCreateOrConnectWithoutTagInput = {
    where: IncomeStreamTagWhereUniqueInput
    create: XOR<IncomeStreamTagCreateWithoutTagInput, IncomeStreamTagUncheckedCreateWithoutTagInput>
  }

  export type IncomeStreamTagCreateManyTagInputEnvelope = {
    data: IncomeStreamTagCreateManyTagInput | IncomeStreamTagCreateManyTagInput[]
  }

  export type DebtTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    debt: DebtCreateNestedOneWithoutDebtTagsInput
  }

  export type DebtTagUncheckedCreateWithoutTagInput = {
    id?: string
    debtId: string
    createdAt?: Date | string
  }

  export type DebtTagCreateOrConnectWithoutTagInput = {
    where: DebtTagWhereUniqueInput
    create: XOR<DebtTagCreateWithoutTagInput, DebtTagUncheckedCreateWithoutTagInput>
  }

  export type DebtTagCreateManyTagInputEnvelope = {
    data: DebtTagCreateManyTagInput | DebtTagCreateManyTagInput[]
  }

  export type BudgetCreateWithoutTagInput = {
    id?: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
    category?: CategoryCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutTagInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId?: string | null
    createdAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutTagInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutTagInput, BudgetUncheckedCreateWithoutTagInput>
  }

  export type BudgetCreateManyTagInputEnvelope = {
    data: BudgetCreateManyTagInput | BudgetCreateManyTagInput[]
  }

  export type TagRuleTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    tagRule: TagRuleCreateNestedOneWithoutTagsInput
  }

  export type TagRuleTagUncheckedCreateWithoutTagInput = {
    id?: string
    tagRuleId: string
    createdAt?: Date | string
  }

  export type TagRuleTagCreateOrConnectWithoutTagInput = {
    where: TagRuleTagWhereUniqueInput
    create: XOR<TagRuleTagCreateWithoutTagInput, TagRuleTagUncheckedCreateWithoutTagInput>
  }

  export type TagRuleTagCreateManyTagInputEnvelope = {
    data: TagRuleTagCreateManyTagInput | TagRuleTagCreateManyTagInput[]
  }

  export type UserUpsertWithoutTagsInput = {
    update: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserUpdateWithoutTagsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bills?: BillUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUpdateManyWithoutUserNestedInput
    debts?: DebtUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUpdateOneWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    incomeStreams?: IncomeStreamUncheckedUpdateManyWithoutUserNestedInput
    debts?: DebtUncheckedUpdateManyWithoutUserNestedInput
    debtPayments?: DebtPaymentUncheckedUpdateManyWithoutUserNestedInput
    savingsGoals?: SavingsGoalUncheckedUpdateManyWithoutUserNestedInput
    mandatorySavings?: MandatorySavingsUncheckedUpdateOneWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    plaidItems?: PlaidItemUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    tagRules?: TagRuleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TransactionTagWhereUniqueInput
    update: XOR<TransactionTagUpdateWithoutTagInput, TransactionTagUncheckedUpdateWithoutTagInput>
    create: XOR<TransactionTagCreateWithoutTagInput, TransactionTagUncheckedCreateWithoutTagInput>
  }

  export type TransactionTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TransactionTagWhereUniqueInput
    data: XOR<TransactionTagUpdateWithoutTagInput, TransactionTagUncheckedUpdateWithoutTagInput>
  }

  export type TransactionTagUpdateManyWithWhereWithoutTagInput = {
    where: TransactionTagScalarWhereInput
    data: XOR<TransactionTagUpdateManyMutationInput, TransactionTagUncheckedUpdateManyWithoutTagInput>
  }

  export type IncomeStreamTagUpsertWithWhereUniqueWithoutTagInput = {
    where: IncomeStreamTagWhereUniqueInput
    update: XOR<IncomeStreamTagUpdateWithoutTagInput, IncomeStreamTagUncheckedUpdateWithoutTagInput>
    create: XOR<IncomeStreamTagCreateWithoutTagInput, IncomeStreamTagUncheckedCreateWithoutTagInput>
  }

  export type IncomeStreamTagUpdateWithWhereUniqueWithoutTagInput = {
    where: IncomeStreamTagWhereUniqueInput
    data: XOR<IncomeStreamTagUpdateWithoutTagInput, IncomeStreamTagUncheckedUpdateWithoutTagInput>
  }

  export type IncomeStreamTagUpdateManyWithWhereWithoutTagInput = {
    where: IncomeStreamTagScalarWhereInput
    data: XOR<IncomeStreamTagUpdateManyMutationInput, IncomeStreamTagUncheckedUpdateManyWithoutTagInput>
  }

  export type DebtTagUpsertWithWhereUniqueWithoutTagInput = {
    where: DebtTagWhereUniqueInput
    update: XOR<DebtTagUpdateWithoutTagInput, DebtTagUncheckedUpdateWithoutTagInput>
    create: XOR<DebtTagCreateWithoutTagInput, DebtTagUncheckedCreateWithoutTagInput>
  }

  export type DebtTagUpdateWithWhereUniqueWithoutTagInput = {
    where: DebtTagWhereUniqueInput
    data: XOR<DebtTagUpdateWithoutTagInput, DebtTagUncheckedUpdateWithoutTagInput>
  }

  export type DebtTagUpdateManyWithWhereWithoutTagInput = {
    where: DebtTagScalarWhereInput
    data: XOR<DebtTagUpdateManyMutationInput, DebtTagUncheckedUpdateManyWithoutTagInput>
  }

  export type BudgetUpsertWithWhereUniqueWithoutTagInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutTagInput, BudgetUncheckedUpdateWithoutTagInput>
    create: XOR<BudgetCreateWithoutTagInput, BudgetUncheckedCreateWithoutTagInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutTagInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutTagInput, BudgetUncheckedUpdateWithoutTagInput>
  }

  export type BudgetUpdateManyWithWhereWithoutTagInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutTagInput>
  }

  export type TagRuleTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TagRuleTagWhereUniqueInput
    update: XOR<TagRuleTagUpdateWithoutTagInput, TagRuleTagUncheckedUpdateWithoutTagInput>
    create: XOR<TagRuleTagCreateWithoutTagInput, TagRuleTagUncheckedCreateWithoutTagInput>
  }

  export type TagRuleTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TagRuleTagWhereUniqueInput
    data: XOR<TagRuleTagUpdateWithoutTagInput, TagRuleTagUncheckedUpdateWithoutTagInput>
  }

  export type TagRuleTagUpdateManyWithWhereWithoutTagInput = {
    where: TagRuleTagScalarWhereInput
    data: XOR<TagRuleTagUpdateManyMutationInput, TagRuleTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TagRuleCreateWithoutTagsInput = {
    id?: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTagRulesInput
  }

  export type TagRuleUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagRuleCreateOrConnectWithoutTagsInput = {
    where: TagRuleWhereUniqueInput
    create: XOR<TagRuleCreateWithoutTagsInput, TagRuleUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutTagRuleTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutTagInput
    debtTags?: DebtTagCreateNestedManyWithoutTagInput
    budgets?: BudgetCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTagRuleTagsInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutTagInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTagRuleTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTagRuleTagsInput, TagUncheckedCreateWithoutTagRuleTagsInput>
  }

  export type TagRuleUpsertWithoutTagsInput = {
    update: XOR<TagRuleUpdateWithoutTagsInput, TagRuleUncheckedUpdateWithoutTagsInput>
    create: XOR<TagRuleCreateWithoutTagsInput, TagRuleUncheckedCreateWithoutTagsInput>
    where?: TagRuleWhereInput
  }

  export type TagRuleUpdateToOneWithWhereWithoutTagsInput = {
    where?: TagRuleWhereInput
    data: XOR<TagRuleUpdateWithoutTagsInput, TagRuleUncheckedUpdateWithoutTagsInput>
  }

  export type TagRuleUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagRulesNestedInput
  }

  export type TagRuleUncheckedUpdateWithoutTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutTagRuleTagsInput = {
    update: XOR<TagUpdateWithoutTagRuleTagsInput, TagUncheckedUpdateWithoutTagRuleTagsInput>
    create: XOR<TagCreateWithoutTagRuleTagsInput, TagUncheckedCreateWithoutTagRuleTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTagRuleTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTagRuleTagsInput, TagUncheckedUpdateWithoutTagRuleTagsInput>
  }

  export type TagUpdateWithoutTagRuleTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUpdateManyWithoutTagNestedInput
    budgets?: BudgetUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTagRuleTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutTagNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TransactionCreateWithoutTransactionTagsInput = {
    id?: string
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTransactionTagsInput = {
    id?: string
    userId: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTransactionTagsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTransactionTagsInput, TransactionUncheckedCreateWithoutTransactionTagsInput>
  }

  export type TagCreateWithoutTransactionTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutTagInput
    debtTags?: DebtTagCreateNestedManyWithoutTagInput
    budgets?: BudgetCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTransactionTagsInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutTagInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTransactionTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTransactionTagsInput, TagUncheckedCreateWithoutTransactionTagsInput>
  }

  export type TransactionUpsertWithoutTransactionTagsInput = {
    update: XOR<TransactionUpdateWithoutTransactionTagsInput, TransactionUncheckedUpdateWithoutTransactionTagsInput>
    create: XOR<TransactionCreateWithoutTransactionTagsInput, TransactionUncheckedCreateWithoutTransactionTagsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutTransactionTagsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutTransactionTagsInput, TransactionUncheckedUpdateWithoutTransactionTagsInput>
  }

  export type TransactionUpdateWithoutTransactionTagsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTransactionTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutTransactionTagsInput = {
    update: XOR<TagUpdateWithoutTransactionTagsInput, TagUncheckedUpdateWithoutTransactionTagsInput>
    create: XOR<TagCreateWithoutTransactionTagsInput, TagUncheckedCreateWithoutTransactionTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTransactionTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTransactionTagsInput, TagUncheckedUpdateWithoutTransactionTagsInput>
  }

  export type TagUpdateWithoutTransactionTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUpdateManyWithoutTagNestedInput
    budgets?: BudgetUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTransactionTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutTagNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type IncomeStreamCreateWithoutIncomeStreamTagsInput = {
    id?: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutIncomeStreamsInput
  }

  export type IncomeStreamUncheckedCreateWithoutIncomeStreamTagsInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
  }

  export type IncomeStreamCreateOrConnectWithoutIncomeStreamTagsInput = {
    where: IncomeStreamWhereUniqueInput
    create: XOR<IncomeStreamCreateWithoutIncomeStreamTagsInput, IncomeStreamUncheckedCreateWithoutIncomeStreamTagsInput>
  }

  export type TagCreateWithoutIncomeStreamTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTagInput
    debtTags?: DebtTagCreateNestedManyWithoutTagInput
    budgets?: BudgetCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutIncomeStreamTagsInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTagInput
    debtTags?: DebtTagUncheckedCreateNestedManyWithoutTagInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutIncomeStreamTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutIncomeStreamTagsInput, TagUncheckedCreateWithoutIncomeStreamTagsInput>
  }

  export type IncomeStreamUpsertWithoutIncomeStreamTagsInput = {
    update: XOR<IncomeStreamUpdateWithoutIncomeStreamTagsInput, IncomeStreamUncheckedUpdateWithoutIncomeStreamTagsInput>
    create: XOR<IncomeStreamCreateWithoutIncomeStreamTagsInput, IncomeStreamUncheckedCreateWithoutIncomeStreamTagsInput>
    where?: IncomeStreamWhereInput
  }

  export type IncomeStreamUpdateToOneWithWhereWithoutIncomeStreamTagsInput = {
    where?: IncomeStreamWhereInput
    data: XOR<IncomeStreamUpdateWithoutIncomeStreamTagsInput, IncomeStreamUncheckedUpdateWithoutIncomeStreamTagsInput>
  }

  export type IncomeStreamUpdateWithoutIncomeStreamTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIncomeStreamsNestedInput
  }

  export type IncomeStreamUncheckedUpdateWithoutIncomeStreamTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutIncomeStreamTagsInput = {
    update: XOR<TagUpdateWithoutIncomeStreamTagsInput, TagUncheckedUpdateWithoutIncomeStreamTagsInput>
    create: XOR<TagCreateWithoutIncomeStreamTagsInput, TagUncheckedCreateWithoutIncomeStreamTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutIncomeStreamTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutIncomeStreamTagsInput, TagUncheckedUpdateWithoutIncomeStreamTagsInput>
  }

  export type TagUpdateWithoutIncomeStreamTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUpdateManyWithoutTagNestedInput
    budgets?: BudgetUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutIncomeStreamTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutTagNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type DebtCreateWithoutDebtTagsInput = {
    id?: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDebtsInput
    payments?: DebtPaymentCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutDebtTagsInput = {
    id?: string
    userId: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
    payments?: DebtPaymentUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutDebtTagsInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutDebtTagsInput, DebtUncheckedCreateWithoutDebtTagsInput>
  }

  export type TagCreateWithoutDebtTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    transactionTags?: TransactionTagCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagCreateNestedManyWithoutTagInput
    budgets?: BudgetCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutDebtTagsInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    transactionTags?: TransactionTagUncheckedCreateNestedManyWithoutTagInput
    incomeStreamTags?: IncomeStreamTagUncheckedCreateNestedManyWithoutTagInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTagInput
    tagRuleTags?: TagRuleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutDebtTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutDebtTagsInput, TagUncheckedCreateWithoutDebtTagsInput>
  }

  export type DebtUpsertWithoutDebtTagsInput = {
    update: XOR<DebtUpdateWithoutDebtTagsInput, DebtUncheckedUpdateWithoutDebtTagsInput>
    create: XOR<DebtCreateWithoutDebtTagsInput, DebtUncheckedCreateWithoutDebtTagsInput>
    where?: DebtWhereInput
  }

  export type DebtUpdateToOneWithWhereWithoutDebtTagsInput = {
    where?: DebtWhereInput
    data: XOR<DebtUpdateWithoutDebtTagsInput, DebtUncheckedUpdateWithoutDebtTagsInput>
  }

  export type DebtUpdateWithoutDebtTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDebtsNestedInput
    payments?: DebtPaymentUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutDebtTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type TagUpsertWithoutDebtTagsInput = {
    update: XOR<TagUpdateWithoutDebtTagsInput, TagUncheckedUpdateWithoutDebtTagsInput>
    create: XOR<TagCreateWithoutDebtTagsInput, TagUncheckedCreateWithoutDebtTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutDebtTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutDebtTagsInput, TagUncheckedUpdateWithoutDebtTagsInput>
  }

  export type TagUpdateWithoutDebtTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutTagNestedInput
    budgets?: BudgetUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutDebtTagsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidItemId?: string | null
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
  }

  export type CategoryCreateManyUserInput = {
    id?: string
    name: string
    kind: $Enums.CategoryKind
    createdAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TagCreateManyUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type BillCreateManyUserInput = {
    id?: string
    name: string
    amountDollars: number
    dueDayOfMonth?: number | null
    dueDate?: Date | string | null
    frequency: $Enums.BillFrequency
    isEssential?: boolean
    autopay?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    name: string
    amountDollars: number
    billingDayOfMonth: number
    frequency: $Enums.SubscriptionFrequency
    cancelable: boolean
    createdAt?: Date | string
  }

  export type IncomeStreamCreateManyUserInput = {
    id?: string
    name: string
    amountDollars: number
    lastAmountDollars?: number | null
    cadence: $Enums.IncomeCadence
    nextPayDate: Date | string
    createdAt?: Date | string
  }

  export type DebtCreateManyUserInput = {
    id?: string
    name: string
    principalDollars: number
    aprBps: number
    minPaymentDollars: number
    estimatedMonthlyPaymentDollars?: number | null
    dueDayOfMonth: number
    estimatedPayoffDate?: Date | string | null
    createdAt?: Date | string
  }

  export type DebtPaymentCreateManyUserInput = {
    id?: string
    debtId: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type SavingsGoalCreateManyUserInput = {
    id?: string
    name: string
    targetDollars: number
    currentDollars: number
    ruleType: $Enums.SavingsRuleType
    ruleValueBpsOrDollars: number
    priority?: number
    createdAt?: Date | string
  }

  export type PlanCreateManyUserInput = {
    id?: string
    name: string
    strategy: $Enums.PlanStrategy
    horizonMonths: number
    startDate: Date | string
    rulesJson: InputJsonValue
    summaryJson: InputJsonValue
    warningsJson: InputJsonValue
    createdAt?: Date | string
  }

  export type PlaidItemCreateManyUserInput = {
    id?: string
    itemId: string
    accessTokenEncrypted: string
    institutionId?: string | null
    institutionName?: string | null
    transactionsCursor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyUserInput = {
    id?: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId?: string | null
    tagId?: string | null
    createdAt?: Date | string
  }

  export type TagRuleCreateManyUserInput = {
    id?: string
    name: string
    pattern: string
    matchType: $Enums.TagRuleMatchType
    sourceField: $Enums.TagRuleSourceField
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    entityType?: string | null
    entityId?: string | null
    milestonePct?: number | null
    message: string
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plaidItem?: PlaidItemUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidItemId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidItemId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    kind?: EnumCategoryKindFieldUpdateOperationsInput | $Enums.CategoryKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUpdateManyWithoutTagNestedInput
    budgets?: BudgetUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTagNestedInput
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutTagNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutTagNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTagNestedInput
    tagRuleTags?: TagRuleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    dueDayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    frequency?: EnumBillFrequencyFieldUpdateOperationsInput | $Enums.BillFrequency
    isEssential?: BoolFieldUpdateOperationsInput | boolean
    autopay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    billingDayOfMonth?: IntFieldUpdateOperationsInput | number
    frequency?: EnumSubscriptionFrequencyFieldUpdateOperationsInput | $Enums.SubscriptionFrequency
    cancelable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomeStreamTags?: IncomeStreamTagUpdateManyWithoutIncomeStreamNestedInput
  }

  export type IncomeStreamUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomeStreamTags?: IncomeStreamTagUncheckedUpdateManyWithoutIncomeStreamNestedInput
  }

  export type IncomeStreamUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    lastAmountDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    cadence?: EnumIncomeCadenceFieldUpdateOperationsInput | $Enums.IncomeCadence
    nextPayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUpdateManyWithoutDebtNestedInput
    debtTags?: DebtTagUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput
    debtTags?: DebtTagUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    principalDollars?: FloatFieldUpdateOperationsInput | number
    aprBps?: IntFieldUpdateOperationsInput | number
    minPaymentDollars?: FloatFieldUpdateOperationsInput | number
    estimatedMonthlyPaymentDollars?: NullableFloatFieldUpdateOperationsInput | number | null
    dueDayOfMonth?: IntFieldUpdateOperationsInput | number
    estimatedPayoffDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUpdateWithoutUserInput = {
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type DebtPaymentUncheckedUpdateWithoutUserInput = {
    debtId?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUncheckedUpdateManyWithoutUserInput = {
    debtId?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavingsGoalUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavingsGoalUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavingsGoalUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetDollars?: FloatFieldUpdateOperationsInput | number
    currentDollars?: FloatFieldUpdateOperationsInput | number
    ruleType?: EnumSavingsRuleTypeFieldUpdateOperationsInput | $Enums.SavingsRuleType
    ruleValueBpsOrDollars?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PlanItemUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PlanItemUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumPlanStrategyFieldUpdateOperationsInput | $Enums.PlanStrategy
    horizonMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rulesJson?: InputJsonValue | InputJsonValue
    summaryJson?: InputJsonValue | InputJsonValue
    warningsJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaidItemUpdateWithoutUserInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutPlaidItemNestedInput
  }

  export type PlaidItemUncheckedUpdateWithoutUserInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutPlaidItemNestedInput
  }

  export type PlaidItemUncheckedUpdateManyWithoutUserInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    accessTokenEncrypted?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionsCursor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutBudgetsNestedInput
    tag?: TagUpdateOneWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagRuleTagUpdateManyWithoutTagRuleNestedInput
  }

  export type TagRuleUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagRuleTagUncheckedUpdateManyWithoutTagRuleNestedInput
  }

  export type TagRuleUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    pattern?: StringFieldUpdateOperationsInput | string
    matchType?: EnumTagRuleMatchTypeFieldUpdateOperationsInput | $Enums.TagRuleMatchType
    sourceField?: EnumTagRuleSourceFieldFieldUpdateOperationsInput | $Enums.TagRuleSourceField
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    milestonePct?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    userId: string
    date: Date | string
    amountDollars: number
    categoryId?: string | null
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutAccountInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyCategoryInput = {
    id?: string
    userId: string
    accountId?: string | null
    date: Date | string
    amountDollars: number
    merchant?: string | null
    note?: string | null
    plaidTransactionId?: string | null
    pending?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BudgetCreateManyCategoryInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    tagId?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutCategoryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    transactionTags?: TransactionTagUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    plaidTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    pending?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
    tag?: TagUpdateOneWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagCreateManyTransactionInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type TransactionTagUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutTransactionTagsNestedInput
  }

  export type TransactionTagUncheckedUpdateWithoutTransactionInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagUncheckedUpdateManyWithoutTransactionInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagCreateManyTagRuleInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type TagRuleTagUpdateWithoutTagRuleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutTagRuleTagsNestedInput
  }

  export type TagRuleTagUncheckedUpdateWithoutTagRuleInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagUncheckedUpdateManyWithoutTagRuleInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagCreateManyIncomeStreamInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type IncomeStreamTagUpdateWithoutIncomeStreamInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutIncomeStreamTagsNestedInput
  }

  export type IncomeStreamTagUncheckedUpdateWithoutIncomeStreamInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagUncheckedUpdateManyWithoutIncomeStreamInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentCreateManyDebtInput = {
    id?: string
    userId: string
    amountDollars: number
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type DebtTagCreateManyDebtInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type DebtPaymentUpdateWithoutDebtInput = {
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDebtPaymentsNestedInput
  }

  export type DebtPaymentUncheckedUpdateWithoutDebtInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUncheckedUpdateManyWithoutDebtInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagUpdateWithoutDebtInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutDebtTagsNestedInput
  }

  export type DebtTagUncheckedUpdateWithoutDebtInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagUncheckedUpdateManyWithoutDebtInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanItemCreateManyPlanInput = {
    id?: string
    date: Date | string
    type: $Enums.PlanItemType
    entityId?: string | null
    amountDollars: number
    notes?: string | null
    balanceSnapshotJson?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type PlanItemUpdateWithoutPlanInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanItemUncheckedUpdateWithoutPlanInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanItemUncheckedUpdateManyWithoutPlanInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPlanItemTypeFieldUpdateOperationsInput | $Enums.PlanItemType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    amountDollars?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    balanceSnapshotJson?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyPlaidItemInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.AccountType
    currency: string
    plaidAccountId?: string | null
    plaidMask?: string | null
    plaidType?: string | null
    plaidSubtype?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutPlaidItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPlaidItemInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutPlaidItemInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    currency?: StringFieldUpdateOperationsInput | string
    plaidAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    plaidMask?: NullableStringFieldUpdateOperationsInput | string | null
    plaidType?: NullableStringFieldUpdateOperationsInput | string | null
    plaidSubtype?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagCreateManyTagInput = {
    id?: string
    transactionId: string
    createdAt?: Date | string
  }

  export type IncomeStreamTagCreateManyTagInput = {
    id?: string
    incomeStreamId: string
    createdAt?: Date | string
  }

  export type DebtTagCreateManyTagInput = {
    id?: string
    debtId: string
    createdAt?: Date | string
  }

  export type BudgetCreateManyTagInput = {
    id?: string
    userId: string
    name: string
    amountDollars: number
    period: $Enums.BudgetPeriod
    categoryId?: string | null
    createdAt?: Date | string
  }

  export type TagRuleTagCreateManyTagInput = {
    id?: string
    tagRuleId: string
    createdAt?: Date | string
  }

  export type TransactionTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutTransactionTagsNestedInput
  }

  export type TransactionTagUncheckedUpdateWithoutTagInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagUncheckedUpdateManyWithoutTagInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomeStream?: IncomeStreamUpdateOneRequiredWithoutIncomeStreamTagsNestedInput
  }

  export type IncomeStreamTagUncheckedUpdateWithoutTagInput = {
    incomeStreamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeStreamTagUncheckedUpdateManyWithoutTagInput = {
    incomeStreamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneRequiredWithoutDebtTagsNestedInput
  }

  export type DebtTagUncheckedUpdateWithoutTagInput = {
    debtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtTagUncheckedUpdateManyWithoutTagInput = {
    debtId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
    category?: CategoryUpdateOneWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutTagInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutTagInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amountDollars?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagRule?: TagRuleUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagRuleTagUncheckedUpdateWithoutTagInput = {
    tagRuleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagRuleTagUncheckedUpdateManyWithoutTagInput = {
    tagRuleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionCountOutputTypeDefaultArgs instead
     */
    export type TransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagRuleCountOutputTypeDefaultArgs instead
     */
    export type TagRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncomeStreamCountOutputTypeDefaultArgs instead
     */
    export type IncomeStreamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncomeStreamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DebtCountOutputTypeDefaultArgs instead
     */
    export type DebtCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DebtCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlaidItemCountOutputTypeDefaultArgs instead
     */
    export type PlaidItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlaidItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagRuleDefaultArgs instead
     */
    export type TagRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDefaultArgs instead
     */
    export type BudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillDefaultArgs instead
     */
    export type BillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncomeStreamDefaultArgs instead
     */
    export type IncomeStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncomeStreamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DebtDefaultArgs instead
     */
    export type DebtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DebtDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavingsGoalDefaultArgs instead
     */
    export type SavingsGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavingsGoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MandatorySavingsDefaultArgs instead
     */
    export type MandatorySavingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MandatorySavingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanItemDefaultArgs instead
     */
    export type PlanItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DebtPaymentDefaultArgs instead
     */
    export type DebtPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DebtPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlaidItemDefaultArgs instead
     */
    export type PlaidItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlaidItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagRuleTagDefaultArgs instead
     */
    export type TagRuleTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagRuleTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionTagDefaultArgs instead
     */
    export type TransactionTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncomeStreamTagDefaultArgs instead
     */
    export type IncomeStreamTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncomeStreamTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DebtTagDefaultArgs instead
     */
    export type DebtTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DebtTagDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}